
module vulkan::vk;

const NULL_HANDLE = ((void*)0);

macro @makeVersion(#major, #minor, #patch) {
  return ((#major) << 22) | ((#minor) << 12) | (#patch);
}

macro @makeApiVersion(#variant, #major, #minor, #patch) {
  return (((uint)(#variant)) << 29U) | (((uint)(#major)) << 22U) | (((uint)(#minor)) << 12U) | ((uint)(#patch));
}

const API_VERSION_1_0 = @makeApiVersion(0,1,0,0);

const HEADER_VERSION = 203;

const HEADER_VERSION_COMPLETE = @makeApiVersion(0,1,2,HEADER_VERSION);

macro @versionMajor(#version) {
  return (uint)(#version) >> 22;
}

macro @versionMinor(#version) {
  return ((uint)(#version) >> 12) & 0x3ff;
}

macro @versionPatch(#version) {
  return (uint)(#version) & 0xfff;
}

macro @apiVersionVariant(#version) {
  return (uint)(#version) >> 29U;
}

macro @apiVersionMajor(#version) {
  return ((uint)(#version) >> 22U) & 0x7FU;
}

macro @apiVersionMinor(#version) {
  return ((uint)(#version) >> 12U) & 0x3FFU;
}

macro @apiVersionPatch(#version) {
  return (uint)(#version) & 0xFFFU;
}

const UUID_SIZE = 16U;

const ATTACHMENT_UNUSED = (~0U);

const FALSE = 0U;

const LOD_CLAMP_NONE = 1000.0F;

const QUEUE_FAMILY_IGNORED = (~0U);

const REMAINING_ARRAY_LAYERS = (~0U);

const REMAINING_MIP_LEVELS = (~0U);

const SUBPASS_EXTERNAL = (~0U);

const TRUE = 1U;

const WHOLE_SIZE = (~0UL);

const MAX_MEMORY_TYPES = 32U;

const MAX_MEMORY_HEAPS = 16U;

const MAX_PHYSICAL_DEVICE_NAME_SIZE = 256U;

const MAX_EXTENSION_NAME_SIZE = 256U;

const MAX_DESCRIPTION_SIZE = 256U;

const VERSION_1_1 = 1;

const API_VERSION_1_1 = @makeApiVersion(0,1,1,0);

const MAX_DEVICE_GROUP_SIZE = 32U;

const LUID_SIZE = 8U;

const QUEUE_FAMILY_EXTERNAL = ~0U-1U;

const VERSION_1_2 = 1;

const API_VERSION_1_2 = @makeApiVersion(0,1,2,0);

const MAX_DRIVER_NAME_SIZE = 256U;

const MAX_DRIVER_INFO_SIZE = 256U;

const KHR_SURFACE = 1;

const KHR_SURFACE_SPEC_VERSION = 25;

const KHR_SURFACE_EXTENSION_NAME = "VK_KHR_surface";

const KHR_SWAPCHAIN = 1;

const KHR_SWAPCHAIN_SPEC_VERSION = 70;

const KHR_SWAPCHAIN_EXTENSION_NAME = "VK_KHR_swapchain";

const KHR_DISPLAY = 1;

const KHR_DISPLAY_SPEC_VERSION = 23;

const KHR_DISPLAY_EXTENSION_NAME = "VK_KHR_display";

const KHR_DISPLAY_SWAPCHAIN = 1;

const KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION = 10;

const KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME = "VK_KHR_display_swapchain";

const KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE = 1;

const KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_SPEC_VERSION = 3;

const KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME = "VK_KHR_sampler_mirror_clamp_to_edge";

const KHR_DYNAMIC_RENDERING = 1;

const KHR_DYNAMIC_RENDERING_SPEC_VERSION = 1;

const KHR_DYNAMIC_RENDERING_EXTENSION_NAME = "VK_KHR_dynamic_rendering";

const KHR_MULTIVIEW = 1;

const KHR_MULTIVIEW_SPEC_VERSION = 1;

const KHR_MULTIVIEW_EXTENSION_NAME = "VK_KHR_multiview";

const KHR_GET_PHYSICAL_DEVICE_PROPERTIES2 = 1;

const KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_SPEC_VERSION = 2;

const KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME = "VK_KHR_get_physical_device_properties2";

const KHR_DEVICE_GROUP = 1;

const KHR_DEVICE_GROUP_SPEC_VERSION = 4;

const KHR_DEVICE_GROUP_EXTENSION_NAME = "VK_KHR_device_group";

const KHR_SHADER_DRAW_PARAMETERS = 1;

const KHR_SHADER_DRAW_PARAMETERS_SPEC_VERSION = 1;

const KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME = "VK_KHR_shader_draw_parameters";

const KHR_MAINTENANCE1 = 1;

const KHR_MAINTENANCE_1_SPEC_VERSION = 2;

const KHR_MAINTENANCE_1_EXTENSION_NAME = "VK_KHR_maintenance1";

const KHR_MAINTENANCE1_SPEC_VERSION = KHR_MAINTENANCE_1_SPEC_VERSION;

const KHR_MAINTENANCE1_EXTENSION_NAME = KHR_MAINTENANCE_1_EXTENSION_NAME;

const KHR_DEVICE_GROUP_CREATION = 1;

const KHR_DEVICE_GROUP_CREATION_SPEC_VERSION = 1;

const KHR_DEVICE_GROUP_CREATION_EXTENSION_NAME = "VK_KHR_device_group_creation";

const MAX_DEVICE_GROUP_SIZE_KHR = MAX_DEVICE_GROUP_SIZE;

const KHR_EXTERNAL_MEMORY_CAPABILITIES = 1;

const KHR_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION = 1;

const KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME = "VK_KHR_external_memory_capabilities";

const LUID_SIZE_KHR = LUID_SIZE;

const KHR_EXTERNAL_MEMORY = 1;

const KHR_EXTERNAL_MEMORY_SPEC_VERSION = 1;

const KHR_EXTERNAL_MEMORY_EXTENSION_NAME = "VK_KHR_external_memory";

const QUEUE_FAMILY_EXTERNAL_KHR = QUEUE_FAMILY_EXTERNAL;

const KHR_EXTERNAL_MEMORY_FD = 1;

const KHR_EXTERNAL_MEMORY_FD_SPEC_VERSION = 1;

const KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME = "VK_KHR_external_memory_fd";

const KHR_EXTERNAL_SEMAPHORE_CAPABILITIES = 1;

const KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_SPEC_VERSION = 1;

const KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME = "VK_KHR_external_semaphore_capabilities";

const KHR_EXTERNAL_SEMAPHORE = 1;

const KHR_EXTERNAL_SEMAPHORE_SPEC_VERSION = 1;

const KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME = "VK_KHR_external_semaphore";

const KHR_EXTERNAL_SEMAPHORE_FD = 1;

const KHR_EXTERNAL_SEMAPHORE_FD_SPEC_VERSION = 1;

const KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME = "VK_KHR_external_semaphore_fd";

const KHR_PUSH_DESCRIPTOR = 1;

const KHR_PUSH_DESCRIPTOR_SPEC_VERSION = 2;

const KHR_PUSH_DESCRIPTOR_EXTENSION_NAME = "VK_KHR_push_descriptor";

const KHR_SHADER_FLOAT16_INT8 = 1;

const KHR_SHADER_FLOAT16_INT8_SPEC_VERSION = 1;

const KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME = "VK_KHR_shader_float16_int8";

const KHR_16BIT_STORAGE = 1;

const KHR_16BIT_STORAGE_SPEC_VERSION = 1;

const KHR_16BIT_STORAGE_EXTENSION_NAME = "VK_KHR_16bit_storage";

const KHR_INCREMENTAL_PRESENT = 1;

const KHR_INCREMENTAL_PRESENT_SPEC_VERSION = 2;

const KHR_INCREMENTAL_PRESENT_EXTENSION_NAME = "VK_KHR_incremental_present";

const KHR_DESCRIPTOR_UPDATE_TEMPLATE = 1;

const KHR_DESCRIPTOR_UPDATE_TEMPLATE_SPEC_VERSION = 1;

const KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME = "VK_KHR_descriptor_update_template";

const KHR_IMAGELESS_FRAMEBUFFER = 1;

const KHR_IMAGELESS_FRAMEBUFFER_SPEC_VERSION = 1;

const KHR_IMAGELESS_FRAMEBUFFER_EXTENSION_NAME = "VK_KHR_imageless_framebuffer";

const KHR_CREATE_RENDERPASS2 = 1;

const KHR_CREATE_RENDERPASS_2_SPEC_VERSION = 1;

const KHR_CREATE_RENDERPASS_2_EXTENSION_NAME = "VK_KHR_create_renderpass2";

const KHR_SHARED_PRESENTABLE_IMAGE = 1;

const KHR_SHARED_PRESENTABLE_IMAGE_SPEC_VERSION = 1;

const KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME = "VK_KHR_shared_presentable_image";

const KHR_EXTERNAL_FENCE_CAPABILITIES = 1;

const KHR_EXTERNAL_FENCE_CAPABILITIES_SPEC_VERSION = 1;

const KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME = "VK_KHR_external_fence_capabilities";

const KHR_EXTERNAL_FENCE = 1;

const KHR_EXTERNAL_FENCE_SPEC_VERSION = 1;

const KHR_EXTERNAL_FENCE_EXTENSION_NAME = "VK_KHR_external_fence";

const KHR_EXTERNAL_FENCE_FD = 1;

const KHR_EXTERNAL_FENCE_FD_SPEC_VERSION = 1;

const KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME = "VK_KHR_external_fence_fd";

const KHR_PERFORMANCE_QUERY = 1;

const KHR_PERFORMANCE_QUERY_SPEC_VERSION = 1;

const KHR_PERFORMANCE_QUERY_EXTENSION_NAME = "VK_KHR_performance_query";

const KHR_MAINTENANCE2 = 1;

const KHR_MAINTENANCE_2_SPEC_VERSION = 1;

const KHR_MAINTENANCE_2_EXTENSION_NAME = "VK_KHR_maintenance2";

const KHR_MAINTENANCE2_SPEC_VERSION = KHR_MAINTENANCE_2_SPEC_VERSION;

const KHR_MAINTENANCE2_EXTENSION_NAME = KHR_MAINTENANCE_2_EXTENSION_NAME;

const KHR_GET_SURFACE_CAPABILITIES2 = 1;

const KHR_GET_SURFACE_CAPABILITIES_2_SPEC_VERSION = 1;

const KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME = "VK_KHR_get_surface_capabilities2";

const KHR_VARIABLE_POINTERS = 1;

const KHR_VARIABLE_POINTERS_SPEC_VERSION = 1;

const KHR_VARIABLE_POINTERS_EXTENSION_NAME = "VK_KHR_variable_pointers";

const KHR_GET_DISPLAY_PROPERTIES2 = 1;

const KHR_GET_DISPLAY_PROPERTIES_2_SPEC_VERSION = 1;

const KHR_GET_DISPLAY_PROPERTIES_2_EXTENSION_NAME = "VK_KHR_get_display_properties2";

const KHR_DEDICATED_ALLOCATION = 1;

const KHR_DEDICATED_ALLOCATION_SPEC_VERSION = 3;

const KHR_DEDICATED_ALLOCATION_EXTENSION_NAME = "VK_KHR_dedicated_allocation";

const KHR_STORAGE_BUFFER_STORAGE_CLASS = 1;

const KHR_STORAGE_BUFFER_STORAGE_CLASS_SPEC_VERSION = 1;

const KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME = "VK_KHR_storage_buffer_storage_class";

const KHR_RELAXED_BLOCK_LAYOUT = 1;

const KHR_RELAXED_BLOCK_LAYOUT_SPEC_VERSION = 1;

const KHR_RELAXED_BLOCK_LAYOUT_EXTENSION_NAME = "VK_KHR_relaxed_block_layout";

const KHR_GET_MEMORY_REQUIREMENTS2 = 1;

const KHR_GET_MEMORY_REQUIREMENTS_2_SPEC_VERSION = 1;

const KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME = "VK_KHR_get_memory_requirements2";

const KHR_IMAGE_FORMAT_LIST = 1;

const KHR_IMAGE_FORMAT_LIST_SPEC_VERSION = 1;

const KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME = "VK_KHR_image_format_list";

const KHR_SAMPLER_YCBCR_CONVERSION = 1;

const KHR_SAMPLER_YCBCR_CONVERSION_SPEC_VERSION = 14;

const KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME = "VK_KHR_sampler_ycbcr_conversion";

const KHR_BIND_MEMORY2 = 1;

const KHR_BIND_MEMORY_2_SPEC_VERSION = 1;

const KHR_BIND_MEMORY_2_EXTENSION_NAME = "VK_KHR_bind_memory2";

const KHR_MAINTENANCE3 = 1;

const KHR_MAINTENANCE_3_SPEC_VERSION = 1;

const KHR_MAINTENANCE_3_EXTENSION_NAME = "VK_KHR_maintenance3";

const KHR_MAINTENANCE3_SPEC_VERSION = KHR_MAINTENANCE_3_SPEC_VERSION;

const KHR_MAINTENANCE3_EXTENSION_NAME = KHR_MAINTENANCE_3_EXTENSION_NAME;

const KHR_DRAW_INDIRECT_COUNT = 1;

const KHR_DRAW_INDIRECT_COUNT_SPEC_VERSION = 1;

const KHR_DRAW_INDIRECT_COUNT_EXTENSION_NAME = "VK_KHR_draw_indirect_count";

const KHR_SHADER_SUBGROUP_EXTENDED_TYPES = 1;

const KHR_SHADER_SUBGROUP_EXTENDED_TYPES_SPEC_VERSION = 1;

const KHR_SHADER_SUBGROUP_EXTENDED_TYPES_EXTENSION_NAME = "VK_KHR_shader_subgroup_extended_types";

const KHR_8BIT_STORAGE = 1;

const KHR_8BIT_STORAGE_SPEC_VERSION = 1;

const KHR_8BIT_STORAGE_EXTENSION_NAME = "VK_KHR_8bit_storage";

const KHR_SHADER_ATOMIC_INT64 = 1;

const KHR_SHADER_ATOMIC_INT64_SPEC_VERSION = 1;

const KHR_SHADER_ATOMIC_INT64_EXTENSION_NAME = "VK_KHR_shader_atomic_int64";

const KHR_SHADER_CLOCK = 1;

const KHR_SHADER_CLOCK_SPEC_VERSION = 1;

const KHR_SHADER_CLOCK_EXTENSION_NAME = "VK_KHR_shader_clock";

const KHR_DRIVER_PROPERTIES = 1;

const KHR_DRIVER_PROPERTIES_SPEC_VERSION = 1;

const KHR_DRIVER_PROPERTIES_EXTENSION_NAME = "VK_KHR_driver_properties";

const MAX_DRIVER_NAME_SIZE_KHR = MAX_DRIVER_NAME_SIZE;

const MAX_DRIVER_INFO_SIZE_KHR = MAX_DRIVER_INFO_SIZE;

const KHR_SHADER_FLOAT_CONTROLS = 1;

const KHR_SHADER_FLOAT_CONTROLS_SPEC_VERSION = 4;

const KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME = "VK_KHR_shader_float_controls";

const KHR_DEPTH_STENCIL_RESOLVE = 1;

const KHR_DEPTH_STENCIL_RESOLVE_SPEC_VERSION = 1;

const KHR_DEPTH_STENCIL_RESOLVE_EXTENSION_NAME = "VK_KHR_depth_stencil_resolve";

const KHR_SWAPCHAIN_MUTABLE_FORMAT = 1;

const KHR_SWAPCHAIN_MUTABLE_FORMAT_SPEC_VERSION = 1;

const KHR_SWAPCHAIN_MUTABLE_FORMAT_EXTENSION_NAME = "VK_KHR_swapchain_mutable_format";

const KHR_TIMELINE_SEMAPHORE = 1;

const KHR_TIMELINE_SEMAPHORE_SPEC_VERSION = 2;

const KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME = "VK_KHR_timeline_semaphore";

const KHR_VULKAN_MEMORY_MODEL = 1;

const KHR_VULKAN_MEMORY_MODEL_SPEC_VERSION = 3;

const KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME = "VK_KHR_vulkan_memory_model";

const KHR_SHADER_TERMINATE_INVOCATION = 1;

const KHR_SHADER_TERMINATE_INVOCATION_SPEC_VERSION = 1;

const KHR_SHADER_TERMINATE_INVOCATION_EXTENSION_NAME = "VK_KHR_shader_terminate_invocation";

const KHR_FRAGMENT_SHADING_RATE = 1;

const KHR_FRAGMENT_SHADING_RATE_SPEC_VERSION = 2;

const KHR_FRAGMENT_SHADING_RATE_EXTENSION_NAME = "VK_KHR_fragment_shading_rate";

const KHR_SPIRV_1_4 = 1;

const KHR_SPIRV_1_4_SPEC_VERSION = 1;

const KHR_SPIRV_1_4_EXTENSION_NAME = "VK_KHR_spirv_1_4";

const KHR_SURFACE_PROTECTED_CAPABILITIES = 1;

const KHR_SURFACE_PROTECTED_CAPABILITIES_SPEC_VERSION = 1;

const KHR_SURFACE_PROTECTED_CAPABILITIES_EXTENSION_NAME = "VK_KHR_surface_protected_capabilities";

const KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS = 1;

const KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_SPEC_VERSION = 1;

const KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_EXTENSION_NAME = "VK_KHR_separate_depth_stencil_layouts";

const KHR_PRESENT_WAIT = 1;

const KHR_PRESENT_WAIT_SPEC_VERSION = 1;

const KHR_PRESENT_WAIT_EXTENSION_NAME = "VK_KHR_present_wait";

const KHR_UNIFORM_BUFFER_STANDARD_LAYOUT = 1;

const KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_SPEC_VERSION = 1;

const KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_EXTENSION_NAME = "VK_KHR_uniform_buffer_standard_layout";

const KHR_BUFFER_DEVICE_ADDRESS = 1;

const KHR_BUFFER_DEVICE_ADDRESS_SPEC_VERSION = 1;

const KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME = "VK_KHR_buffer_device_address";

const KHR_DEFERRED_HOST_OPERATIONS = 1;

const KHR_DEFERRED_HOST_OPERATIONS_SPEC_VERSION = 4;

const KHR_DEFERRED_HOST_OPERATIONS_EXTENSION_NAME = "VK_KHR_deferred_host_operations";

const KHR_PIPELINE_EXECUTABLE_PROPERTIES = 1;

const KHR_PIPELINE_EXECUTABLE_PROPERTIES_SPEC_VERSION = 1;

const KHR_PIPELINE_EXECUTABLE_PROPERTIES_EXTENSION_NAME = "VK_KHR_pipeline_executable_properties";

const KHR_SHADER_INTEGER_DOT_PRODUCT = 1;

const KHR_SHADER_INTEGER_DOT_PRODUCT_SPEC_VERSION = 1;

const KHR_SHADER_INTEGER_DOT_PRODUCT_EXTENSION_NAME = "VK_KHR_shader_integer_dot_product";

const KHR_PIPELINE_LIBRARY = 1;

const KHR_PIPELINE_LIBRARY_SPEC_VERSION = 1;

const KHR_PIPELINE_LIBRARY_EXTENSION_NAME = "VK_KHR_pipeline_library";

const KHR_SHADER_NON_SEMANTIC_INFO = 1;

const KHR_SHADER_NON_SEMANTIC_INFO_SPEC_VERSION = 1;

const KHR_SHADER_NON_SEMANTIC_INFO_EXTENSION_NAME = "VK_KHR_shader_non_semantic_info";

const KHR_PRESENT_ID = 1;

const KHR_PRESENT_ID_SPEC_VERSION = 1;

const KHR_PRESENT_ID_EXTENSION_NAME = "VK_KHR_present_id";

const KHR_SYNCHRONIZATION2 = 1;

const KHR_SYNCHRONIZATION_2_SPEC_VERSION = 1;

const KHR_SYNCHRONIZATION_2_EXTENSION_NAME = "VK_KHR_synchronization2";

const KHR_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW = 1;

const KHR_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_SPEC_VERSION = 1;

const KHR_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_EXTENSION_NAME = "VK_KHR_shader_subgroup_uniform_control_flow";

const KHR_ZERO_INITIALIZE_WORKGROUP_MEMORY = 1;

const KHR_ZERO_INITIALIZE_WORKGROUP_MEMORY_SPEC_VERSION = 1;

const KHR_ZERO_INITIALIZE_WORKGROUP_MEMORY_EXTENSION_NAME = "VK_KHR_zero_initialize_workgroup_memory";

const KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT = 1;

const KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_SPEC_VERSION = 1;

const KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_EXTENSION_NAME = "VK_KHR_workgroup_memory_explicit_layout";

const KHR_COPY_COMMANDS2 = 1;

const KHR_COPY_COMMANDS_2_SPEC_VERSION = 1;

const KHR_COPY_COMMANDS_2_EXTENSION_NAME = "VK_KHR_copy_commands2";

const KHR_FORMAT_FEATURE_FLAGS2 = 1;

const KHR_FORMAT_FEATURE_FLAGS_2_SPEC_VERSION = 1;

const KHR_FORMAT_FEATURE_FLAGS_2_EXTENSION_NAME = "VK_KHR_format_feature_flags2";

const KHR_MAINTENANCE4 = 1;

const KHR_MAINTENANCE_4_SPEC_VERSION = 2;

const KHR_MAINTENANCE_4_EXTENSION_NAME = "VK_KHR_maintenance4";

const EXT_DEBUG_REPORT = 1;

const EXT_DEBUG_REPORT_SPEC_VERSION = 10;

const EXT_DEBUG_REPORT_EXTENSION_NAME = "VK_EXT_debug_report";

const NV_GLSL_SHADER = 1;

const NV_GLSL_SHADER_SPEC_VERSION = 1;

const NV_GLSL_SHADER_EXTENSION_NAME = "VK_NV_glsl_shader";

const EXT_DEPTH_RANGE_UNRESTRICTED = 1;

const EXT_DEPTH_RANGE_UNRESTRICTED_SPEC_VERSION = 1;

const EXT_DEPTH_RANGE_UNRESTRICTED_EXTENSION_NAME = "VK_EXT_depth_range_unrestricted";

const IMG_FILTER_CUBIC = 1;

const IMG_FILTER_CUBIC_SPEC_VERSION = 1;

const IMG_FILTER_CUBIC_EXTENSION_NAME = "VK_IMG_filter_cubic";

const AMD_RASTERIZATION_ORDER = 1;

const AMD_RASTERIZATION_ORDER_SPEC_VERSION = 1;

const AMD_RASTERIZATION_ORDER_EXTENSION_NAME = "VK_AMD_rasterization_order";

const AMD_SHADER_TRINARY_MINMAX = 1;

const AMD_SHADER_TRINARY_MINMAX_SPEC_VERSION = 1;

const AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME = "VK_AMD_shader_trinary_minmax";

const AMD_SHADER_EXPLICIT_VERTEX_PARAMETER = 1;

const AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_SPEC_VERSION = 1;

const AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME = "VK_AMD_shader_explicit_vertex_parameter";

const EXT_DEBUG_MARKER = 1;

const EXT_DEBUG_MARKER_SPEC_VERSION = 4;

const EXT_DEBUG_MARKER_EXTENSION_NAME = "VK_EXT_debug_marker";

const AMD_GCN_SHADER = 1;

const AMD_GCN_SHADER_SPEC_VERSION = 1;

const AMD_GCN_SHADER_EXTENSION_NAME = "VK_AMD_gcn_shader";

const NV_DEDICATED_ALLOCATION = 1;

const NV_DEDICATED_ALLOCATION_SPEC_VERSION = 1;

const NV_DEDICATED_ALLOCATION_EXTENSION_NAME = "VK_NV_dedicated_allocation";

const EXT_TRANSFORM_FEEDBACK = 1;

const EXT_TRANSFORM_FEEDBACK_SPEC_VERSION = 1;

const EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME = "VK_EXT_transform_feedback";

const NVX_BINARY_IMPORT = 1;

const NVX_BINARY_IMPORT_SPEC_VERSION = 1;

const NVX_BINARY_IMPORT_EXTENSION_NAME = "VK_NVX_binary_import";

const NVX_IMAGE_VIEW_HANDLE = 1;

const NVX_IMAGE_VIEW_HANDLE_SPEC_VERSION = 2;

const NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME = "VK_NVX_image_view_handle";

const AMD_DRAW_INDIRECT_COUNT = 1;

const AMD_DRAW_INDIRECT_COUNT_SPEC_VERSION = 2;

const AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME = "VK_AMD_draw_indirect_count";

const AMD_NEGATIVE_VIEWPORT_HEIGHT = 1;

const AMD_NEGATIVE_VIEWPORT_HEIGHT_SPEC_VERSION = 1;

const AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME = "VK_AMD_negative_viewport_height";

const AMD_GPU_SHADER_HALF_FLOAT = 1;

const AMD_GPU_SHADER_HALF_FLOAT_SPEC_VERSION = 2;

const AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME = "VK_AMD_gpu_shader_half_float";

const AMD_SHADER_BALLOT = 1;

const AMD_SHADER_BALLOT_SPEC_VERSION = 1;

const AMD_SHADER_BALLOT_EXTENSION_NAME = "VK_AMD_shader_ballot";

const AMD_TEXTURE_GATHER_BIAS_LOD = 1;

const AMD_TEXTURE_GATHER_BIAS_LOD_SPEC_VERSION = 1;

const AMD_TEXTURE_GATHER_BIAS_LOD_EXTENSION_NAME = "VK_AMD_texture_gather_bias_lod";

const AMD_SHADER_INFO = 1;

const AMD_SHADER_INFO_SPEC_VERSION = 1;

const AMD_SHADER_INFO_EXTENSION_NAME = "VK_AMD_shader_info";

const AMD_SHADER_IMAGE_LOAD_STORE_LOD = 1;

const AMD_SHADER_IMAGE_LOAD_STORE_LOD_SPEC_VERSION = 1;

const AMD_SHADER_IMAGE_LOAD_STORE_LOD_EXTENSION_NAME = "VK_AMD_shader_image_load_store_lod";

const NV_CORNER_SAMPLED_IMAGE = 1;

const NV_CORNER_SAMPLED_IMAGE_SPEC_VERSION = 2;

const NV_CORNER_SAMPLED_IMAGE_EXTENSION_NAME = "VK_NV_corner_sampled_image";

const IMG_FORMAT_PVRTC = 1;

const IMG_FORMAT_PVRTC_SPEC_VERSION = 1;

const IMG_FORMAT_PVRTC_EXTENSION_NAME = "VK_IMG_format_pvrtc";

const NV_EXTERNAL_MEMORY_CAPABILITIES = 1;

const NV_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION = 1;

const NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME = "VK_NV_external_memory_capabilities";

const NV_EXTERNAL_MEMORY = 1;

const NV_EXTERNAL_MEMORY_SPEC_VERSION = 1;

const NV_EXTERNAL_MEMORY_EXTENSION_NAME = "VK_NV_external_memory";

const EXT_VALIDATION_FLAGS = 1;

const EXT_VALIDATION_FLAGS_SPEC_VERSION = 2;

const EXT_VALIDATION_FLAGS_EXTENSION_NAME = "VK_EXT_validation_flags";

const EXT_SHADER_SUBGROUP_BALLOT = 1;

const EXT_SHADER_SUBGROUP_BALLOT_SPEC_VERSION = 1;

const EXT_SHADER_SUBGROUP_BALLOT_EXTENSION_NAME = "VK_EXT_shader_subgroup_ballot";

const EXT_SHADER_SUBGROUP_VOTE = 1;

const EXT_SHADER_SUBGROUP_VOTE_SPEC_VERSION = 1;

const EXT_SHADER_SUBGROUP_VOTE_EXTENSION_NAME = "VK_EXT_shader_subgroup_vote";

const EXT_TEXTURE_COMPRESSION_ASTC_HDR = 1;

const EXT_TEXTURE_COMPRESSION_ASTC_HDR_SPEC_VERSION = 1;

const EXT_TEXTURE_COMPRESSION_ASTC_HDR_EXTENSION_NAME = "VK_EXT_texture_compression_astc_hdr";

const EXT_ASTC_DECODE_MODE = 1;

const EXT_ASTC_DECODE_MODE_SPEC_VERSION = 1;

const EXT_ASTC_DECODE_MODE_EXTENSION_NAME = "VK_EXT_astc_decode_mode";

const EXT_CONDITIONAL_RENDERING = 1;

const EXT_CONDITIONAL_RENDERING_SPEC_VERSION = 2;

const EXT_CONDITIONAL_RENDERING_EXTENSION_NAME = "VK_EXT_conditional_rendering";

const NV_CLIP_SPACE_W_SCALING = 1;

const NV_CLIP_SPACE_W_SCALING_SPEC_VERSION = 1;

const NV_CLIP_SPACE_W_SCALING_EXTENSION_NAME = "VK_NV_clip_space_w_scaling";

const EXT_DIRECT_MODE_DISPLAY = 1;

const EXT_DIRECT_MODE_DISPLAY_SPEC_VERSION = 1;

const EXT_DIRECT_MODE_DISPLAY_EXTENSION_NAME = "VK_EXT_direct_mode_display";

const EXT_DISPLAY_SURFACE_COUNTER = 1;

const EXT_DISPLAY_SURFACE_COUNTER_SPEC_VERSION = 1;

const EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME = "VK_EXT_display_surface_counter";

const EXT_DISPLAY_CONTROL = 1;

const EXT_DISPLAY_CONTROL_SPEC_VERSION = 1;

const EXT_DISPLAY_CONTROL_EXTENSION_NAME = "VK_EXT_display_control";

const GOOGLE_DISPLAY_TIMING = 1;

const GOOGLE_DISPLAY_TIMING_SPEC_VERSION = 1;

const GOOGLE_DISPLAY_TIMING_EXTENSION_NAME = "VK_GOOGLE_display_timing";

const NV_SAMPLE_MASK_OVERRIDE_COVERAGE = 1;

const NV_SAMPLE_MASK_OVERRIDE_COVERAGE_SPEC_VERSION = 1;

const NV_SAMPLE_MASK_OVERRIDE_COVERAGE_EXTENSION_NAME = "VK_NV_sample_mask_override_coverage";

const NV_GEOMETRY_SHADER_PASSTHROUGH = 1;

const NV_GEOMETRY_SHADER_PASSTHROUGH_SPEC_VERSION = 1;

const NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME = "VK_NV_geometry_shader_passthrough";

const NV_VIEWPORT_ARRAY2 = 1;

const NV_VIEWPORT_ARRAY_2_SPEC_VERSION = 1;

const NV_VIEWPORT_ARRAY_2_EXTENSION_NAME = "VK_NV_viewport_array2";

const NV_VIEWPORT_ARRAY2_SPEC_VERSION = NV_VIEWPORT_ARRAY_2_SPEC_VERSION;

const NV_VIEWPORT_ARRAY2_EXTENSION_NAME = NV_VIEWPORT_ARRAY_2_EXTENSION_NAME;

const NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES = 1;

const NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_SPEC_VERSION = 1;

const NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_EXTENSION_NAME = "VK_NVX_multiview_per_view_attributes";

const NV_VIEWPORT_SWIZZLE = 1;

const NV_VIEWPORT_SWIZZLE_SPEC_VERSION = 1;

const NV_VIEWPORT_SWIZZLE_EXTENSION_NAME = "VK_NV_viewport_swizzle";

const EXT_DISCARD_RECTANGLES = 1;

const EXT_DISCARD_RECTANGLES_SPEC_VERSION = 1;

const EXT_DISCARD_RECTANGLES_EXTENSION_NAME = "VK_EXT_discard_rectangles";

const EXT_CONSERVATIVE_RASTERIZATION = 1;

const EXT_CONSERVATIVE_RASTERIZATION_SPEC_VERSION = 1;

const EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME = "VK_EXT_conservative_rasterization";

const EXT_DEPTH_CLIP_ENABLE = 1;

const EXT_DEPTH_CLIP_ENABLE_SPEC_VERSION = 1;

const EXT_DEPTH_CLIP_ENABLE_EXTENSION_NAME = "VK_EXT_depth_clip_enable";

const EXT_SWAPCHAIN_COLORSPACE = 1;

const EXT_SWAPCHAIN_COLOR_SPACE_SPEC_VERSION = 4;

const EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME = "VK_EXT_swapchain_colorspace";

const EXT_HDR_METADATA = 1;

const EXT_HDR_METADATA_SPEC_VERSION = 2;

const EXT_HDR_METADATA_EXTENSION_NAME = "VK_EXT_hdr_metadata";

const EXT_EXTERNAL_MEMORY_DMA_BUF = 1;

const EXT_EXTERNAL_MEMORY_DMA_BUF_SPEC_VERSION = 1;

const EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME = "VK_EXT_external_memory_dma_buf";

const EXT_QUEUE_FAMILY_FOREIGN = 1;

const EXT_QUEUE_FAMILY_FOREIGN_SPEC_VERSION = 1;

const EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME = "VK_EXT_queue_family_foreign";

const QUEUE_FAMILY_FOREIGN_EXT = ~0U-2U;

const EXT_DEBUG_UTILS = 1;

const EXT_DEBUG_UTILS_SPEC_VERSION = 2;

const EXT_DEBUG_UTILS_EXTENSION_NAME = "VK_EXT_debug_utils";

const EXT_SAMPLER_FILTER_MINMAX = 1;

const EXT_SAMPLER_FILTER_MINMAX_SPEC_VERSION = 2;

const EXT_SAMPLER_FILTER_MINMAX_EXTENSION_NAME = "VK_EXT_sampler_filter_minmax";

const AMD_GPU_SHADER_INT16 = 1;

const AMD_GPU_SHADER_INT16_SPEC_VERSION = 2;

const AMD_GPU_SHADER_INT16_EXTENSION_NAME = "VK_AMD_gpu_shader_int16";

const AMD_MIXED_ATTACHMENT_SAMPLES = 1;

const AMD_MIXED_ATTACHMENT_SAMPLES_SPEC_VERSION = 1;

const AMD_MIXED_ATTACHMENT_SAMPLES_EXTENSION_NAME = "VK_AMD_mixed_attachment_samples";

const AMD_SHADER_FRAGMENT_MASK = 1;

const AMD_SHADER_FRAGMENT_MASK_SPEC_VERSION = 1;

const AMD_SHADER_FRAGMENT_MASK_EXTENSION_NAME = "VK_AMD_shader_fragment_mask";

const EXT_INLINE_UNIFORM_BLOCK = 1;

const EXT_INLINE_UNIFORM_BLOCK_SPEC_VERSION = 1;

const EXT_INLINE_UNIFORM_BLOCK_EXTENSION_NAME = "VK_EXT_inline_uniform_block";

const EXT_SHADER_STENCIL_EXPORT = 1;

const EXT_SHADER_STENCIL_EXPORT_SPEC_VERSION = 1;

const EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME = "VK_EXT_shader_stencil_export";

const EXT_SAMPLE_LOCATIONS = 1;

const EXT_SAMPLE_LOCATIONS_SPEC_VERSION = 1;

const EXT_SAMPLE_LOCATIONS_EXTENSION_NAME = "VK_EXT_sample_locations";

const EXT_BLEND_OPERATION_ADVANCED = 1;

const EXT_BLEND_OPERATION_ADVANCED_SPEC_VERSION = 2;

const EXT_BLEND_OPERATION_ADVANCED_EXTENSION_NAME = "VK_EXT_blend_operation_advanced";

const NV_FRAGMENT_COVERAGE_TO_COLOR = 1;

const NV_FRAGMENT_COVERAGE_TO_COLOR_SPEC_VERSION = 1;

const NV_FRAGMENT_COVERAGE_TO_COLOR_EXTENSION_NAME = "VK_NV_fragment_coverage_to_color";

const NV_FRAMEBUFFER_MIXED_SAMPLES = 1;

const NV_FRAMEBUFFER_MIXED_SAMPLES_SPEC_VERSION = 1;

const NV_FRAMEBUFFER_MIXED_SAMPLES_EXTENSION_NAME = "VK_NV_framebuffer_mixed_samples";

const NV_FILL_RECTANGLE = 1;

const NV_FILL_RECTANGLE_SPEC_VERSION = 1;

const NV_FILL_RECTANGLE_EXTENSION_NAME = "VK_NV_fill_rectangle";

const NV_SHADER_SM_BUILTINS = 1;

const NV_SHADER_SM_BUILTINS_SPEC_VERSION = 1;

const NV_SHADER_SM_BUILTINS_EXTENSION_NAME = "VK_NV_shader_sm_builtins";

const EXT_POST_DEPTH_COVERAGE = 1;

const EXT_POST_DEPTH_COVERAGE_SPEC_VERSION = 1;

const EXT_POST_DEPTH_COVERAGE_EXTENSION_NAME = "VK_EXT_post_depth_coverage";

const EXT_IMAGE_DRM_FORMAT_MODIFIER = 1;

const EXT_IMAGE_DRM_FORMAT_MODIFIER_SPEC_VERSION = 2;

const EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION_NAME = "VK_EXT_image_drm_format_modifier";

const EXT_VALIDATION_CACHE = 1;

const EXT_VALIDATION_CACHE_SPEC_VERSION = 1;

const EXT_VALIDATION_CACHE_EXTENSION_NAME = "VK_EXT_validation_cache";

const EXT_DESCRIPTOR_INDEXING = 1;

const EXT_DESCRIPTOR_INDEXING_SPEC_VERSION = 2;

const EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME = "VK_EXT_descriptor_indexing";

const EXT_SHADER_VIEWPORT_INDEX_LAYER = 1;

const EXT_SHADER_VIEWPORT_INDEX_LAYER_SPEC_VERSION = 1;

const EXT_SHADER_VIEWPORT_INDEX_LAYER_EXTENSION_NAME = "VK_EXT_shader_viewport_index_layer";

const NV_SHADING_RATE_IMAGE = 1;

const NV_SHADING_RATE_IMAGE_SPEC_VERSION = 3;

const NV_SHADING_RATE_IMAGE_EXTENSION_NAME = "VK_NV_shading_rate_image";

const NV_RAY_TRACING = 1;

const NV_RAY_TRACING_SPEC_VERSION = 3;

const NV_RAY_TRACING_EXTENSION_NAME = "VK_NV_ray_tracing";

const SHADER_UNUSED_KHR = (~0U);

const SHADER_UNUSED_NV = SHADER_UNUSED_KHR;

const NV_REPRESENTATIVE_FRAGMENT_TEST = 1;

const NV_REPRESENTATIVE_FRAGMENT_TEST_SPEC_VERSION = 2;

const NV_REPRESENTATIVE_FRAGMENT_TEST_EXTENSION_NAME = "VK_NV_representative_fragment_test";

const EXT_FILTER_CUBIC = 1;

const EXT_FILTER_CUBIC_SPEC_VERSION = 3;

const EXT_FILTER_CUBIC_EXTENSION_NAME = "VK_EXT_filter_cubic";

const QCOM_RENDER_PASS_SHADER_RESOLVE = 1;

const QCOM_RENDER_PASS_SHADER_RESOLVE_SPEC_VERSION = 4;

const QCOM_RENDER_PASS_SHADER_RESOLVE_EXTENSION_NAME = "VK_QCOM_render_pass_shader_resolve";

const EXT_GLOBAL_PRIORITY = 1;

const EXT_GLOBAL_PRIORITY_SPEC_VERSION = 2;

const EXT_GLOBAL_PRIORITY_EXTENSION_NAME = "VK_EXT_global_priority";

const EXT_EXTERNAL_MEMORY_HOST = 1;

const EXT_EXTERNAL_MEMORY_HOST_SPEC_VERSION = 1;

const EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME = "VK_EXT_external_memory_host";

const AMD_BUFFER_MARKER = 1;

const AMD_BUFFER_MARKER_SPEC_VERSION = 1;

const AMD_BUFFER_MARKER_EXTENSION_NAME = "VK_AMD_buffer_marker";

const AMD_PIPELINE_COMPILER_CONTROL = 1;

const AMD_PIPELINE_COMPILER_CONTROL_SPEC_VERSION = 1;

const AMD_PIPELINE_COMPILER_CONTROL_EXTENSION_NAME = "VK_AMD_pipeline_compiler_control";

const EXT_CALIBRATED_TIMESTAMPS = 1;

const EXT_CALIBRATED_TIMESTAMPS_SPEC_VERSION = 2;

const EXT_CALIBRATED_TIMESTAMPS_EXTENSION_NAME = "VK_EXT_calibrated_timestamps";

const AMD_SHADER_CORE_PROPERTIES = 1;

const AMD_SHADER_CORE_PROPERTIES_SPEC_VERSION = 2;

const AMD_SHADER_CORE_PROPERTIES_EXTENSION_NAME = "VK_AMD_shader_core_properties";

const AMD_MEMORY_OVERALLOCATION_BEHAVIOR = 1;

const AMD_MEMORY_OVERALLOCATION_BEHAVIOR_SPEC_VERSION = 1;

const AMD_MEMORY_OVERALLOCATION_BEHAVIOR_EXTENSION_NAME = "VK_AMD_memory_overallocation_behavior";

const EXT_VERTEX_ATTRIBUTE_DIVISOR = 1;

const EXT_VERTEX_ATTRIBUTE_DIVISOR_SPEC_VERSION = 3;

const EXT_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME = "VK_EXT_vertex_attribute_divisor";

const EXT_PIPELINE_CREATION_FEEDBACK = 1;

const EXT_PIPELINE_CREATION_FEEDBACK_SPEC_VERSION = 1;

const EXT_PIPELINE_CREATION_FEEDBACK_EXTENSION_NAME = "VK_EXT_pipeline_creation_feedback";

const NV_SHADER_SUBGROUP_PARTITIONED = 1;

const NV_SHADER_SUBGROUP_PARTITIONED_SPEC_VERSION = 1;

const NV_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME = "VK_NV_shader_subgroup_partitioned";

const NV_COMPUTE_SHADER_DERIVATIVES = 1;

const NV_COMPUTE_SHADER_DERIVATIVES_SPEC_VERSION = 1;

const NV_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME = "VK_NV_compute_shader_derivatives";

const NV_MESH_SHADER = 1;

const NV_MESH_SHADER_SPEC_VERSION = 1;

const NV_MESH_SHADER_EXTENSION_NAME = "VK_NV_mesh_shader";

const NV_FRAGMENT_SHADER_BARYCENTRIC = 1;

const NV_FRAGMENT_SHADER_BARYCENTRIC_SPEC_VERSION = 1;

const NV_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME = "VK_NV_fragment_shader_barycentric";

const NV_SHADER_IMAGE_FOOTPRINT = 1;

const NV_SHADER_IMAGE_FOOTPRINT_SPEC_VERSION = 2;

const NV_SHADER_IMAGE_FOOTPRINT_EXTENSION_NAME = "VK_NV_shader_image_footprint";

const NV_SCISSOR_EXCLUSIVE = 1;

const NV_SCISSOR_EXCLUSIVE_SPEC_VERSION = 1;

const NV_SCISSOR_EXCLUSIVE_EXTENSION_NAME = "VK_NV_scissor_exclusive";

const NV_DEVICE_DIAGNOSTIC_CHECKPOINTS = 1;

const NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_SPEC_VERSION = 2;

const NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_EXTENSION_NAME = "VK_NV_device_diagnostic_checkpoints";

const INTEL_SHADER_INTEGER_FUNCTIONS2 = 1;

const INTEL_SHADER_INTEGER_FUNCTIONS_2_SPEC_VERSION = 1;

const INTEL_SHADER_INTEGER_FUNCTIONS_2_EXTENSION_NAME = "VK_INTEL_shader_integer_functions2";

const INTEL_PERFORMANCE_QUERY = 1;

const INTEL_PERFORMANCE_QUERY_SPEC_VERSION = 2;

const INTEL_PERFORMANCE_QUERY_EXTENSION_NAME = "VK_INTEL_performance_query";

const EXT_PCI_BUS_INFO = 1;

const EXT_PCI_BUS_INFO_SPEC_VERSION = 2;

const EXT_PCI_BUS_INFO_EXTENSION_NAME = "VK_EXT_pci_bus_info";

const AMD_DISPLAY_NATIVE_HDR = 1;

const AMD_DISPLAY_NATIVE_HDR_SPEC_VERSION = 1;

const AMD_DISPLAY_NATIVE_HDR_EXTENSION_NAME = "VK_AMD_display_native_hdr";

const EXT_FRAGMENT_DENSITY_MAP = 1;

const EXT_FRAGMENT_DENSITY_MAP_SPEC_VERSION = 2;

const EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME = "VK_EXT_fragment_density_map";

const EXT_SCALAR_BLOCK_LAYOUT = 1;

const EXT_SCALAR_BLOCK_LAYOUT_SPEC_VERSION = 1;

const EXT_SCALAR_BLOCK_LAYOUT_EXTENSION_NAME = "VK_EXT_scalar_block_layout";

const GOOGLE_HLSL_FUNCTIONALITY1 = 1;

const GOOGLE_HLSL_FUNCTIONALITY_1_SPEC_VERSION = 1;

const GOOGLE_HLSL_FUNCTIONALITY_1_EXTENSION_NAME = "VK_GOOGLE_hlsl_functionality1";

const GOOGLE_HLSL_FUNCTIONALITY1_SPEC_VERSION = GOOGLE_HLSL_FUNCTIONALITY_1_SPEC_VERSION;

const GOOGLE_HLSL_FUNCTIONALITY1_EXTENSION_NAME = GOOGLE_HLSL_FUNCTIONALITY_1_EXTENSION_NAME;

const GOOGLE_DECORATE_STRING = 1;

const GOOGLE_DECORATE_STRING_SPEC_VERSION = 1;

const GOOGLE_DECORATE_STRING_EXTENSION_NAME = "VK_GOOGLE_decorate_string";

const EXT_SUBGROUP_SIZE_CONTROL = 1;

const EXT_SUBGROUP_SIZE_CONTROL_SPEC_VERSION = 2;

const EXT_SUBGROUP_SIZE_CONTROL_EXTENSION_NAME = "VK_EXT_subgroup_size_control";

const AMD_SHADER_CORE_PROPERTIES2 = 1;

const AMD_SHADER_CORE_PROPERTIES_2_SPEC_VERSION = 1;

const AMD_SHADER_CORE_PROPERTIES_2_EXTENSION_NAME = "VK_AMD_shader_core_properties2";

const AMD_DEVICE_COHERENT_MEMORY = 1;

const AMD_DEVICE_COHERENT_MEMORY_SPEC_VERSION = 1;

const AMD_DEVICE_COHERENT_MEMORY_EXTENSION_NAME = "VK_AMD_device_coherent_memory";

const EXT_SHADER_IMAGE_ATOMIC_INT64 = 1;

const EXT_SHADER_IMAGE_ATOMIC_INT64_SPEC_VERSION = 1;

const EXT_SHADER_IMAGE_ATOMIC_INT64_EXTENSION_NAME = "VK_EXT_shader_image_atomic_int64";

const EXT_MEMORY_BUDGET = 1;

const EXT_MEMORY_BUDGET_SPEC_VERSION = 1;

const EXT_MEMORY_BUDGET_EXTENSION_NAME = "VK_EXT_memory_budget";

const EXT_MEMORY_PRIORITY = 1;

const EXT_MEMORY_PRIORITY_SPEC_VERSION = 1;

const EXT_MEMORY_PRIORITY_EXTENSION_NAME = "VK_EXT_memory_priority";

const NV_DEDICATED_ALLOCATION_IMAGE_ALIASING = 1;

const NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_SPEC_VERSION = 1;

const NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_EXTENSION_NAME = "VK_NV_dedicated_allocation_image_aliasing";

const EXT_BUFFER_DEVICE_ADDRESS = 1;

const EXT_BUFFER_DEVICE_ADDRESS_SPEC_VERSION = 2;

const EXT_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME = "VK_EXT_buffer_device_address";

const EXT_TOOLING_INFO = 1;

const EXT_TOOLING_INFO_SPEC_VERSION = 1;

const EXT_TOOLING_INFO_EXTENSION_NAME = "VK_EXT_tooling_info";

const EXT_SEPARATE_STENCIL_USAGE = 1;

const EXT_SEPARATE_STENCIL_USAGE_SPEC_VERSION = 1;

const EXT_SEPARATE_STENCIL_USAGE_EXTENSION_NAME = "VK_EXT_separate_stencil_usage";

const EXT_VALIDATION_FEATURES = 1;

const EXT_VALIDATION_FEATURES_SPEC_VERSION = 5;

const EXT_VALIDATION_FEATURES_EXTENSION_NAME = "VK_EXT_validation_features";

const NV_COOPERATIVE_MATRIX = 1;

const NV_COOPERATIVE_MATRIX_SPEC_VERSION = 1;

const NV_COOPERATIVE_MATRIX_EXTENSION_NAME = "VK_NV_cooperative_matrix";

const NV_COVERAGE_REDUCTION_MODE = 1;

const NV_COVERAGE_REDUCTION_MODE_SPEC_VERSION = 1;

const NV_COVERAGE_REDUCTION_MODE_EXTENSION_NAME = "VK_NV_coverage_reduction_mode";

const EXT_FRAGMENT_SHADER_INTERLOCK = 1;

const EXT_FRAGMENT_SHADER_INTERLOCK_SPEC_VERSION = 1;

const EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME = "VK_EXT_fragment_shader_interlock";

const EXT_YCBCR_IMAGE_ARRAYS = 1;

const EXT_YCBCR_IMAGE_ARRAYS_SPEC_VERSION = 1;

const EXT_YCBCR_IMAGE_ARRAYS_EXTENSION_NAME = "VK_EXT_ycbcr_image_arrays";

const EXT_PROVOKING_VERTEX = 1;

const EXT_PROVOKING_VERTEX_SPEC_VERSION = 1;

const EXT_PROVOKING_VERTEX_EXTENSION_NAME = "VK_EXT_provoking_vertex";

const EXT_HEADLESS_SURFACE = 1;

const EXT_HEADLESS_SURFACE_SPEC_VERSION = 1;

const EXT_HEADLESS_SURFACE_EXTENSION_NAME = "VK_EXT_headless_surface";

const EXT_LINE_RASTERIZATION = 1;

const EXT_LINE_RASTERIZATION_SPEC_VERSION = 1;

const EXT_LINE_RASTERIZATION_EXTENSION_NAME = "VK_EXT_line_rasterization";

const EXT_SHADER_ATOMIC_FLOAT = 1;

const EXT_SHADER_ATOMIC_FLOAT_SPEC_VERSION = 1;

const EXT_SHADER_ATOMIC_FLOAT_EXTENSION_NAME = "VK_EXT_shader_atomic_float";

const EXT_HOST_QUERY_RESET = 1;

const EXT_HOST_QUERY_RESET_SPEC_VERSION = 1;

const EXT_HOST_QUERY_RESET_EXTENSION_NAME = "VK_EXT_host_query_reset";

const EXT_INDEX_TYPE_UINT8 = 1;

const EXT_INDEX_TYPE_UINT8_SPEC_VERSION = 1;

const EXT_INDEX_TYPE_UINT8_EXTENSION_NAME = "VK_EXT_index_type_uint8";

const EXT_EXTENDED_DYNAMIC_STATE = 1;

const EXT_EXTENDED_DYNAMIC_STATE_SPEC_VERSION = 1;

const EXT_EXTENDED_DYNAMIC_STATE_EXTENSION_NAME = "VK_EXT_extended_dynamic_state";

const EXT_SHADER_ATOMIC_FLOAT2 = 1;

const EXT_SHADER_ATOMIC_FLOAT_2_SPEC_VERSION = 1;

const EXT_SHADER_ATOMIC_FLOAT_2_EXTENSION_NAME = "VK_EXT_shader_atomic_float2";

const EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION = 1;

const EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_SPEC_VERSION = 1;

const EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_EXTENSION_NAME = "VK_EXT_shader_demote_to_helper_invocation";

const NV_DEVICE_GENERATED_COMMANDS = 1;

const NV_DEVICE_GENERATED_COMMANDS_SPEC_VERSION = 3;

const NV_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME = "VK_NV_device_generated_commands";

const NV_INHERITED_VIEWPORT_SCISSOR = 1;

const NV_INHERITED_VIEWPORT_SCISSOR_SPEC_VERSION = 1;

const NV_INHERITED_VIEWPORT_SCISSOR_EXTENSION_NAME = "VK_NV_inherited_viewport_scissor";

const EXT_TEXEL_BUFFER_ALIGNMENT = 1;

const EXT_TEXEL_BUFFER_ALIGNMENT_SPEC_VERSION = 1;

const EXT_TEXEL_BUFFER_ALIGNMENT_EXTENSION_NAME = "VK_EXT_texel_buffer_alignment";

const QCOM_RENDER_PASS_TRANSFORM = 1;

const QCOM_RENDER_PASS_TRANSFORM_SPEC_VERSION = 2;

const QCOM_RENDER_PASS_TRANSFORM_EXTENSION_NAME = "VK_QCOM_render_pass_transform";

const EXT_DEVICE_MEMORY_REPORT = 1;

const EXT_DEVICE_MEMORY_REPORT_SPEC_VERSION = 2;

const EXT_DEVICE_MEMORY_REPORT_EXTENSION_NAME = "VK_EXT_device_memory_report";

const EXT_ACQUIRE_DRM_DISPLAY = 1;

const EXT_ACQUIRE_DRM_DISPLAY_SPEC_VERSION = 1;

const EXT_ACQUIRE_DRM_DISPLAY_EXTENSION_NAME = "VK_EXT_acquire_drm_display";

const EXT_ROBUSTNESS2 = 1;

const EXT_ROBUSTNESS_2_SPEC_VERSION = 1;

const EXT_ROBUSTNESS_2_EXTENSION_NAME = "VK_EXT_robustness2";

const EXT_CUSTOM_BORDER_COLOR = 1;

const EXT_CUSTOM_BORDER_COLOR_SPEC_VERSION = 12;

const EXT_CUSTOM_BORDER_COLOR_EXTENSION_NAME = "VK_EXT_custom_border_color";

const GOOGLE_USER_TYPE = 1;

const GOOGLE_USER_TYPE_SPEC_VERSION = 1;

const GOOGLE_USER_TYPE_EXTENSION_NAME = "VK_GOOGLE_user_type";

const EXT_PRIVATE_DATA = 1;

const EXT_PRIVATE_DATA_SPEC_VERSION = 1;

const EXT_PRIVATE_DATA_EXTENSION_NAME = "VK_EXT_private_data";

const EXT_PIPELINE_CREATION_CACHE_CONTROL = 1;

const EXT_PIPELINE_CREATION_CACHE_CONTROL_SPEC_VERSION = 3;

const EXT_PIPELINE_CREATION_CACHE_CONTROL_EXTENSION_NAME = "VK_EXT_pipeline_creation_cache_control";

const NV_DEVICE_DIAGNOSTICS_CONFIG = 1;

const NV_DEVICE_DIAGNOSTICS_CONFIG_SPEC_VERSION = 1;

const NV_DEVICE_DIAGNOSTICS_CONFIG_EXTENSION_NAME = "VK_NV_device_diagnostics_config";

const QCOM_RENDER_PASS_STORE_OPS = 1;

const QCOM_RENDER_PASS_STORE_OPS_SPEC_VERSION = 2;

const QCOM_RENDER_PASS_STORE_OPS_EXTENSION_NAME = "VK_QCOM_render_pass_store_ops";

const NV_FRAGMENT_SHADING_RATE_ENUMS = 1;

const NV_FRAGMENT_SHADING_RATE_ENUMS_SPEC_VERSION = 1;

const NV_FRAGMENT_SHADING_RATE_ENUMS_EXTENSION_NAME = "VK_NV_fragment_shading_rate_enums";

const NV_RAY_TRACING_MOTION_BLUR = 1;

const NV_RAY_TRACING_MOTION_BLUR_SPEC_VERSION = 1;

const NV_RAY_TRACING_MOTION_BLUR_EXTENSION_NAME = "VK_NV_ray_tracing_motion_blur";

const EXT_YCBCR_2PLANE_444_FORMATS = 1;

const EXT_YCBCR_2PLANE_444_FORMATS_SPEC_VERSION = 1;

const EXT_YCBCR_2PLANE_444_FORMATS_EXTENSION_NAME = "VK_EXT_ycbcr_2plane_444_formats";

const EXT_FRAGMENT_DENSITY_MAP2 = 1;

const EXT_FRAGMENT_DENSITY_MAP_2_SPEC_VERSION = 1;

const EXT_FRAGMENT_DENSITY_MAP_2_EXTENSION_NAME = "VK_EXT_fragment_density_map2";

const QCOM_ROTATED_COPY_COMMANDS = 1;

const QCOM_ROTATED_COPY_COMMANDS_SPEC_VERSION = 1;

const QCOM_ROTATED_COPY_COMMANDS_EXTENSION_NAME = "VK_QCOM_rotated_copy_commands";

const EXT_IMAGE_ROBUSTNESS = 1;

const EXT_IMAGE_ROBUSTNESS_SPEC_VERSION = 1;

const EXT_IMAGE_ROBUSTNESS_EXTENSION_NAME = "VK_EXT_image_robustness";

const EXT_4444_FORMATS = 1;

const EXT_4444_FORMATS_SPEC_VERSION = 1;

const EXT_4444_FORMATS_EXTENSION_NAME = "VK_EXT_4444_formats";

const ARM_RASTERIZATION_ORDER_ATTACHMENT_ACCESS = 1;

const ARM_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_SPEC_VERSION = 1;

const ARM_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_EXTENSION_NAME = "VK_ARM_rasterization_order_attachment_access";

const EXT_RGBA10X6_FORMATS = 1;

const EXT_RGBA10X6_FORMATS_SPEC_VERSION = 1;

const EXT_RGBA10X6_FORMATS_EXTENSION_NAME = "VK_EXT_rgba10x6_formats";

const NV_ACQUIRE_WINRT_DISPLAY = 1;

const NV_ACQUIRE_WINRT_DISPLAY_SPEC_VERSION = 1;

const NV_ACQUIRE_WINRT_DISPLAY_EXTENSION_NAME = "VK_NV_acquire_winrt_display";

const VALVE_MUTABLE_DESCRIPTOR_TYPE = 1;

const VALVE_MUTABLE_DESCRIPTOR_TYPE_SPEC_VERSION = 1;

const VALVE_MUTABLE_DESCRIPTOR_TYPE_EXTENSION_NAME = "VK_VALVE_mutable_descriptor_type";

const EXT_VERTEX_INPUT_DYNAMIC_STATE = 1;

const EXT_VERTEX_INPUT_DYNAMIC_STATE_SPEC_VERSION = 2;

const EXT_VERTEX_INPUT_DYNAMIC_STATE_EXTENSION_NAME = "VK_EXT_vertex_input_dynamic_state";

const EXT_PHYSICAL_DEVICE_DRM = 1;

const EXT_PHYSICAL_DEVICE_DRM_SPEC_VERSION = 1;

const EXT_PHYSICAL_DEVICE_DRM_EXTENSION_NAME = "VK_EXT_physical_device_drm";

const EXT_DEPTH_CLIP_CONTROL = 1;

const EXT_DEPTH_CLIP_CONTROL_SPEC_VERSION = 1;

const EXT_DEPTH_CLIP_CONTROL_EXTENSION_NAME = "VK_EXT_depth_clip_control";

const EXT_PRIMITIVE_TOPOLOGY_LIST_RESTART = 1;

const EXT_PRIMITIVE_TOPOLOGY_LIST_RESTART_SPEC_VERSION = 1;

const EXT_PRIMITIVE_TOPOLOGY_LIST_RESTART_EXTENSION_NAME = "VK_EXT_primitive_topology_list_restart";

const HUAWEI_SUBPASS_SHADING = 1;

const HUAWEI_SUBPASS_SHADING_SPEC_VERSION = 2;

const HUAWEI_SUBPASS_SHADING_EXTENSION_NAME = "VK_HUAWEI_subpass_shading";

const HUAWEI_INVOCATION_MASK = 1;

const HUAWEI_INVOCATION_MASK_SPEC_VERSION = 1;

const HUAWEI_INVOCATION_MASK_EXTENSION_NAME = "VK_HUAWEI_invocation_mask";

const NV_EXTERNAL_MEMORY_RDMA = 1;

const NV_EXTERNAL_MEMORY_RDMA_SPEC_VERSION = 1;

const NV_EXTERNAL_MEMORY_RDMA_EXTENSION_NAME = "VK_NV_external_memory_rdma";

const EXT_EXTENDED_DYNAMIC_STATE2 = 1;

const EXT_EXTENDED_DYNAMIC_STATE_2_SPEC_VERSION = 1;

const EXT_EXTENDED_DYNAMIC_STATE_2_EXTENSION_NAME = "VK_EXT_extended_dynamic_state2";

const EXT_COLOR_WRITE_ENABLE = 1;

const EXT_COLOR_WRITE_ENABLE_SPEC_VERSION = 1;

const EXT_COLOR_WRITE_ENABLE_EXTENSION_NAME = "VK_EXT_color_write_enable";

const EXT_GLOBAL_PRIORITY_QUERY = 1;

const MAX_GLOBAL_PRIORITY_SIZE_EXT = 16U;

const EXT_GLOBAL_PRIORITY_QUERY_SPEC_VERSION = 1;

const EXT_GLOBAL_PRIORITY_QUERY_EXTENSION_NAME = "VK_EXT_global_priority_query";

const EXT_IMAGE_VIEW_MIN_LOD = 1;

const EXT_IMAGE_VIEW_MIN_LOD_SPEC_VERSION = 1;

const EXT_IMAGE_VIEW_MIN_LOD_EXTENSION_NAME = "VK_EXT_image_view_min_lod";

const EXT_MULTI_DRAW = 1;

const EXT_MULTI_DRAW_SPEC_VERSION = 1;

const EXT_MULTI_DRAW_EXTENSION_NAME = "VK_EXT_multi_draw";

const EXT_LOAD_STORE_OP_NONE = 1;

const EXT_LOAD_STORE_OP_NONE_SPEC_VERSION = 1;

const EXT_LOAD_STORE_OP_NONE_EXTENSION_NAME = "VK_EXT_load_store_op_none";

const EXT_BORDER_COLOR_SWIZZLE = 1;

const EXT_BORDER_COLOR_SWIZZLE_SPEC_VERSION = 1;

const EXT_BORDER_COLOR_SWIZZLE_EXTENSION_NAME = "VK_EXT_border_color_swizzle";

const EXT_PAGEABLE_DEVICE_LOCAL_MEMORY = 1;

const EXT_PAGEABLE_DEVICE_LOCAL_MEMORY_SPEC_VERSION = 1;

const EXT_PAGEABLE_DEVICE_LOCAL_MEMORY_EXTENSION_NAME = "VK_EXT_pageable_device_local_memory";

const QCOM_FRAGMENT_DENSITY_MAP_OFFSET = 1;

const QCOM_FRAGMENT_DENSITY_MAP_OFFSET_SPEC_VERSION = 1;

const QCOM_FRAGMENT_DENSITY_MAP_OFFSET_EXTENSION_NAME = "VK_QCOM_fragment_density_map_offset";

const NV_LINEAR_COLOR_ATTACHMENT = 1;

const NV_LINEAR_COLOR_ATTACHMENT_SPEC_VERSION = 1;

const NV_LINEAR_COLOR_ATTACHMENT_EXTENSION_NAME = "VK_NV_linear_color_attachment";

const GOOGLE_SURFACELESS_QUERY = 1;

const GOOGLE_SURFACELESS_QUERY_SPEC_VERSION = 1;

const GOOGLE_SURFACELESS_QUERY_EXTENSION_NAME = "VK_GOOGLE_surfaceless_query";

const KHR_ACCELERATION_STRUCTURE = 1;

const KHR_ACCELERATION_STRUCTURE_SPEC_VERSION = 13;

const KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME = "VK_KHR_acceleration_structure";

const KHR_RAY_TRACING_PIPELINE = 1;

const KHR_RAY_TRACING_PIPELINE_SPEC_VERSION = 1;

const KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME = "VK_KHR_ray_tracing_pipeline";

const KHR_RAY_QUERY = 1;

const KHR_RAY_QUERY_SPEC_VERSION = 1;

const KHR_RAY_QUERY_EXTENSION_NAME = "VK_KHR_ray_query";

const KHR_ANDROID_SURFACE @if($defined(env::VK_USE_PLATFORM_ANDROID_KHR) &&& env::VK_USE_PLATFORM_ANDROID_KHR) = 1;

const KHR_ANDROID_SURFACE_SPEC_VERSION @if($defined(env::VK_USE_PLATFORM_ANDROID_KHR) &&& env::VK_USE_PLATFORM_ANDROID_KHR) = 6;

const KHR_ANDROID_SURFACE_EXTENSION_NAME @if($defined(env::VK_USE_PLATFORM_ANDROID_KHR) &&& env::VK_USE_PLATFORM_ANDROID_KHR) = "VK_KHR_android_surface";

const ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER @if($defined(env::VK_USE_PLATFORM_ANDROID_KHR) &&& env::VK_USE_PLATFORM_ANDROID_KHR) = 1;

const ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION @if($defined(env::VK_USE_PLATFORM_ANDROID_KHR) &&& env::VK_USE_PLATFORM_ANDROID_KHR) = 4;

const ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME @if($defined(env::VK_USE_PLATFORM_ANDROID_KHR) &&& env::VK_USE_PLATFORM_ANDROID_KHR) = "VK_ANDROID_external_memory_android_hardware_buffer";

const FUCHSIA_IMAGEPIPE_SURFACE @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) = 1;

const FUCHSIA_IMAGEPIPE_SURFACE_SPEC_VERSION @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) = 1;

const FUCHSIA_IMAGEPIPE_SURFACE_EXTENSION_NAME @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) = "VK_FUCHSIA_imagepipe_surface";

const FUCHSIA_EXTERNAL_MEMORY @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) = 1;

const FUCHSIA_EXTERNAL_MEMORY_SPEC_VERSION @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) = 1;

const FUCHSIA_EXTERNAL_MEMORY_EXTENSION_NAME @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) = "VK_FUCHSIA_external_memory";

const FUCHSIA_EXTERNAL_SEMAPHORE @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) = 1;

const FUCHSIA_EXTERNAL_SEMAPHORE_SPEC_VERSION @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) = 1;

const FUCHSIA_EXTERNAL_SEMAPHORE_EXTENSION_NAME @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) = "VK_FUCHSIA_external_semaphore";

const FUCHSIA_BUFFER_COLLECTION @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) = 1;

const FUCHSIA_BUFFER_COLLECTION_SPEC_VERSION @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) = 2;

const FUCHSIA_BUFFER_COLLECTION_EXTENSION_NAME @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) = "VK_FUCHSIA_buffer_collection";

const MVK_IOS_SURFACE @if($defined(env::VK_USE_PLATFORM_IOS_MVK) &&& env::VK_USE_PLATFORM_IOS_MVK) = 1;

const MVK_IOS_SURFACE_SPEC_VERSION @if($defined(env::VK_USE_PLATFORM_IOS_MVK) &&& env::VK_USE_PLATFORM_IOS_MVK) = 3;

const MVK_IOS_SURFACE_EXTENSION_NAME @if($defined(env::VK_USE_PLATFORM_IOS_MVK) &&& env::VK_USE_PLATFORM_IOS_MVK) = "VK_MVK_ios_surface";

const MVK_MACOS_SURFACE @if($defined(env::VK_USE_PLATFORM_MACOS_MVK) &&& env::VK_USE_PLATFORM_MACOS_MVK) = 1;

const MVK_MACOS_SURFACE_SPEC_VERSION @if($defined(env::VK_USE_PLATFORM_MACOS_MVK) &&& env::VK_USE_PLATFORM_MACOS_MVK) = 3;

const MVK_MACOS_SURFACE_EXTENSION_NAME @if($defined(env::VK_USE_PLATFORM_MACOS_MVK) &&& env::VK_USE_PLATFORM_MACOS_MVK) = "VK_MVK_macos_surface";

const EXT_METAL_SURFACE @if($defined(env::VK_USE_PLATFORM_METAL_EXT) &&& env::VK_USE_PLATFORM_METAL_EXT) = 1;

const EXT_METAL_SURFACE_SPEC_VERSION @if($defined(env::VK_USE_PLATFORM_METAL_EXT) &&& env::VK_USE_PLATFORM_METAL_EXT) = 1;

const EXT_METAL_SURFACE_EXTENSION_NAME @if($defined(env::VK_USE_PLATFORM_METAL_EXT) &&& env::VK_USE_PLATFORM_METAL_EXT) = "VK_EXT_metal_surface";

const NN_VI_SURFACE @if($defined(env::VK_USE_PLATFORM_VI_NN) &&& env::VK_USE_PLATFORM_VI_NN) = 1;

const NN_VI_SURFACE_SPEC_VERSION @if($defined(env::VK_USE_PLATFORM_VI_NN) &&& env::VK_USE_PLATFORM_VI_NN) = 1;

const NN_VI_SURFACE_EXTENSION_NAME @if($defined(env::VK_USE_PLATFORM_VI_NN) &&& env::VK_USE_PLATFORM_VI_NN) = "VK_NN_vi_surface";

const KHR_WAYLAND_SURFACE @if($defined(env::VK_USE_PLATFORM_WAYLAND_KHR) &&& env::VK_USE_PLATFORM_WAYLAND_KHR) = 1;

const KHR_WAYLAND_SURFACE_SPEC_VERSION @if($defined(env::VK_USE_PLATFORM_WAYLAND_KHR) &&& env::VK_USE_PLATFORM_WAYLAND_KHR) = 6;

const KHR_WAYLAND_SURFACE_EXTENSION_NAME @if($defined(env::VK_USE_PLATFORM_WAYLAND_KHR) &&& env::VK_USE_PLATFORM_WAYLAND_KHR) = "VK_KHR_wayland_surface";

const KHR_WIN32_SURFACE @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR) = 1;

const KHR_WIN32_SURFACE_SPEC_VERSION @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR) = 6;

const KHR_WIN32_SURFACE_EXTENSION_NAME @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR) = "VK_KHR_win32_surface";

const KHR_EXTERNAL_MEMORY_WIN32 = 1;

const KHR_EXTERNAL_MEMORY_WIN32_SPEC_VERSION @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR) = 1;

const KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR) = "VK_KHR_external_memory_win32";

const KHR_WIN32_KEYED_MUTEX @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR) = 1;

const KHR_WIN32_KEYED_MUTEX_SPEC_VERSION @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR) = 1;

const KHR_WIN32_KEYED_MUTEX_EXTENSION_NAME @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR) = "VK_KHR_win32_keyed_mutex";

const KHR_EXTERNAL_SEMAPHORE_WIN32 = 1;

const KHR_EXTERNAL_SEMAPHORE_WIN32_SPEC_VERSION @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR) = 1;

const KHR_EXTERNAL_SEMAPHORE_WIN32_EXTENSION_NAME @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR) = "VK_KHR_external_semaphore_win32";

const KHR_EXTERNAL_FENCE_WIN32 = 1;

const KHR_EXTERNAL_FENCE_WIN32_SPEC_VERSION @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR) = 1;

const KHR_EXTERNAL_FENCE_WIN32_EXTENSION_NAME @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR) = "VK_KHR_external_fence_win32";

const NV_EXTERNAL_MEMORY_WIN32 = 1;

const NV_EXTERNAL_MEMORY_WIN32_SPEC_VERSION @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR) = 1;

const NV_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR) = "VK_NV_external_memory_win32";

const NV_WIN32_KEYED_MUTEX @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR) = 1;

const NV_WIN32_KEYED_MUTEX_SPEC_VERSION @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR) = 2;

const NV_WIN32_KEYED_MUTEX_EXTENSION_NAME @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR) = "VK_NV_win32_keyed_mutex";

const EXT_FULL_SCREEN_EXCLUSIVE = 1;

const EXT_FULL_SCREEN_EXCLUSIVE_SPEC_VERSION = 4;

const EXT_FULL_SCREEN_EXCLUSIVE_EXTENSION_NAME = "VK_EXT_full_screen_exclusive";

const KHR_XCB_SURFACE @if($defined(env::VK_USE_PLATFORM_XCB_KHR) &&& env::VK_USE_PLATFORM_XCB_KHR) = 1;

const KHR_XCB_SURFACE_SPEC_VERSION @if($defined(env::VK_USE_PLATFORM_XCB_KHR) &&& env::VK_USE_PLATFORM_XCB_KHR) = 6;

const KHR_XCB_SURFACE_EXTENSION_NAME @if($defined(env::VK_USE_PLATFORM_XCB_KHR) &&& env::VK_USE_PLATFORM_XCB_KHR) = "VK_KHR_xcb_surface";

const KHR_XLIB_SURFACE @if($defined(env::VK_USE_PLATFORM_XLIB_KHR) &&& env::VK_USE_PLATFORM_XLIB_KHR) = 1;

const KHR_XLIB_SURFACE_SPEC_VERSION @if($defined(env::VK_USE_PLATFORM_XLIB_KHR) &&& env::VK_USE_PLATFORM_XLIB_KHR) = 6;

const KHR_XLIB_SURFACE_EXTENSION_NAME @if($defined(env::VK_USE_PLATFORM_XLIB_KHR) &&& env::VK_USE_PLATFORM_XLIB_KHR) = "VK_KHR_xlib_surface";

const EXT_DIRECTFB_SURFACE @if($defined(env::VK_USE_PLATFORM_DIRECTFB_EXT) &&& env::VK_USE_PLATFORM_DIRECTFB_EXT) = 1;

const EXT_DIRECTFB_SURFACE_SPEC_VERSION @if($defined(env::VK_USE_PLATFORM_DIRECTFB_EXT) &&& env::VK_USE_PLATFORM_DIRECTFB_EXT) = 1;

const EXT_DIRECTFB_SURFACE_EXTENSION_NAME @if($defined(env::VK_USE_PLATFORM_DIRECTFB_EXT) &&& env::VK_USE_PLATFORM_DIRECTFB_EXT) = "VK_EXT_directfb_surface";

const GGP_STREAM_DESCRIPTOR_SURFACE @if($defined(env::VK_USE_PLATFORM_GGP) &&& env::VK_USE_PLATFORM_GGP) = 1;

const GGP_STREAM_DESCRIPTOR_SURFACE_SPEC_VERSION @if($defined(env::VK_USE_PLATFORM_GGP) &&& env::VK_USE_PLATFORM_GGP) = 1;

const GGP_STREAM_DESCRIPTOR_SURFACE_EXTENSION_NAME @if($defined(env::VK_USE_PLATFORM_GGP) &&& env::VK_USE_PLATFORM_GGP) = "VK_GGP_stream_descriptor_surface";

const GGP_FRAME_TOKEN @if($defined(env::VK_USE_PLATFORM_GGP) &&& env::VK_USE_PLATFORM_GGP) = 1;

const GGP_FRAME_TOKEN_SPEC_VERSION @if($defined(env::VK_USE_PLATFORM_GGP) &&& env::VK_USE_PLATFORM_GGP) = 1;

const GGP_FRAME_TOKEN_EXTENSION_NAME @if($defined(env::VK_USE_PLATFORM_GGP) &&& env::VK_USE_PLATFORM_GGP) = "VK_GGP_frame_token";

const QNX_SCREEN_SURFACE @if($defined(env::VK_USE_PLATFORM_SCREEN_QNX) &&& env::VK_USE_PLATFORM_SCREEN_QNX) = 1;

const QNX_SCREEN_SURFACE_SPEC_VERSION @if($defined(env::VK_USE_PLATFORM_SCREEN_QNX) &&& env::VK_USE_PLATFORM_SCREEN_QNX) = 1;

const QNX_SCREEN_SURFACE_EXTENSION_NAME @if($defined(env::VK_USE_PLATFORM_SCREEN_QNX) &&& env::VK_USE_PLATFORM_SCREEN_QNX) = "VK_QNX_screen_surface";

const KHR_VIDEO_QUEUE = 1;

const KHR_VIDEO_QUEUE_SPEC_VERSION = 2;

const KHR_VIDEO_QUEUE_EXTENSION_NAME = "VK_KHR_video_queue";

const KHR_VIDEO_DECODE_QUEUE = 1;

const KHR_VIDEO_DECODE_QUEUE_SPEC_VERSION = 2;

const KHR_VIDEO_DECODE_QUEUE_EXTENSION_NAME = "VK_KHR_video_decode_queue";

const KHR_PORTABILITY_SUBSET = 1;

const KHR_PORTABILITY_SUBSET_SPEC_VERSION = 1;

const KHR_PORTABILITY_SUBSET_EXTENSION_NAME = "VK_KHR_portability_subset";

const KHR_VIDEO_ENCODE_QUEUE = 1;

const KHR_VIDEO_ENCODE_QUEUE_SPEC_VERSION = 3;

const KHR_VIDEO_ENCODE_QUEUE_EXTENSION_NAME = "VK_KHR_video_encode_queue";

const EXT_VIDEO_ENCODE_H264 = 1;

const VULKAN_VIDEO_CODEC_H264STD = 1;

const VULKAN_VIDEO_CODECS_COMMON = 1;

macro @makeVideoStdVersion(#major, #minor, #patch) {
  return (((uint)#major) << 22) | (((uint)#minor) << 12) | ((uint)#patch);
}

const STD_VULKAN_VIDEO_CODEC_H264_API_VERSION_0_9_5 = @makeVideoStdVersion(0,9,5);

const STD_VIDEO_H264_CPB_CNT_LIST_SIZE = 32;

const STD_VIDEO_H264_SCALING_LIST_4X4_NUM_LISTS = 6;

const STD_VIDEO_H264_SCALING_LIST_4X4_NUM_ELEMENTS = 16;

const STD_VIDEO_H264_SCALING_LIST_8X8_NUM_LISTS = 2;

const STD_VIDEO_H264_SCALING_LIST_8X8_NUM_ELEMENTS = 64;

const STD_VULKAN_VIDEO_CODEC_H264_SPEC_VERSION = STD_VULKAN_VIDEO_CODEC_H264_API_VERSION_0_9_5;

const STD_VULKAN_VIDEO_CODEC_H264_EXTENSION_NAME = "VK_STD_vulkan_video_codec_h264";

const VULKAN_VIDEO_CODEC_H264STD_ENCODE = 1;

const EXT_VIDEO_ENCODE_H264_SPEC_VERSION = 3;

const EXT_VIDEO_ENCODE_H264_EXTENSION_NAME = "VK_EXT_video_encode_h264";

const EXT_VIDEO_ENCODE_H265 = 1;

const VULKAN_VIDEO_CODEC_H265STD = 1;

const STD_VULKAN_VIDEO_CODEC_H265_API_VERSION_0_9_5 = @makeVideoStdVersion(0,9,5);

const STD_VIDEO_H265_SUBLAYERS_MINUS1_LIST_SIZE = 7;

const STD_VIDEO_H265_CPB_CNT_LIST_SIZE = 32;

const STD_VIDEO_H265_SCALING_LIST_4X4_NUM_LISTS = 6;

const STD_VIDEO_H265_SCALING_LIST_4X4_NUM_ELEMENTS = 16;

const STD_VIDEO_H265_SCALING_LIST_8X8_NUM_LISTS = 6;

const STD_VIDEO_H265_SCALING_LIST_8X8_NUM_ELEMENTS = 64;

const STD_VIDEO_H265_SCALING_LIST_16X16_NUM_LISTS = 6;

const STD_VIDEO_H265_SCALING_LIST_16X16_NUM_ELEMENTS = 64;

const STD_VIDEO_H265_SCALING_LIST_32X32_NUM_LISTS = 2;

const STD_VIDEO_H265_SCALING_LIST_32X32_NUM_ELEMENTS = 64;

const STD_VIDEO_H265_PREDICTOR_PALETTE_COMPONENTS_LIST_SIZE = 3;

const STD_VIDEO_H265_PREDICTOR_PALETTE_COMP_ENTRIES_LIST_SIZE = 128;

const STD_VIDEO_H265_CHROMA_QP_OFFSET_TILE_COLS_LIST_SIZE = 19;

const STD_VIDEO_H265_CHROMA_QP_OFFSET_TILE_ROWS_LIST_SIZE = 21;

const STD_VIDEO_H265_CHROMA_QP_OFFSET_LIST_SIZE = 6;

const STD_VULKAN_VIDEO_CODEC_H265_SPEC_VERSION = STD_VULKAN_VIDEO_CODEC_H265_API_VERSION_0_9_5;

const STD_VULKAN_VIDEO_CODEC_H265_EXTENSION_NAME = "VK_STD_vulkan_video_codec_h265";

const VULKAN_VIDEO_CODEC_H265STD_ENCODE = 1;

const STD_VIDEO_ENCODE_H265_LUMA_LIST_SIZE = 15;

const STD_VIDEO_ENCODE_H265_CHROMA_LIST_SIZE = 15;

const STD_VIDEO_ENCODE_H265_CHROMA_LISTS_NUM = 2;

const EXT_VIDEO_ENCODE_H265_SPEC_VERSION = 3;

const EXT_VIDEO_ENCODE_H265_EXTENSION_NAME = "VK_EXT_video_encode_h265";

const EXT_VIDEO_DECODE_H264 = 1;

const VULKAN_VIDEO_CODEC_H264STD_DECODE = 1;

const STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_LIST_SIZE = 2;

const STD_VIDEO_DECODE_H264_MVC_REF_LIST_SIZE = 15;

const EXT_VIDEO_DECODE_H264_SPEC_VERSION = 3;

const EXT_VIDEO_DECODE_H264_EXTENSION_NAME = "VK_EXT_video_decode_h264";

const EXT_VIDEO_DECODE_H265 = 1;

const VULKAN_VIDEO_CODEC_H265STD_DECODE = 1;

const STD_VIDEO_DECODE_H265_REF_PIC_SET_LIST_SIZE = 8;

const EXT_VIDEO_DECODE_H265_SPEC_VERSION = 1;

const EXT_VIDEO_DECODE_H265_EXTENSION_NAME = "VK_EXT_video_decode_h265";

alias VkBool32 = uint;

alias VkDeviceAddress = ulong;

alias VkDeviceSize = ulong;

alias VkFlags = uint;

alias VkSampleMask = uint;

typedef VkBuffer_T = void;

alias VkBuffer = VkBuffer_T *;

typedef VkImage_T = void;

alias VkImage = VkImage_T *;

typedef VkInstance_T = void;

alias VkInstance = VkInstance_T *;

typedef VkPhysicalDevice_T = void;

alias VkPhysicalDevice = VkPhysicalDevice_T *;

typedef VkDevice_T = void;

alias VkDevice = VkDevice_T *;

typedef VkQueue_T = void;

alias VkQueue = VkQueue_T *;

typedef VkSemaphore_T = void;

alias VkSemaphore = VkSemaphore_T *;

typedef VkCommandBuffer_T = void;

alias VkCommandBuffer = VkCommandBuffer_T *;

typedef VkFence_T = void;

alias VkFence = VkFence_T *;

typedef VkDeviceMemory_T = void;

alias VkDeviceMemory = VkDeviceMemory_T *;

typedef VkEvent_T = void;

alias VkEvent = VkEvent_T *;

typedef VkQueryPool_T = void;

alias VkQueryPool = VkQueryPool_T *;

typedef VkBufferView_T = void;

alias VkBufferView = VkBufferView_T *;

typedef VkImageView_T = void;

alias VkImageView = VkImageView_T *;

typedef VkShaderModule_T = void;

alias VkShaderModule = VkShaderModule_T *;

typedef VkPipelineCache_T = void;

alias VkPipelineCache = VkPipelineCache_T *;

typedef VkPipelineLayout_T = void;

alias VkPipelineLayout = VkPipelineLayout_T *;

typedef VkPipeline_T = void;

alias VkPipeline = VkPipeline_T *;

typedef VkRenderPass_T = void;

alias VkRenderPass = VkRenderPass_T *;

typedef VkDescriptorSetLayout_T = void;

alias VkDescriptorSetLayout = VkDescriptorSetLayout_T *;

typedef VkSampler_T = void;

alias VkSampler = VkSampler_T *;

typedef VkDescriptorSet_T = void;

alias VkDescriptorSet = VkDescriptorSet_T *;

typedef VkDescriptorPool_T = void;

alias VkDescriptorPool = VkDescriptorPool_T *;

typedef VkFramebuffer_T = void;

alias VkFramebuffer = VkFramebuffer_T *;

typedef VkCommandPool_T = void;

alias VkCommandPool = VkCommandPool_T *;

typedef VkResult = inline CInt;
const VkResult SUCCESS = 0;
const VkResult NOT_READY = 1;
const VkResult TIMEOUT = 2;
const VkResult EVENT_SET = 3;
const VkResult EVENT_RESET = 4;
const VkResult INCOMPLETE = 5;
const VkResult ERROR_OUT_OF_HOST_MEMORY = -1;
const VkResult ERROR_OUT_OF_DEVICE_MEMORY = -2;
const VkResult ERROR_INITIALIZATION_FAILED = -3;
const VkResult ERROR_DEVICE_LOST = -4;
const VkResult ERROR_MEMORY_MAP_FAILED = -5;
const VkResult ERROR_LAYER_NOT_PRESENT = -6;
const VkResult ERROR_EXTENSION_NOT_PRESENT = -7;
const VkResult ERROR_FEATURE_NOT_PRESENT = -8;
const VkResult ERROR_INCOMPATIBLE_DRIVER = -9;
const VkResult ERROR_TOO_MANY_OBJECTS = -10;
const VkResult ERROR_FORMAT_NOT_SUPPORTED = -11;
const VkResult ERROR_FRAGMENTED_POOL = -12;
const VkResult ERROR_UNKNOWN = -13;
const VkResult ERROR_OUT_OF_POOL_MEMORY = -1000069000;
const VkResult ERROR_INVALID_EXTERNAL_HANDLE = -1000072003;
const VkResult ERROR_FRAGMENTATION = -1000161000;
const VkResult ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS = -1000257000;
const VkResult ERROR_SURFACE_LOST_KHR = -1000000000;
const VkResult ERROR_NATIVE_WINDOW_IN_USE_KHR = -1000000001;
const VkResult SUBOPTIMAL_KHR = 1000001003;
const VkResult ERROR_OUT_OF_DATE_KHR = -1000001004;
const VkResult ERROR_INCOMPATIBLE_DISPLAY_KHR = -1000003001;
const VkResult ERROR_VALIDATION_FAILED_EXT = -1000011001;
const VkResult ERROR_INVALID_SHADER_NV = -1000012000;
const VkResult ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT = -1000158000;
const VkResult ERROR_NOT_PERMITTED_EXT = -1000174001;
const VkResult ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT = -1000255000;
const VkResult THREAD_IDLE_KHR = 1000268000;
const VkResult THREAD_DONE_KHR = 1000268001;
const VkResult OPERATION_DEFERRED_KHR = 1000268002;
const VkResult OPERATION_NOT_DEFERRED_KHR = 1000268003;
const VkResult PIPELINE_COMPILE_REQUIRED_EXT = 1000297000;
const VkResult ERROR_OUT_OF_POOL_MEMORY_KHR = ERROR_OUT_OF_POOL_MEMORY;
const VkResult ERROR_INVALID_EXTERNAL_HANDLE_KHR = ERROR_INVALID_EXTERNAL_HANDLE;
const VkResult ERROR_FRAGMENTATION_EXT = ERROR_FRAGMENTATION;
const VkResult ERROR_INVALID_DEVICE_ADDRESS_EXT = ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS;
const VkResult ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR = ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS;
const VkResult ERROR_PIPELINE_COMPILE_REQUIRED_EXT = PIPELINE_COMPILE_REQUIRED_EXT;
const VkResult RESULT_MAX_ENUM = 0x7FFFFFFF;

typedef VkStructureType = inline CUInt;
const VkStructureType STRUCTURE_TYPE_APPLICATION_INFO = 0;
const VkStructureType STRUCTURE_TYPE_INSTANCE_CREATE_INFO = 1;
const VkStructureType STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO = 2;
const VkStructureType STRUCTURE_TYPE_DEVICE_CREATE_INFO = 3;
const VkStructureType STRUCTURE_TYPE_SUBMIT_INFO = 4;
const VkStructureType STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO = 5;
const VkStructureType STRUCTURE_TYPE_MAPPED_MEMORY_RANGE = 6;
const VkStructureType STRUCTURE_TYPE_BIND_SPARSE_INFO = 7;
const VkStructureType STRUCTURE_TYPE_FENCE_CREATE_INFO = 8;
const VkStructureType STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO = 9;
const VkStructureType STRUCTURE_TYPE_EVENT_CREATE_INFO = 10;
const VkStructureType STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO = 11;
const VkStructureType STRUCTURE_TYPE_BUFFER_CREATE_INFO = 12;
const VkStructureType STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO = 13;
const VkStructureType STRUCTURE_TYPE_IMAGE_CREATE_INFO = 14;
const VkStructureType STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO = 15;
const VkStructureType STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO = 16;
const VkStructureType STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO = 17;
const VkStructureType STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO = 18;
const VkStructureType STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = 19;
const VkStructureType STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20;
const VkStructureType STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO = 21;
const VkStructureType STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO = 22;
const VkStructureType STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO = 23;
const VkStructureType STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = 24;
const VkStructureType STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = 25;
const VkStructureType STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = 26;
const VkStructureType STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO = 27;
const VkStructureType STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO = 28;
const VkStructureType STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO = 29;
const VkStructureType STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO = 30;
const VkStructureType STRUCTURE_TYPE_SAMPLER_CREATE_INFO = 31;
const VkStructureType STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO = 32;
const VkStructureType STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO = 33;
const VkStructureType STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO = 34;
const VkStructureType STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET = 35;
const VkStructureType STRUCTURE_TYPE_COPY_DESCRIPTOR_SET = 36;
const VkStructureType STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO = 37;
const VkStructureType STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO = 38;
const VkStructureType STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO = 39;
const VkStructureType STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO = 40;
const VkStructureType STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO = 41;
const VkStructureType STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO = 42;
const VkStructureType STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO = 43;
const VkStructureType STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER = 44;
const VkStructureType STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER = 45;
const VkStructureType STRUCTURE_TYPE_MEMORY_BARRIER = 46;
const VkStructureType STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO = 47;
const VkStructureType STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO = 48;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES = 1000094000;
const VkStructureType STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO = 1000157000;
const VkStructureType STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO = 1000157001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES = 1000083000;
const VkStructureType STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS = 1000127000;
const VkStructureType STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO = 1000127001;
const VkStructureType STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO = 1000060000;
const VkStructureType STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO = 1000060003;
const VkStructureType STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO = 1000060004;
const VkStructureType STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO = 1000060005;
const VkStructureType STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO = 1000060006;
const VkStructureType STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO = 1000060013;
const VkStructureType STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO = 1000060014;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES = 1000070000;
const VkStructureType STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO = 1000070001;
const VkStructureType STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2 = 1000146000;
const VkStructureType STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2 = 1000146001;
const VkStructureType STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2 = 1000146002;
const VkStructureType STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2 = 1000146003;
const VkStructureType STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2 = 1000146004;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 = 1000059000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 = 1000059001;
const VkStructureType STRUCTURE_TYPE_FORMAT_PROPERTIES_2 = 1000059002;
const VkStructureType STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2 = 1000059003;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2 = 1000059004;
const VkStructureType STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2 = 1000059005;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2 = 1000059006;
const VkStructureType STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2 = 1000059007;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2 = 1000059008;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES = 1000117000;
const VkStructureType STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO = 1000117001;
const VkStructureType STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO = 1000117002;
const VkStructureType STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO = 1000117003;
const VkStructureType STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO = 1000053000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES = 1000053001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES = 1000053002;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES = 1000120000;
const VkStructureType STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO = 1000145000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES = 1000145001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES = 1000145002;
const VkStructureType STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2 = 1000145003;
const VkStructureType STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO = 1000156000;
const VkStructureType STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO = 1000156001;
const VkStructureType STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO = 1000156002;
const VkStructureType STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO = 1000156003;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES = 1000156004;
const VkStructureType STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES = 1000156005;
const VkStructureType STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO = 1000085000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO = 1000071000;
const VkStructureType STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES = 1000071001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO = 1000071002;
const VkStructureType STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES = 1000071003;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES = 1000071004;
const VkStructureType STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO = 1000072000;
const VkStructureType STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO = 1000072001;
const VkStructureType STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO = 1000072002;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO = 1000112000;
const VkStructureType STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES = 1000112001;
const VkStructureType STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO = 1000113000;
const VkStructureType STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO = 1000077000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO = 1000076000;
const VkStructureType STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES = 1000076001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES = 1000168000;
const VkStructureType STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT = 1000168001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES = 1000063000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES = 49;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES = 50;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES = 51;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES = 52;
const VkStructureType STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO = 1000147000;
const VkStructureType STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2 = 1000109000;
const VkStructureType STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2 = 1000109001;
const VkStructureType STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2 = 1000109002;
const VkStructureType STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2 = 1000109003;
const VkStructureType STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2 = 1000109004;
const VkStructureType STRUCTURE_TYPE_SUBPASS_BEGIN_INFO = 1000109005;
const VkStructureType STRUCTURE_TYPE_SUBPASS_END_INFO = 1000109006;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES = 1000177000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES = 1000196000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES = 1000180000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES = 1000082000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES = 1000197000;
const VkStructureType STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO = 1000161000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES = 1000161001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES = 1000161002;
const VkStructureType STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO = 1000161003;
const VkStructureType STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT = 1000161004;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES = 1000199000;
const VkStructureType STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE = 1000199001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES = 1000221000;
const VkStructureType STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO = 1000246000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES = 1000130000;
const VkStructureType STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO = 1000130001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES = 1000211000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES = 1000108000;
const VkStructureType STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO = 1000108001;
const VkStructureType STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO = 1000108002;
const VkStructureType STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO = 1000108003;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES = 1000253000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES = 1000175000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES = 1000241000;
const VkStructureType STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT = 1000241001;
const VkStructureType STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT = 1000241002;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES = 1000261000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES = 1000207000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES = 1000207001;
const VkStructureType STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO = 1000207002;
const VkStructureType STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO = 1000207003;
const VkStructureType STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO = 1000207004;
const VkStructureType STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO = 1000207005;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES = 1000257000;
const VkStructureType STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO = 1000244001;
const VkStructureType STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO = 1000257002;
const VkStructureType STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO = 1000257003;
const VkStructureType STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO = 1000257004;
const VkStructureType STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR = 1000001000;
const VkStructureType STRUCTURE_TYPE_PRESENT_INFO_KHR = 1000001001;
const VkStructureType STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR = 1000060007;
const VkStructureType STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR = 1000060008;
const VkStructureType STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR = 1000060009;
const VkStructureType STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR = 1000060010;
const VkStructureType STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR = 1000060011;
const VkStructureType STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR = 1000060012;
const VkStructureType STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR = 1000002000;
const VkStructureType STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR = 1000002001;
const VkStructureType STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR = 1000003000;
const VkStructureType STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR = 1000004000;
const VkStructureType STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR = 1000005000;
const VkStructureType STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR = 1000006000;
const VkStructureType STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR = 1000008000;
const VkStructureType STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR = 1000009000;
const VkStructureType STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT = 1000011000;
const VkStructureType STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD = 1000018000;
const VkStructureType STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT = 1000022000;
const VkStructureType STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT = 1000022001;
const VkStructureType STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT = 1000022002;
const VkStructureType STRUCTURE_TYPE_VIDEO_PROFILE_KHR = 1000023000;
const VkStructureType STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR = 1000023001;
const VkStructureType STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_KHR = 1000023002;
const VkStructureType STRUCTURE_TYPE_VIDEO_GET_MEMORY_PROPERTIES_KHR = 1000023003;
const VkStructureType STRUCTURE_TYPE_VIDEO_BIND_MEMORY_KHR = 1000023004;
const VkStructureType STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR = 1000023005;
const VkStructureType STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000023006;
const VkStructureType STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR = 1000023007;
const VkStructureType STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR = 1000023008;
const VkStructureType STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR = 1000023009;
const VkStructureType STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR = 1000023010;
const VkStructureType STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_KHR = 1000023011;
const VkStructureType STRUCTURE_TYPE_VIDEO_QUEUE_FAMILY_PROPERTIES_2_KHR = 1000023012;
const VkStructureType STRUCTURE_TYPE_VIDEO_PROFILES_KHR = 1000023013;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR = 1000023014;
const VkStructureType STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR = 1000023015;
const VkStructureType STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_2_KHR = 1000023016;
const VkStructureType STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR = 1000024000;
const VkStructureType STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV = 1000026000;
const VkStructureType STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV = 1000026001;
const VkStructureType STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV = 1000026002;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT = 1000028000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT = 1000028001;
const VkStructureType STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT = 1000028002;
const VkStructureType STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX = 1000029000;
const VkStructureType STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX = 1000029001;
const VkStructureType STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX = 1000029002;
const VkStructureType STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX = 1000030000;
const VkStructureType STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX = 1000030001;
const VkStructureType STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_EXT = 1000038000;
const VkStructureType STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_EXT = 1000038001;
const VkStructureType STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_EXT = 1000038002;
const VkStructureType STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT = 1000038003;
const VkStructureType STRUCTURE_TYPE_VIDEO_ENCODE_H264_VCL_FRAME_INFO_EXT = 1000038004;
const VkStructureType STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_EXT = 1000038005;
const VkStructureType STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_EXT = 1000038006;
const VkStructureType STRUCTURE_TYPE_VIDEO_ENCODE_H264_EMIT_PICTURE_PARAMETERS_EXT = 1000038007;
const VkStructureType STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_EXT = 1000038008;
const VkStructureType STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_EXT = 1000038009;
const VkStructureType STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_EXT = 1000038010;
const VkStructureType STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_EXT = 1000039000;
const VkStructureType STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_EXT = 1000039001;
const VkStructureType STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_EXT = 1000039002;
const VkStructureType STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_EXT = 1000039003;
const VkStructureType STRUCTURE_TYPE_VIDEO_ENCODE_H265_VCL_FRAME_INFO_EXT = 1000039004;
const VkStructureType STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_EXT = 1000039005;
const VkStructureType STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_EXT = 1000039006;
const VkStructureType STRUCTURE_TYPE_VIDEO_ENCODE_H265_EMIT_PICTURE_PARAMETERS_EXT = 1000039007;
const VkStructureType STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_EXT = 1000039008;
const VkStructureType STRUCTURE_TYPE_VIDEO_ENCODE_H265_REFERENCE_LISTS_EXT = 1000039009;
const VkStructureType STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_EXT = 1000039010;
const VkStructureType STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_EXT = 1000039011;
const VkStructureType STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_EXT = 1000040000;
const VkStructureType STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_CREATE_INFO_EXT = 1000040001;
const VkStructureType STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_EXT = 1000040002;
const VkStructureType STRUCTURE_TYPE_VIDEO_DECODE_H264_MVC_EXT = 1000040003;
const VkStructureType STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_EXT = 1000040004;
const VkStructureType STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_EXT = 1000040005;
const VkStructureType STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT = 1000040006;
const VkStructureType STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_EXT = 1000040007;
const VkStructureType STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD = 1000041000;
const VkStructureType STRUCTURE_TYPE_RENDERING_INFO_KHR = 1000044000;
const VkStructureType STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO_KHR = 1000044001;
const VkStructureType STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO_KHR = 1000044002;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES_KHR = 1000044003;
const VkStructureType STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO_KHR = 1000044004;
const VkStructureType STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR = 1000044006;
const VkStructureType STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT = 1000044007;
const VkStructureType STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD = 1000044008;
const VkStructureType STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX = 1000044009;
const VkStructureType STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP = 1000049000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV = 1000050000;
const VkStructureType STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV = 1000056000;
const VkStructureType STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV = 1000056001;
const VkStructureType STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057000;
const VkStructureType STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057001;
const VkStructureType STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV = 1000058000;
const VkStructureType STRUCTURE_TYPE_VALIDATION_FLAGS_EXT = 1000061000;
const VkStructureType STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN = 1000062000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT = 1000066000;
const VkStructureType STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT = 1000067000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT = 1000067001;
const VkStructureType STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073000;
const VkStructureType STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073001;
const VkStructureType STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR = 1000073002;
const VkStructureType STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR = 1000073003;
const VkStructureType STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR = 1000074000;
const VkStructureType STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR = 1000074001;
const VkStructureType STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR = 1000074002;
const VkStructureType STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR = 1000075000;
const VkStructureType STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078000;
const VkStructureType STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078001;
const VkStructureType STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR = 1000078002;
const VkStructureType STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR = 1000078003;
const VkStructureType STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR = 1000079000;
const VkStructureType STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR = 1000079001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR = 1000080000;
const VkStructureType STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT = 1000081000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT = 1000081001;
const VkStructureType STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT = 1000081002;
const VkStructureType STRUCTURE_TYPE_PRESENT_REGIONS_KHR = 1000084000;
const VkStructureType STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV = 1000087000;
const VkStructureType STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT = 1000090000;
const VkStructureType STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT = 1000091000;
const VkStructureType STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT = 1000091001;
const VkStructureType STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT = 1000091002;
const VkStructureType STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT = 1000091003;
const VkStructureType STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE = 1000092000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX = 1000097000;
const VkStructureType STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV = 1000098000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT = 1000099000;
const VkStructureType STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT = 1000099001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT = 1000101000;
const VkStructureType STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT = 1000101001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT = 1000102000;
const VkStructureType STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT = 1000102001;
const VkStructureType STRUCTURE_TYPE_HDR_METADATA_EXT = 1000105000;
const VkStructureType STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR = 1000111000;
const VkStructureType STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114000;
const VkStructureType STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114001;
const VkStructureType STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR = 1000114002;
const VkStructureType STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR = 1000115000;
const VkStructureType STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR = 1000115001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR = 1000116000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR = 1000116001;
const VkStructureType STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR = 1000116002;
const VkStructureType STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR = 1000116003;
const VkStructureType STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR = 1000116004;
const VkStructureType STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR = 1000116005;
const VkStructureType STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR = 1000116006;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR = 1000119000;
const VkStructureType STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR = 1000119001;
const VkStructureType STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR = 1000119002;
const VkStructureType STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR = 1000121000;
const VkStructureType STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR = 1000121001;
const VkStructureType STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR = 1000121002;
const VkStructureType STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR = 1000121003;
const VkStructureType STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR = 1000121004;
const VkStructureType STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK = 1000122000;
const VkStructureType STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK = 1000123000;
const VkStructureType STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT = 1000128000;
const VkStructureType STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT = 1000128001;
const VkStructureType STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT = 1000128002;
const VkStructureType STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT = 1000128003;
const VkStructureType STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT = 1000128004;
const VkStructureType STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID = 1000129000;
const VkStructureType STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID = 1000129001;
const VkStructureType STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID = 1000129002;
const VkStructureType STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129003;
const VkStructureType STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129004;
const VkStructureType STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID = 1000129005;
const VkStructureType STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID = 1000129006;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT = 1000138000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT = 1000138001;
const VkStructureType STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT = 1000138002;
const VkStructureType STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT = 1000138003;
const VkStructureType STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT = 1000143000;
const VkStructureType STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT = 1000143001;
const VkStructureType STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT = 1000143002;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT = 1000143003;
const VkStructureType STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT = 1000143004;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT = 1000148000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT = 1000148001;
const VkStructureType STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT = 1000148002;
const VkStructureType STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV = 1000149000;
const VkStructureType STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR = 1000150007;
const VkStructureType STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR = 1000150000;
const VkStructureType STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR = 1000150002;
const VkStructureType STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR = 1000150003;
const VkStructureType STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR = 1000150004;
const VkStructureType STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR = 1000150005;
const VkStructureType STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR = 1000150006;
const VkStructureType STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR = 1000150009;
const VkStructureType STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR = 1000150010;
const VkStructureType STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR = 1000150011;
const VkStructureType STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR = 1000150012;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR = 1000150013;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR = 1000150014;
const VkStructureType STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR = 1000150017;
const VkStructureType STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR = 1000150020;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR = 1000347000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR = 1000347001;
const VkStructureType STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR = 1000150015;
const VkStructureType STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR = 1000150016;
const VkStructureType STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR = 1000150018;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR = 1000348013;
const VkStructureType STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV = 1000152000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV = 1000154000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV = 1000154001;
const VkStructureType STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT = 1000158000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT = 1000158002;
const VkStructureType STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT = 1000158003;
const VkStructureType STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT = 1000158004;
const VkStructureType STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT = 1000158005;
const VkStructureType STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT = 1000158006;
const VkStructureType STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160000;
const VkStructureType STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR = 1000163000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR = 1000163001;
const VkStructureType STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV = 1000164000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV = 1000164001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV = 1000164002;
const VkStructureType STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV = 1000164005;
const VkStructureType STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV = 1000165000;
const VkStructureType STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV = 1000165001;
const VkStructureType STRUCTURE_TYPE_GEOMETRY_NV = 1000165003;
const VkStructureType STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV = 1000165004;
const VkStructureType STRUCTURE_TYPE_GEOMETRY_AABB_NV = 1000165005;
const VkStructureType STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV = 1000165006;
const VkStructureType STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV = 1000165007;
const VkStructureType STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV = 1000165008;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV = 1000165009;
const VkStructureType STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV = 1000165011;
const VkStructureType STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV = 1000165012;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV = 1000166000;
const VkStructureType STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV = 1000166001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT = 1000170000;
const VkStructureType STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT = 1000170001;
const VkStructureType STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT = 1000174000;
const VkStructureType STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT = 1000178000;
const VkStructureType STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT = 1000178001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT = 1000178002;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR = 1000181000;
const VkStructureType STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD = 1000183000;
const VkStructureType STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT = 1000184000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD = 1000185000;
const VkStructureType STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_EXT = 1000187000;
const VkStructureType STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_CREATE_INFO_EXT = 1000187001;
const VkStructureType STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_EXT = 1000187002;
const VkStructureType STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_EXT = 1000187003;
const VkStructureType STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_EXT = 1000187004;
const VkStructureType STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_EXT = 1000187005;
const VkStructureType STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_EXT = 1000187006;
const VkStructureType STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD = 1000189000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT = 1000190000;
const VkStructureType STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT = 1000190001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT = 1000190002;
const VkStructureType STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP = 1000191000;
const VkStructureType STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT = 1000192000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV = 1000201000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV = 1000202000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV = 1000202001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV = 1000203000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV = 1000204000;
const VkStructureType STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV = 1000205000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV = 1000205002;
const VkStructureType STRUCTURE_TYPE_CHECKPOINT_DATA_NV = 1000206000;
const VkStructureType STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV = 1000206001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL = 1000209000;
const VkStructureType STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL = 1000210000;
const VkStructureType STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL = 1000210001;
const VkStructureType STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL = 1000210002;
const VkStructureType STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL = 1000210003;
const VkStructureType STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL = 1000210004;
const VkStructureType STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL = 1000210005;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT = 1000212000;
const VkStructureType STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD = 1000213000;
const VkStructureType STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD = 1000213001;
const VkStructureType STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA = 1000214000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR = 1000215000;
const VkStructureType STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT = 1000217000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT = 1000218000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT = 1000218001;
const VkStructureType STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT = 1000218002;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT = 1000225000;
const VkStructureType STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT = 1000225001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT = 1000225002;
const VkStructureType STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR = 1000226000;
const VkStructureType STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR = 1000226001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR = 1000226002;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR = 1000226003;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR = 1000226004;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD = 1000227000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD = 1000229000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT = 1000234000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT = 1000237000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT = 1000238000;
const VkStructureType STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT = 1000238001;
const VkStructureType STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR = 1000239000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV = 1000240000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT = 1000244000;
const VkStructureType STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT = 1000244002;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT = 1000245000;
const VkStructureType STRUCTURE_TYPE_VALIDATION_FEATURES_EXT = 1000247000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR = 1000248000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV = 1000249000;
const VkStructureType STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV = 1000249001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV = 1000249002;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV = 1000250000;
const VkStructureType STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV = 1000250001;
const VkStructureType STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV = 1000250002;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT = 1000251000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT = 1000252000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT = 1000254000;
const VkStructureType STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT = 1000254001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT = 1000254002;
const VkStructureType STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT = 1000255000;
const VkStructureType STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT = 1000255002;
const VkStructureType STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT = 1000255001;
const VkStructureType STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT = 1000256000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT = 1000259000;
const VkStructureType STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT = 1000259001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT = 1000259002;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT = 1000260000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT = 1000265000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT = 1000267000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR = 1000269000;
const VkStructureType STRUCTURE_TYPE_PIPELINE_INFO_KHR = 1000269001;
const VkStructureType STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR = 1000269002;
const VkStructureType STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR = 1000269003;
const VkStructureType STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR = 1000269004;
const VkStructureType STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR = 1000269005;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT = 1000273000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT = 1000276000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV = 1000277000;
const VkStructureType STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV = 1000277001;
const VkStructureType STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV = 1000277002;
const VkStructureType STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV = 1000277003;
const VkStructureType STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV = 1000277004;
const VkStructureType STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV = 1000277005;
const VkStructureType STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV = 1000277006;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV = 1000277007;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV = 1000278000;
const VkStructureType STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV = 1000278001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES_KHR = 1000280000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES_KHR = 1000280001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT = 1000281000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT = 1000281001;
const VkStructureType STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM = 1000282000;
const VkStructureType STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM = 1000282001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT = 1000284000;
const VkStructureType STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT = 1000284001;
const VkStructureType STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT = 1000284002;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT = 1000286000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT = 1000286001;
const VkStructureType STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT = 1000287000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT = 1000287001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT = 1000287002;
const VkStructureType STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR = 1000290000;
const VkStructureType STRUCTURE_TYPE_PRESENT_ID_KHR = 1000294000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR = 1000294001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT = 1000295000;
const VkStructureType STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT = 1000295001;
const VkStructureType STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO_EXT = 1000295002;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT = 1000297000;
const VkStructureType STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR = 1000299000;
const VkStructureType STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR = 1000299001;
const VkStructureType STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR = 1000299002;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV = 1000300000;
const VkStructureType STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV = 1000300001;
const VkStructureType STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR = 1000314000;
const VkStructureType STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR = 1000314001;
const VkStructureType STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2_KHR = 1000314002;
const VkStructureType STRUCTURE_TYPE_DEPENDENCY_INFO_KHR = 1000314003;
const VkStructureType STRUCTURE_TYPE_SUBMIT_INFO_2_KHR = 1000314004;
const VkStructureType STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR = 1000314005;
const VkStructureType STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO_KHR = 1000314006;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR = 1000314007;
const VkStructureType STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV = 1000314008;
const VkStructureType STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV = 1000314009;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR = 1000323000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR = 1000325000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV = 1000326000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV = 1000326001;
const VkStructureType STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV = 1000326002;
const VkStructureType STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV = 1000327000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV = 1000327001;
const VkStructureType STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV = 1000327002;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT = 1000330000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT = 1000332000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT = 1000332001;
const VkStructureType STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM = 1000333000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT = 1000335000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR = 1000336000;
const VkStructureType STRUCTURE_TYPE_COPY_BUFFER_INFO_2_KHR = 1000337000;
const VkStructureType STRUCTURE_TYPE_COPY_IMAGE_INFO_2_KHR = 1000337001;
const VkStructureType STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2_KHR = 1000337002;
const VkStructureType STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2_KHR = 1000337003;
const VkStructureType STRUCTURE_TYPE_BLIT_IMAGE_INFO_2_KHR = 1000337004;
const VkStructureType STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2_KHR = 1000337005;
const VkStructureType STRUCTURE_TYPE_BUFFER_COPY_2_KHR = 1000337006;
const VkStructureType STRUCTURE_TYPE_IMAGE_COPY_2_KHR = 1000337007;
const VkStructureType STRUCTURE_TYPE_IMAGE_BLIT_2_KHR = 1000337008;
const VkStructureType STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR = 1000337009;
const VkStructureType STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR = 1000337010;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT = 1000340000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_ARM = 1000342000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT = 1000344000;
const VkStructureType STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT = 1000346000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE = 1000351000;
const VkStructureType STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE = 1000351002;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT = 1000352000;
const VkStructureType STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT = 1000352001;
const VkStructureType STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT = 1000352002;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT = 1000353000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT = 1000355000;
const VkStructureType STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT = 1000355001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT = 1000356000;
const VkStructureType STRUCTURE_TYPE_FORMAT_PROPERTIES_3_KHR = 1000360000;
const VkStructureType STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA = 1000364000;
const VkStructureType STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA = 1000364001;
const VkStructureType STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA = 1000364002;
const VkStructureType STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA = 1000365000;
const VkStructureType STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA = 1000365001;
const VkStructureType STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA = 1000366000;
const VkStructureType STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA = 1000366001;
const VkStructureType STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA = 1000366002;
const VkStructureType STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA = 1000366003;
const VkStructureType STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA = 1000366004;
const VkStructureType STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA = 1000366005;
const VkStructureType STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA = 1000366006;
const VkStructureType STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA = 1000366007;
const VkStructureType STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA = 1000366008;
const VkStructureType STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA = 1000366009;
const VkStructureType STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI = 1000369000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI = 1000369001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI = 1000369002;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI = 1000370000;
const VkStructureType STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV = 1000371000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV = 1000371001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT = 1000377000;
const VkStructureType STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX = 1000378000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT = 1000381000;
const VkStructureType STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT = 1000381001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT = 1000388000;
const VkStructureType STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT = 1000388001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT = 1000391000;
const VkStructureType STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT = 1000391001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT = 1000392000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT = 1000392001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT = 1000411000;
const VkStructureType STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT = 1000411001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT = 1000412000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES_KHR = 1000413000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES_KHR = 1000413001;
const VkStructureType STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS_KHR = 1000413002;
const VkStructureType STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS_KHR = 1000413003;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM = 1000425000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM = 1000425001;
const VkStructureType STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM = 1000425002;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV = 1000430000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES = STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES = STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES;
const VkStructureType STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT = STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT;
const VkStructureType STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_NV = STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD;
const VkStructureType STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR = STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2;
const VkStructureType STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR = STRUCTURE_TYPE_FORMAT_PROPERTIES_2;
const VkStructureType STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR = STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2;
const VkStructureType STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR = STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2;
const VkStructureType STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR = STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2;
const VkStructureType STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR = STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO;
const VkStructureType STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR = STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO;
const VkStructureType STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR = STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO;
const VkStructureType STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR = STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO;
const VkStructureType STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR = STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO;
const VkStructureType STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR = STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO;
const VkStructureType STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR = STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES;
const VkStructureType STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR = STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO;
const VkStructureType STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR = STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO;
const VkStructureType STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR = STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES;
const VkStructureType STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR = STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO;
const VkStructureType STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR = STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO;
const VkStructureType STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR = STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO;
const VkStructureType STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR = STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES;
const VkStructureType STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR = STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES;
const VkStructureType STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR = STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO;
const VkStructureType STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT = STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES;
const VkStructureType STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR = STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO;
const VkStructureType STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR = STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO;
const VkStructureType STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR = STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO;
const VkStructureType STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR = STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2;
const VkStructureType STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR = STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2;
const VkStructureType STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR = STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2;
const VkStructureType STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR = STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2;
const VkStructureType STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR = STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2;
const VkStructureType STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR = STRUCTURE_TYPE_SUBPASS_BEGIN_INFO;
const VkStructureType STRUCTURE_TYPE_SUBPASS_END_INFO_KHR = STRUCTURE_TYPE_SUBPASS_END_INFO;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO;
const VkStructureType STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR = STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES;
const VkStructureType STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR = STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES;
const VkStructureType STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR = STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO;
const VkStructureType STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR = STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO;
const VkStructureType STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR = STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR;
const VkStructureType STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR = STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS;
const VkStructureType STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR = STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT = STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES;
const VkStructureType STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT = STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO;
const VkStructureType STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR = STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2;
const VkStructureType STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR = STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2;
const VkStructureType STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR = STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2;
const VkStructureType STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR = STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2;
const VkStructureType STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR = STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2;
const VkStructureType STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR = STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO;
const VkStructureType STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR = STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO;
const VkStructureType STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR = STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO;
const VkStructureType STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR = STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO;
const VkStructureType STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR = STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES;
const VkStructureType STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR = STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES;
const VkStructureType STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR = STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO;
const VkStructureType STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR = STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO;
const VkStructureType STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT = STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT = STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT = STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES;
const VkStructureType STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT = STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO;
const VkStructureType STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT = STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES;
const VkStructureType STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR = STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES;
const VkStructureType STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR = STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES;
const VkStructureType STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR = STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO;
const VkStructureType STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR = STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO;
const VkStructureType STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR = STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO;
const VkStructureType STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR = STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO;
const VkStructureType STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL = STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT = STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES;
const VkStructureType STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR = STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT;
const VkStructureType STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR = STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT = STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT;
const VkStructureType STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT = STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO;
const VkStructureType STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT = STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES;
const VkStructureType STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR = STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO;
const VkStructureType STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR = STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO;
const VkStructureType STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR = STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO;
const VkStructureType STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR = STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT = STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES;
const VkStructureType STRUCTURE_TYPE_MAX_ENUM = 0x7FFFFFFF;

typedef VkImageLayout = inline CUInt;
const VkImageLayout IMAGE_LAYOUT_UNDEFINED = 0;
const VkImageLayout IMAGE_LAYOUT_GENERAL = 1;
const VkImageLayout IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = 2;
const VkImageLayout IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3;
const VkImageLayout IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = 4;
const VkImageLayout IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = 5;
const VkImageLayout IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = 6;
const VkImageLayout IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = 7;
const VkImageLayout IMAGE_LAYOUT_PREINITIALIZED = 8;
const VkImageLayout IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL = 1000117000;
const VkImageLayout IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL = 1000117001;
const VkImageLayout IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL = 1000241000;
const VkImageLayout IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL = 1000241001;
const VkImageLayout IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL = 1000241002;
const VkImageLayout IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL = 1000241003;
const VkImageLayout IMAGE_LAYOUT_PRESENT_SRC_KHR = 1000001002;
const VkImageLayout IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR = 1000024000;
const VkImageLayout IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR = 1000024001;
const VkImageLayout IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR = 1000024002;
const VkImageLayout IMAGE_LAYOUT_SHARED_PRESENT_KHR = 1000111000;
const VkImageLayout IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT = 1000218000;
const VkImageLayout IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR = 1000164003;
const VkImageLayout IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR = 1000299000;
const VkImageLayout IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR = 1000299001;
const VkImageLayout IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR = 1000299002;
const VkImageLayout IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR = 1000314000;
const VkImageLayout IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR = 1000314001;
const VkImageLayout IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR = IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL;
const VkImageLayout IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR = IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL;
const VkImageLayout IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV = IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR;
const VkImageLayout IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR = IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL;
const VkImageLayout IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR = IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL;
const VkImageLayout IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR = IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL;
const VkImageLayout IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR = IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL;
const VkImageLayout IMAGE_LAYOUT_MAX_ENUM = 0x7FFFFFFF;

typedef VkObjectType = inline CUInt;
const VkObjectType OBJECT_TYPE_UNKNOWN = 0;
const VkObjectType OBJECT_TYPE_INSTANCE = 1;
const VkObjectType OBJECT_TYPE_PHYSICAL_DEVICE = 2;
const VkObjectType OBJECT_TYPE_DEVICE = 3;
const VkObjectType OBJECT_TYPE_QUEUE = 4;
const VkObjectType OBJECT_TYPE_SEMAPHORE = 5;
const VkObjectType OBJECT_TYPE_COMMAND_BUFFER = 6;
const VkObjectType OBJECT_TYPE_FENCE = 7;
const VkObjectType OBJECT_TYPE_DEVICE_MEMORY = 8;
const VkObjectType OBJECT_TYPE_BUFFER = 9;
const VkObjectType OBJECT_TYPE_IMAGE = 10;
const VkObjectType OBJECT_TYPE_EVENT = 11;
const VkObjectType OBJECT_TYPE_QUERY_POOL = 12;
const VkObjectType OBJECT_TYPE_BUFFER_VIEW = 13;
const VkObjectType OBJECT_TYPE_IMAGE_VIEW = 14;
const VkObjectType OBJECT_TYPE_SHADER_MODULE = 15;
const VkObjectType OBJECT_TYPE_PIPELINE_CACHE = 16;
const VkObjectType OBJECT_TYPE_PIPELINE_LAYOUT = 17;
const VkObjectType OBJECT_TYPE_RENDER_PASS = 18;
const VkObjectType OBJECT_TYPE_PIPELINE = 19;
const VkObjectType OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT = 20;
const VkObjectType OBJECT_TYPE_SAMPLER = 21;
const VkObjectType OBJECT_TYPE_DESCRIPTOR_POOL = 22;
const VkObjectType OBJECT_TYPE_DESCRIPTOR_SET = 23;
const VkObjectType OBJECT_TYPE_FRAMEBUFFER = 24;
const VkObjectType OBJECT_TYPE_COMMAND_POOL = 25;
const VkObjectType OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION = 1000156000;
const VkObjectType OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE = 1000085000;
const VkObjectType OBJECT_TYPE_SURFACE_KHR = 1000000000;
const VkObjectType OBJECT_TYPE_SWAPCHAIN_KHR = 1000001000;
const VkObjectType OBJECT_TYPE_DISPLAY_KHR = 1000002000;
const VkObjectType OBJECT_TYPE_DISPLAY_MODE_KHR = 1000002001;
const VkObjectType OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT = 1000011000;
const VkObjectType OBJECT_TYPE_VIDEO_SESSION_KHR = 1000023000;
const VkObjectType OBJECT_TYPE_VIDEO_SESSION_PARAMETERS_KHR = 1000023001;
const VkObjectType OBJECT_TYPE_CU_MODULE_NVX = 1000029000;
const VkObjectType OBJECT_TYPE_CU_FUNCTION_NVX = 1000029001;
const VkObjectType OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT = 1000128000;
const VkObjectType OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR = 1000150000;
const VkObjectType OBJECT_TYPE_VALIDATION_CACHE_EXT = 1000160000;
const VkObjectType OBJECT_TYPE_ACCELERATION_STRUCTURE_NV = 1000165000;
const VkObjectType OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL = 1000210000;
const VkObjectType OBJECT_TYPE_DEFERRED_OPERATION_KHR = 1000268000;
const VkObjectType OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV = 1000277000;
const VkObjectType OBJECT_TYPE_PRIVATE_DATA_SLOT_EXT = 1000295000;
const VkObjectType OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA = 1000366000;
const VkObjectType OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR = OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE;
const VkObjectType OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR = OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION;
const VkObjectType OBJECT_TYPE_MAX_ENUM = 0x7FFFFFFF;

typedef VkPipelineCacheHeaderVersion = inline CUInt;
const VkPipelineCacheHeaderVersion PIPELINE_CACHE_HEADER_VERSION_ONE = 1;
const VkPipelineCacheHeaderVersion PIPELINE_CACHE_HEADER_VERSION_MAX_ENUM = 0x7FFFFFFF;

typedef VkVendorId = inline CUInt;
const VkVendorId VENDOR_ID_VIV = 0x10001;
const VkVendorId VENDOR_ID_VSI = 0x10002;
const VkVendorId VENDOR_ID_KAZAN = 0x10003;
const VkVendorId VENDOR_ID_CODEPLAY = 0x10004;
const VkVendorId VENDOR_ID_MESA = 0x10005;
const VkVendorId VENDOR_ID_POCL = 0x10006;
const VkVendorId VENDOR_ID_MAX_ENUM = 0x7FFFFFFF;

typedef VkSystemAllocationScope = inline CUInt;
const VkSystemAllocationScope SYSTEM_ALLOCATION_SCOPE_COMMAND = 0;
const VkSystemAllocationScope SYSTEM_ALLOCATION_SCOPE_OBJECT = 1;
const VkSystemAllocationScope SYSTEM_ALLOCATION_SCOPE_CACHE = 2;
const VkSystemAllocationScope SYSTEM_ALLOCATION_SCOPE_DEVICE = 3;
const VkSystemAllocationScope SYSTEM_ALLOCATION_SCOPE_INSTANCE = 4;
const VkSystemAllocationScope SYSTEM_ALLOCATION_SCOPE_MAX_ENUM = 0x7FFFFFFF;

typedef VkInternalAllocationType = inline CUInt;
const VkInternalAllocationType INTERNAL_ALLOCATION_TYPE_EXECUTABLE = 0;
const VkInternalAllocationType INTERNAL_ALLOCATION_TYPE_MAX_ENUM = 0x7FFFFFFF;

typedef VkFormat = inline CUInt;
const VkFormat FORMAT_UNDEFINED = 0;
const VkFormat FORMAT_R4G4_UNORM_PACK8 = 1;
const VkFormat FORMAT_R4G4B4A4_UNORM_PACK16 = 2;
const VkFormat FORMAT_B4G4R4A4_UNORM_PACK16 = 3;
const VkFormat FORMAT_R5G6B5_UNORM_PACK16 = 4;
const VkFormat FORMAT_B5G6R5_UNORM_PACK16 = 5;
const VkFormat FORMAT_R5G5B5A1_UNORM_PACK16 = 6;
const VkFormat FORMAT_B5G5R5A1_UNORM_PACK16 = 7;
const VkFormat FORMAT_A1R5G5B5_UNORM_PACK16 = 8;
const VkFormat FORMAT_R8_UNORM = 9;
const VkFormat FORMAT_R8_SNORM = 10;
const VkFormat FORMAT_R8_USCALED = 11;
const VkFormat FORMAT_R8_SSCALED = 12;
const VkFormat FORMAT_R8_UINT = 13;
const VkFormat FORMAT_R8_SINT = 14;
const VkFormat FORMAT_R8_SRGB = 15;
const VkFormat FORMAT_R8G8_UNORM = 16;
const VkFormat FORMAT_R8G8_SNORM = 17;
const VkFormat FORMAT_R8G8_USCALED = 18;
const VkFormat FORMAT_R8G8_SSCALED = 19;
const VkFormat FORMAT_R8G8_UINT = 20;
const VkFormat FORMAT_R8G8_SINT = 21;
const VkFormat FORMAT_R8G8_SRGB = 22;
const VkFormat FORMAT_R8G8B8_UNORM = 23;
const VkFormat FORMAT_R8G8B8_SNORM = 24;
const VkFormat FORMAT_R8G8B8_USCALED = 25;
const VkFormat FORMAT_R8G8B8_SSCALED = 26;
const VkFormat FORMAT_R8G8B8_UINT = 27;
const VkFormat FORMAT_R8G8B8_SINT = 28;
const VkFormat FORMAT_R8G8B8_SRGB = 29;
const VkFormat FORMAT_B8G8R8_UNORM = 30;
const VkFormat FORMAT_B8G8R8_SNORM = 31;
const VkFormat FORMAT_B8G8R8_USCALED = 32;
const VkFormat FORMAT_B8G8R8_SSCALED = 33;
const VkFormat FORMAT_B8G8R8_UINT = 34;
const VkFormat FORMAT_B8G8R8_SINT = 35;
const VkFormat FORMAT_B8G8R8_SRGB = 36;
const VkFormat FORMAT_R8G8B8A8_UNORM = 37;
const VkFormat FORMAT_R8G8B8A8_SNORM = 38;
const VkFormat FORMAT_R8G8B8A8_USCALED = 39;
const VkFormat FORMAT_R8G8B8A8_SSCALED = 40;
const VkFormat FORMAT_R8G8B8A8_UINT = 41;
const VkFormat FORMAT_R8G8B8A8_SINT = 42;
const VkFormat FORMAT_R8G8B8A8_SRGB = 43;
const VkFormat FORMAT_B8G8R8A8_UNORM = 44;
const VkFormat FORMAT_B8G8R8A8_SNORM = 45;
const VkFormat FORMAT_B8G8R8A8_USCALED = 46;
const VkFormat FORMAT_B8G8R8A8_SSCALED = 47;
const VkFormat FORMAT_B8G8R8A8_UINT = 48;
const VkFormat FORMAT_B8G8R8A8_SINT = 49;
const VkFormat FORMAT_B8G8R8A8_SRGB = 50;
const VkFormat FORMAT_A8B8G8R8_UNORM_PACK32 = 51;
const VkFormat FORMAT_A8B8G8R8_SNORM_PACK32 = 52;
const VkFormat FORMAT_A8B8G8R8_USCALED_PACK32 = 53;
const VkFormat FORMAT_A8B8G8R8_SSCALED_PACK32 = 54;
const VkFormat FORMAT_A8B8G8R8_UINT_PACK32 = 55;
const VkFormat FORMAT_A8B8G8R8_SINT_PACK32 = 56;
const VkFormat FORMAT_A8B8G8R8_SRGB_PACK32 = 57;
const VkFormat FORMAT_A2R10G10B10_UNORM_PACK32 = 58;
const VkFormat FORMAT_A2R10G10B10_SNORM_PACK32 = 59;
const VkFormat FORMAT_A2R10G10B10_USCALED_PACK32 = 60;
const VkFormat FORMAT_A2R10G10B10_SSCALED_PACK32 = 61;
const VkFormat FORMAT_A2R10G10B10_UINT_PACK32 = 62;
const VkFormat FORMAT_A2R10G10B10_SINT_PACK32 = 63;
const VkFormat FORMAT_A2B10G10R10_UNORM_PACK32 = 64;
const VkFormat FORMAT_A2B10G10R10_SNORM_PACK32 = 65;
const VkFormat FORMAT_A2B10G10R10_USCALED_PACK32 = 66;
const VkFormat FORMAT_A2B10G10R10_SSCALED_PACK32 = 67;
const VkFormat FORMAT_A2B10G10R10_UINT_PACK32 = 68;
const VkFormat FORMAT_A2B10G10R10_SINT_PACK32 = 69;
const VkFormat FORMAT_R16_UNORM = 70;
const VkFormat FORMAT_R16_SNORM = 71;
const VkFormat FORMAT_R16_USCALED = 72;
const VkFormat FORMAT_R16_SSCALED = 73;
const VkFormat FORMAT_R16_UINT = 74;
const VkFormat FORMAT_R16_SINT = 75;
const VkFormat FORMAT_R16_SFLOAT = 76;
const VkFormat FORMAT_R16G16_UNORM = 77;
const VkFormat FORMAT_R16G16_SNORM = 78;
const VkFormat FORMAT_R16G16_USCALED = 79;
const VkFormat FORMAT_R16G16_SSCALED = 80;
const VkFormat FORMAT_R16G16_UINT = 81;
const VkFormat FORMAT_R16G16_SINT = 82;
const VkFormat FORMAT_R16G16_SFLOAT = 83;
const VkFormat FORMAT_R16G16B16_UNORM = 84;
const VkFormat FORMAT_R16G16B16_SNORM = 85;
const VkFormat FORMAT_R16G16B16_USCALED = 86;
const VkFormat FORMAT_R16G16B16_SSCALED = 87;
const VkFormat FORMAT_R16G16B16_UINT = 88;
const VkFormat FORMAT_R16G16B16_SINT = 89;
const VkFormat FORMAT_R16G16B16_SFLOAT = 90;
const VkFormat FORMAT_R16G16B16A16_UNORM = 91;
const VkFormat FORMAT_R16G16B16A16_SNORM = 92;
const VkFormat FORMAT_R16G16B16A16_USCALED = 93;
const VkFormat FORMAT_R16G16B16A16_SSCALED = 94;
const VkFormat FORMAT_R16G16B16A16_UINT = 95;
const VkFormat FORMAT_R16G16B16A16_SINT = 96;
const VkFormat FORMAT_R16G16B16A16_SFLOAT = 97;
const VkFormat FORMAT_R32_UINT = 98;
const VkFormat FORMAT_R32_SINT = 99;
const VkFormat FORMAT_R32_SFLOAT = 100;
const VkFormat FORMAT_R32G32_UINT = 101;
const VkFormat FORMAT_R32G32_SINT = 102;
const VkFormat FORMAT_R32G32_SFLOAT = 103;
const VkFormat FORMAT_R32G32B32_UINT = 104;
const VkFormat FORMAT_R32G32B32_SINT = 105;
const VkFormat FORMAT_R32G32B32_SFLOAT = 106;
const VkFormat FORMAT_R32G32B32A32_UINT = 107;
const VkFormat FORMAT_R32G32B32A32_SINT = 108;
const VkFormat FORMAT_R32G32B32A32_SFLOAT = 109;
const VkFormat FORMAT_R64_UINT = 110;
const VkFormat FORMAT_R64_SINT = 111;
const VkFormat FORMAT_R64_SFLOAT = 112;
const VkFormat FORMAT_R64G64_UINT = 113;
const VkFormat FORMAT_R64G64_SINT = 114;
const VkFormat FORMAT_R64G64_SFLOAT = 115;
const VkFormat FORMAT_R64G64B64_UINT = 116;
const VkFormat FORMAT_R64G64B64_SINT = 117;
const VkFormat FORMAT_R64G64B64_SFLOAT = 118;
const VkFormat FORMAT_R64G64B64A64_UINT = 119;
const VkFormat FORMAT_R64G64B64A64_SINT = 120;
const VkFormat FORMAT_R64G64B64A64_SFLOAT = 121;
const VkFormat FORMAT_B10G11R11_UFLOAT_PACK32 = 122;
const VkFormat FORMAT_E5B9G9R9_UFLOAT_PACK32 = 123;
const VkFormat FORMAT_D16_UNORM = 124;
const VkFormat FORMAT_X8_D24_UNORM_PACK32 = 125;
const VkFormat FORMAT_D32_SFLOAT = 126;
const VkFormat FORMAT_S8_UINT = 127;
const VkFormat FORMAT_D16_UNORM_S8_UINT = 128;
const VkFormat FORMAT_D24_UNORM_S8_UINT = 129;
const VkFormat FORMAT_D32_SFLOAT_S8_UINT = 130;
const VkFormat FORMAT_BC1_RGB_UNORM_BLOCK = 131;
const VkFormat FORMAT_BC1_RGB_SRGB_BLOCK = 132;
const VkFormat FORMAT_BC1_RGBA_UNORM_BLOCK = 133;
const VkFormat FORMAT_BC1_RGBA_SRGB_BLOCK = 134;
const VkFormat FORMAT_BC2_UNORM_BLOCK = 135;
const VkFormat FORMAT_BC2_SRGB_BLOCK = 136;
const VkFormat FORMAT_BC3_UNORM_BLOCK = 137;
const VkFormat FORMAT_BC3_SRGB_BLOCK = 138;
const VkFormat FORMAT_BC4_UNORM_BLOCK = 139;
const VkFormat FORMAT_BC4_SNORM_BLOCK = 140;
const VkFormat FORMAT_BC5_UNORM_BLOCK = 141;
const VkFormat FORMAT_BC5_SNORM_BLOCK = 142;
const VkFormat FORMAT_BC6H_UFLOAT_BLOCK = 143;
const VkFormat FORMAT_BC6H_SFLOAT_BLOCK = 144;
const VkFormat FORMAT_BC7_UNORM_BLOCK = 145;
const VkFormat FORMAT_BC7_SRGB_BLOCK = 146;
const VkFormat FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 147;
const VkFormat FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 148;
const VkFormat FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 149;
const VkFormat FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 150;
const VkFormat FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 151;
const VkFormat FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 152;
const VkFormat FORMAT_EAC_R11_UNORM_BLOCK = 153;
const VkFormat FORMAT_EAC_R11_SNORM_BLOCK = 154;
const VkFormat FORMAT_EAC_R11G11_UNORM_BLOCK = 155;
const VkFormat FORMAT_EAC_R11G11_SNORM_BLOCK = 156;
const VkFormat FORMAT_ASTC_4X4_UNORM_BLOCK = 157;
const VkFormat FORMAT_ASTC_4X4_SRGB_BLOCK = 158;
const VkFormat FORMAT_ASTC_5X4_UNORM_BLOCK = 159;
const VkFormat FORMAT_ASTC_5X4_SRGB_BLOCK = 160;
const VkFormat FORMAT_ASTC_5X5_UNORM_BLOCK = 161;
const VkFormat FORMAT_ASTC_5X5_SRGB_BLOCK = 162;
const VkFormat FORMAT_ASTC_6X5_UNORM_BLOCK = 163;
const VkFormat FORMAT_ASTC_6X5_SRGB_BLOCK = 164;
const VkFormat FORMAT_ASTC_6X6_UNORM_BLOCK = 165;
const VkFormat FORMAT_ASTC_6X6_SRGB_BLOCK = 166;
const VkFormat FORMAT_ASTC_8X5_UNORM_BLOCK = 167;
const VkFormat FORMAT_ASTC_8X5_SRGB_BLOCK = 168;
const VkFormat FORMAT_ASTC_8X6_UNORM_BLOCK = 169;
const VkFormat FORMAT_ASTC_8X6_SRGB_BLOCK = 170;
const VkFormat FORMAT_ASTC_8X8_UNORM_BLOCK = 171;
const VkFormat FORMAT_ASTC_8X8_SRGB_BLOCK = 172;
const VkFormat FORMAT_ASTC_10X5_UNORM_BLOCK = 173;
const VkFormat FORMAT_ASTC_10X5_SRGB_BLOCK = 174;
const VkFormat FORMAT_ASTC_10X6_UNORM_BLOCK = 175;
const VkFormat FORMAT_ASTC_10X6_SRGB_BLOCK = 176;
const VkFormat FORMAT_ASTC_10X8_UNORM_BLOCK = 177;
const VkFormat FORMAT_ASTC_10X8_SRGB_BLOCK = 178;
const VkFormat FORMAT_ASTC_10X10_UNORM_BLOCK = 179;
const VkFormat FORMAT_ASTC_10X10_SRGB_BLOCK = 180;
const VkFormat FORMAT_ASTC_12X10_UNORM_BLOCK = 181;
const VkFormat FORMAT_ASTC_12X10_SRGB_BLOCK = 182;
const VkFormat FORMAT_ASTC_12X12_UNORM_BLOCK = 183;
const VkFormat FORMAT_ASTC_12X12_SRGB_BLOCK = 184;
const VkFormat FORMAT_G8B8G8R8_422_UNORM = 1000156000;
const VkFormat FORMAT_B8G8R8G8_422_UNORM = 1000156001;
const VkFormat FORMAT_G8_B8_R8_3PLANE_420_UNORM = 1000156002;
const VkFormat FORMAT_G8_B8R8_2PLANE_420_UNORM = 1000156003;
const VkFormat FORMAT_G8_B8_R8_3PLANE_422_UNORM = 1000156004;
const VkFormat FORMAT_G8_B8R8_2PLANE_422_UNORM = 1000156005;
const VkFormat FORMAT_G8_B8_R8_3PLANE_444_UNORM = 1000156006;
const VkFormat FORMAT_R10X6_UNORM_PACK16 = 1000156007;
const VkFormat FORMAT_R10X6G10X6_UNORM_2PACK16 = 1000156008;
const VkFormat FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 = 1000156009;
const VkFormat FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 = 1000156010;
const VkFormat FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 = 1000156011;
const VkFormat FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 = 1000156012;
const VkFormat FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 = 1000156013;
const VkFormat FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 = 1000156014;
const VkFormat FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 = 1000156015;
const VkFormat FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 = 1000156016;
const VkFormat FORMAT_R12X4_UNORM_PACK16 = 1000156017;
const VkFormat FORMAT_R12X4G12X4_UNORM_2PACK16 = 1000156018;
const VkFormat FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16 = 1000156019;
const VkFormat FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 = 1000156020;
const VkFormat FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 = 1000156021;
const VkFormat FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 = 1000156022;
const VkFormat FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 = 1000156023;
const VkFormat FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 = 1000156024;
const VkFormat FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 = 1000156025;
const VkFormat FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 = 1000156026;
const VkFormat FORMAT_G16B16G16R16_422_UNORM = 1000156027;
const VkFormat FORMAT_B16G16R16G16_422_UNORM = 1000156028;
const VkFormat FORMAT_G16_B16_R16_3PLANE_420_UNORM = 1000156029;
const VkFormat FORMAT_G16_B16R16_2PLANE_420_UNORM = 1000156030;
const VkFormat FORMAT_G16_B16_R16_3PLANE_422_UNORM = 1000156031;
const VkFormat FORMAT_G16_B16R16_2PLANE_422_UNORM = 1000156032;
const VkFormat FORMAT_G16_B16_R16_3PLANE_444_UNORM = 1000156033;
const VkFormat FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG = 1000054000;
const VkFormat FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG = 1000054001;
const VkFormat FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG = 1000054002;
const VkFormat FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG = 1000054003;
const VkFormat FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG = 1000054004;
const VkFormat FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG = 1000054005;
const VkFormat FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG = 1000054006;
const VkFormat FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG = 1000054007;
const VkFormat FORMAT_ASTC_4X4_SFLOAT_BLOCK_EXT = 1000066000;
const VkFormat FORMAT_ASTC_5X4_SFLOAT_BLOCK_EXT = 1000066001;
const VkFormat FORMAT_ASTC_5X5_SFLOAT_BLOCK_EXT = 1000066002;
const VkFormat FORMAT_ASTC_6X5_SFLOAT_BLOCK_EXT = 1000066003;
const VkFormat FORMAT_ASTC_6X6_SFLOAT_BLOCK_EXT = 1000066004;
const VkFormat FORMAT_ASTC_8X5_SFLOAT_BLOCK_EXT = 1000066005;
const VkFormat FORMAT_ASTC_8X6_SFLOAT_BLOCK_EXT = 1000066006;
const VkFormat FORMAT_ASTC_8X8_SFLOAT_BLOCK_EXT = 1000066007;
const VkFormat FORMAT_ASTC_10X5_SFLOAT_BLOCK_EXT = 1000066008;
const VkFormat FORMAT_ASTC_10X6_SFLOAT_BLOCK_EXT = 1000066009;
const VkFormat FORMAT_ASTC_10X8_SFLOAT_BLOCK_EXT = 1000066010;
const VkFormat FORMAT_ASTC_10X10_SFLOAT_BLOCK_EXT = 1000066011;
const VkFormat FORMAT_ASTC_12X10_SFLOAT_BLOCK_EXT = 1000066012;
const VkFormat FORMAT_ASTC_12X12_SFLOAT_BLOCK_EXT = 1000066013;
const VkFormat FORMAT_G8_B8R8_2PLANE_444_UNORM_EXT = 1000330000;
const VkFormat FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT = 1000330001;
const VkFormat FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT = 1000330002;
const VkFormat FORMAT_G16_B16R16_2PLANE_444_UNORM_EXT = 1000330003;
const VkFormat FORMAT_A4R4G4B4_UNORM_PACK16_EXT = 1000340000;
const VkFormat FORMAT_A4B4G4R4_UNORM_PACK16_EXT = 1000340001;
const VkFormat FORMAT_G8B8G8R8_422_UNORM_KHR = FORMAT_G8B8G8R8_422_UNORM;
const VkFormat FORMAT_B8G8R8G8_422_UNORM_KHR = FORMAT_B8G8R8G8_422_UNORM;
const VkFormat FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR = FORMAT_G8_B8_R8_3PLANE_420_UNORM;
const VkFormat FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR = FORMAT_G8_B8R8_2PLANE_420_UNORM;
const VkFormat FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR = FORMAT_G8_B8_R8_3PLANE_422_UNORM;
const VkFormat FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR = FORMAT_G8_B8R8_2PLANE_422_UNORM;
const VkFormat FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR = FORMAT_G8_B8_R8_3PLANE_444_UNORM;
const VkFormat FORMAT_R10X6_UNORM_PACK16_KHR = FORMAT_R10X6_UNORM_PACK16;
const VkFormat FORMAT_R10X6G10X6_UNORM_2PACK16_KHR = FORMAT_R10X6G10X6_UNORM_2PACK16;
const VkFormat FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR = FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16;
const VkFormat FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR = FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16;
const VkFormat FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR = FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16;
const VkFormat FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR = FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16;
const VkFormat FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR = FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16;
const VkFormat FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR = FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16;
const VkFormat FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR = FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16;
const VkFormat FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR = FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16;
const VkFormat FORMAT_R12X4_UNORM_PACK16_KHR = FORMAT_R12X4_UNORM_PACK16;
const VkFormat FORMAT_R12X4G12X4_UNORM_2PACK16_KHR = FORMAT_R12X4G12X4_UNORM_2PACK16;
const VkFormat FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR = FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16;
const VkFormat FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR = FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16;
const VkFormat FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR = FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16;
const VkFormat FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR = FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16;
const VkFormat FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR = FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16;
const VkFormat FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR = FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16;
const VkFormat FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR = FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16;
const VkFormat FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR = FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16;
const VkFormat FORMAT_G16B16G16R16_422_UNORM_KHR = FORMAT_G16B16G16R16_422_UNORM;
const VkFormat FORMAT_B16G16R16G16_422_UNORM_KHR = FORMAT_B16G16R16G16_422_UNORM;
const VkFormat FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR = FORMAT_G16_B16_R16_3PLANE_420_UNORM;
const VkFormat FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR = FORMAT_G16_B16R16_2PLANE_420_UNORM;
const VkFormat FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR = FORMAT_G16_B16_R16_3PLANE_422_UNORM;
const VkFormat FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR = FORMAT_G16_B16R16_2PLANE_422_UNORM;
const VkFormat FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR = FORMAT_G16_B16_R16_3PLANE_444_UNORM;
const VkFormat FORMAT_MAX_ENUM = 0x7FFFFFFF;

typedef VkImageTiling = inline CUInt;
const VkImageTiling IMAGE_TILING_OPTIMAL = 0;
const VkImageTiling IMAGE_TILING_LINEAR = 1;
const VkImageTiling IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT = 1000158000;
const VkImageTiling IMAGE_TILING_MAX_ENUM = 0x7FFFFFFF;

typedef VkImageType = inline CUInt;
const VkImageType IMAGE_TYPE_1D = 0;
const VkImageType IMAGE_TYPE_2D = 1;
const VkImageType IMAGE_TYPE_3D = 2;
const VkImageType IMAGE_TYPE_MAX_ENUM = 0x7FFFFFFF;

typedef VkPhysicalDeviceType = inline CUInt;
const VkPhysicalDeviceType PHYSICAL_DEVICE_TYPE_OTHER = 0;
const VkPhysicalDeviceType PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 1;
const VkPhysicalDeviceType PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = 2;
const VkPhysicalDeviceType PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = 3;
const VkPhysicalDeviceType PHYSICAL_DEVICE_TYPE_CPU = 4;
const VkPhysicalDeviceType PHYSICAL_DEVICE_TYPE_MAX_ENUM = 0x7FFFFFFF;

typedef VkQueryType = inline CUInt;
const VkQueryType QUERY_TYPE_OCCLUSION = 0;
const VkQueryType QUERY_TYPE_PIPELINE_STATISTICS = 1;
const VkQueryType QUERY_TYPE_TIMESTAMP = 2;
const VkQueryType QUERY_TYPE_RESULT_STATUS_ONLY_KHR = 1000023000;
const VkQueryType QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT = 1000028004;
const VkQueryType QUERY_TYPE_PERFORMANCE_QUERY_KHR = 1000116000;
const VkQueryType QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR = 1000150000;
const VkQueryType QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR = 1000150001;
const VkQueryType QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV = 1000165000;
const VkQueryType QUERY_TYPE_PERFORMANCE_QUERY_INTEL = 1000210000;
const VkQueryType QUERY_TYPE_VIDEO_ENCODE_BITSTREAM_BUFFER_RANGE_KHR = 1000299000;
const VkQueryType QUERY_TYPE_MAX_ENUM = 0x7FFFFFFF;

typedef VkSharingMode = inline CUInt;
const VkSharingMode SHARING_MODE_EXCLUSIVE = 0;
const VkSharingMode SHARING_MODE_CONCURRENT = 1;
const VkSharingMode SHARING_MODE_MAX_ENUM = 0x7FFFFFFF;

typedef VkComponentSwizzle = inline CUInt;
const VkComponentSwizzle COMPONENT_SWIZZLE_IDENTITY = 0;
const VkComponentSwizzle COMPONENT_SWIZZLE_ZERO = 1;
const VkComponentSwizzle COMPONENT_SWIZZLE_ONE = 2;
const VkComponentSwizzle COMPONENT_SWIZZLE_R = 3;
const VkComponentSwizzle COMPONENT_SWIZZLE_G = 4;
const VkComponentSwizzle COMPONENT_SWIZZLE_B = 5;
const VkComponentSwizzle COMPONENT_SWIZZLE_A = 6;
const VkComponentSwizzle COMPONENT_SWIZZLE_MAX_ENUM = 0x7FFFFFFF;

typedef VkImageViewType = inline CUInt;
const VkImageViewType IMAGE_VIEW_TYPE_1D = 0;
const VkImageViewType IMAGE_VIEW_TYPE_2D = 1;
const VkImageViewType IMAGE_VIEW_TYPE_3D = 2;
const VkImageViewType IMAGE_VIEW_TYPE_CUBE = 3;
const VkImageViewType IMAGE_VIEW_TYPE_1D_ARRAY = 4;
const VkImageViewType IMAGE_VIEW_TYPE_2D_ARRAY = 5;
const VkImageViewType IMAGE_VIEW_TYPE_CUBE_ARRAY = 6;
const VkImageViewType IMAGE_VIEW_TYPE_MAX_ENUM = 0x7FFFFFFF;

typedef VkBlendFactor = inline CUInt;
const VkBlendFactor BLEND_FACTOR_ZERO = 0;
const VkBlendFactor BLEND_FACTOR_ONE = 1;
const VkBlendFactor BLEND_FACTOR_SRC_COLOR = 2;
const VkBlendFactor BLEND_FACTOR_ONE_MINUS_SRC_COLOR = 3;
const VkBlendFactor BLEND_FACTOR_DST_COLOR = 4;
const VkBlendFactor BLEND_FACTOR_ONE_MINUS_DST_COLOR = 5;
const VkBlendFactor BLEND_FACTOR_SRC_ALPHA = 6;
const VkBlendFactor BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = 7;
const VkBlendFactor BLEND_FACTOR_DST_ALPHA = 8;
const VkBlendFactor BLEND_FACTOR_ONE_MINUS_DST_ALPHA = 9;
const VkBlendFactor BLEND_FACTOR_CONSTANT_COLOR = 10;
const VkBlendFactor BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = 11;
const VkBlendFactor BLEND_FACTOR_CONSTANT_ALPHA = 12;
const VkBlendFactor BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = 13;
const VkBlendFactor BLEND_FACTOR_SRC_ALPHA_SATURATE = 14;
const VkBlendFactor BLEND_FACTOR_SRC1_COLOR = 15;
const VkBlendFactor BLEND_FACTOR_ONE_MINUS_SRC1_COLOR = 16;
const VkBlendFactor BLEND_FACTOR_SRC1_ALPHA = 17;
const VkBlendFactor BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA = 18;
const VkBlendFactor BLEND_FACTOR_MAX_ENUM = 0x7FFFFFFF;

typedef VkBlendOp = inline CUInt;
const VkBlendOp BLEND_OP_ADD = 0;
const VkBlendOp BLEND_OP_SUBTRACT = 1;
const VkBlendOp BLEND_OP_REVERSE_SUBTRACT = 2;
const VkBlendOp BLEND_OP_MIN = 3;
const VkBlendOp BLEND_OP_MAX = 4;
const VkBlendOp BLEND_OP_ZERO_EXT = 1000148000;
const VkBlendOp BLEND_OP_SRC_EXT = 1000148001;
const VkBlendOp BLEND_OP_DST_EXT = 1000148002;
const VkBlendOp BLEND_OP_SRC_OVER_EXT = 1000148003;
const VkBlendOp BLEND_OP_DST_OVER_EXT = 1000148004;
const VkBlendOp BLEND_OP_SRC_IN_EXT = 1000148005;
const VkBlendOp BLEND_OP_DST_IN_EXT = 1000148006;
const VkBlendOp BLEND_OP_SRC_OUT_EXT = 1000148007;
const VkBlendOp BLEND_OP_DST_OUT_EXT = 1000148008;
const VkBlendOp BLEND_OP_SRC_ATOP_EXT = 1000148009;
const VkBlendOp BLEND_OP_DST_ATOP_EXT = 1000148010;
const VkBlendOp BLEND_OP_XOR_EXT = 1000148011;
const VkBlendOp BLEND_OP_MULTIPLY_EXT = 1000148012;
const VkBlendOp BLEND_OP_SCREEN_EXT = 1000148013;
const VkBlendOp BLEND_OP_OVERLAY_EXT = 1000148014;
const VkBlendOp BLEND_OP_DARKEN_EXT = 1000148015;
const VkBlendOp BLEND_OP_LIGHTEN_EXT = 1000148016;
const VkBlendOp BLEND_OP_COLORDODGE_EXT = 1000148017;
const VkBlendOp BLEND_OP_COLORBURN_EXT = 1000148018;
const VkBlendOp BLEND_OP_HARDLIGHT_EXT = 1000148019;
const VkBlendOp BLEND_OP_SOFTLIGHT_EXT = 1000148020;
const VkBlendOp BLEND_OP_DIFFERENCE_EXT = 1000148021;
const VkBlendOp BLEND_OP_EXCLUSION_EXT = 1000148022;
const VkBlendOp BLEND_OP_INVERT_EXT = 1000148023;
const VkBlendOp BLEND_OP_INVERT_RGB_EXT = 1000148024;
const VkBlendOp BLEND_OP_LINEARDODGE_EXT = 1000148025;
const VkBlendOp BLEND_OP_LINEARBURN_EXT = 1000148026;
const VkBlendOp BLEND_OP_VIVIDLIGHT_EXT = 1000148027;
const VkBlendOp BLEND_OP_LINEARLIGHT_EXT = 1000148028;
const VkBlendOp BLEND_OP_PINLIGHT_EXT = 1000148029;
const VkBlendOp BLEND_OP_HARDMIX_EXT = 1000148030;
const VkBlendOp BLEND_OP_HSL_HUE_EXT = 1000148031;
const VkBlendOp BLEND_OP_HSL_SATURATION_EXT = 1000148032;
const VkBlendOp BLEND_OP_HSL_COLOR_EXT = 1000148033;
const VkBlendOp BLEND_OP_HSL_LUMINOSITY_EXT = 1000148034;
const VkBlendOp BLEND_OP_PLUS_EXT = 1000148035;
const VkBlendOp BLEND_OP_PLUS_CLAMPED_EXT = 1000148036;
const VkBlendOp BLEND_OP_PLUS_CLAMPED_ALPHA_EXT = 1000148037;
const VkBlendOp BLEND_OP_PLUS_DARKER_EXT = 1000148038;
const VkBlendOp BLEND_OP_MINUS_EXT = 1000148039;
const VkBlendOp BLEND_OP_MINUS_CLAMPED_EXT = 1000148040;
const VkBlendOp BLEND_OP_CONTRAST_EXT = 1000148041;
const VkBlendOp BLEND_OP_INVERT_OVG_EXT = 1000148042;
const VkBlendOp BLEND_OP_RED_EXT = 1000148043;
const VkBlendOp BLEND_OP_GREEN_EXT = 1000148044;
const VkBlendOp BLEND_OP_BLUE_EXT = 1000148045;
const VkBlendOp BLEND_OP_MAX_ENUM = 0x7FFFFFFF;

typedef VkCompareOp = inline CUInt;
const VkCompareOp COMPARE_OP_NEVER = 0;
const VkCompareOp COMPARE_OP_LESS = 1;
const VkCompareOp COMPARE_OP_EQUAL = 2;
const VkCompareOp COMPARE_OP_LESS_OR_EQUAL = 3;
const VkCompareOp COMPARE_OP_GREATER = 4;
const VkCompareOp COMPARE_OP_NOT_EQUAL = 5;
const VkCompareOp COMPARE_OP_GREATER_OR_EQUAL = 6;
const VkCompareOp COMPARE_OP_ALWAYS = 7;
const VkCompareOp COMPARE_OP_MAX_ENUM = 0x7FFFFFFF;

typedef VkDynamicState = inline CUInt;
const VkDynamicState DYNAMIC_STATE_VIEWPORT = 0;
const VkDynamicState DYNAMIC_STATE_SCISSOR = 1;
const VkDynamicState DYNAMIC_STATE_LINE_WIDTH = 2;
const VkDynamicState DYNAMIC_STATE_DEPTH_BIAS = 3;
const VkDynamicState DYNAMIC_STATE_BLEND_CONSTANTS = 4;
const VkDynamicState DYNAMIC_STATE_DEPTH_BOUNDS = 5;
const VkDynamicState DYNAMIC_STATE_STENCIL_COMPARE_MASK = 6;
const VkDynamicState DYNAMIC_STATE_STENCIL_WRITE_MASK = 7;
const VkDynamicState DYNAMIC_STATE_STENCIL_REFERENCE = 8;
const VkDynamicState DYNAMIC_STATE_VIEWPORT_W_SCALING_NV = 1000087000;
const VkDynamicState DYNAMIC_STATE_DISCARD_RECTANGLE_EXT = 1000099000;
const VkDynamicState DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT = 1000143000;
const VkDynamicState DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR = 1000347000;
const VkDynamicState DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV = 1000164004;
const VkDynamicState DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV = 1000164006;
const VkDynamicState DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV = 1000205001;
const VkDynamicState DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR = 1000226000;
const VkDynamicState DYNAMIC_STATE_LINE_STIPPLE_EXT = 1000259000;
const VkDynamicState DYNAMIC_STATE_CULL_MODE_EXT = 1000267000;
const VkDynamicState DYNAMIC_STATE_FRONT_FACE_EXT = 1000267001;
const VkDynamicState DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT = 1000267002;
const VkDynamicState DYNAMIC_STATE_VIEWPORT_WITH_COUNT_EXT = 1000267003;
const VkDynamicState DYNAMIC_STATE_SCISSOR_WITH_COUNT_EXT = 1000267004;
const VkDynamicState DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT = 1000267005;
const VkDynamicState DYNAMIC_STATE_DEPTH_TEST_ENABLE_EXT = 1000267006;
const VkDynamicState DYNAMIC_STATE_DEPTH_WRITE_ENABLE_EXT = 1000267007;
const VkDynamicState DYNAMIC_STATE_DEPTH_COMPARE_OP_EXT = 1000267008;
const VkDynamicState DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE_EXT = 1000267009;
const VkDynamicState DYNAMIC_STATE_STENCIL_TEST_ENABLE_EXT = 1000267010;
const VkDynamicState DYNAMIC_STATE_STENCIL_OP_EXT = 1000267011;
const VkDynamicState DYNAMIC_STATE_VERTEX_INPUT_EXT = 1000352000;
const VkDynamicState DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT = 1000377000;
const VkDynamicState DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE_EXT = 1000377001;
const VkDynamicState DYNAMIC_STATE_DEPTH_BIAS_ENABLE_EXT = 1000377002;
const VkDynamicState DYNAMIC_STATE_LOGIC_OP_EXT = 1000377003;
const VkDynamicState DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT = 1000377004;
const VkDynamicState DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT = 1000381000;
const VkDynamicState DYNAMIC_STATE_MAX_ENUM = 0x7FFFFFFF;

typedef VkFrontFace = inline CUInt;
const VkFrontFace FRONT_FACE_COUNTER_CLOCKWISE = 0;
const VkFrontFace FRONT_FACE_CLOCKWISE = 1;
const VkFrontFace FRONT_FACE_MAX_ENUM = 0x7FFFFFFF;

typedef VkVertexInputRate = inline CUInt;
const VkVertexInputRate VERTEX_INPUT_RATE_VERTEX = 0;
const VkVertexInputRate VERTEX_INPUT_RATE_INSTANCE = 1;
const VkVertexInputRate VERTEX_INPUT_RATE_MAX_ENUM = 0x7FFFFFFF;

typedef VkPrimitiveTopology = inline CUInt;
const VkPrimitiveTopology PRIMITIVE_TOPOLOGY_POINT_LIST = 0;
const VkPrimitiveTopology PRIMITIVE_TOPOLOGY_LINE_LIST = 1;
const VkPrimitiveTopology PRIMITIVE_TOPOLOGY_LINE_STRIP = 2;
const VkPrimitiveTopology PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = 3;
const VkPrimitiveTopology PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = 4;
const VkPrimitiveTopology PRIMITIVE_TOPOLOGY_TRIANGLE_FAN = 5;
const VkPrimitiveTopology PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY = 6;
const VkPrimitiveTopology PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY = 7;
const VkPrimitiveTopology PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY = 8;
const VkPrimitiveTopology PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY = 9;
const VkPrimitiveTopology PRIMITIVE_TOPOLOGY_PATCH_LIST = 10;
const VkPrimitiveTopology PRIMITIVE_TOPOLOGY_MAX_ENUM = 0x7FFFFFFF;

typedef VkPolygonMode = inline CUInt;
const VkPolygonMode POLYGON_MODE_FILL = 0;
const VkPolygonMode POLYGON_MODE_LINE = 1;
const VkPolygonMode POLYGON_MODE_POINT = 2;
const VkPolygonMode POLYGON_MODE_FILL_RECTANGLE_NV = 1000153000;
const VkPolygonMode POLYGON_MODE_MAX_ENUM = 0x7FFFFFFF;

typedef VkStencilOp = inline CUInt;
const VkStencilOp STENCIL_OP_KEEP = 0;
const VkStencilOp STENCIL_OP_ZERO = 1;
const VkStencilOp STENCIL_OP_REPLACE = 2;
const VkStencilOp STENCIL_OP_INCREMENT_AND_CLAMP = 3;
const VkStencilOp STENCIL_OP_DECREMENT_AND_CLAMP = 4;
const VkStencilOp STENCIL_OP_INVERT = 5;
const VkStencilOp STENCIL_OP_INCREMENT_AND_WRAP = 6;
const VkStencilOp STENCIL_OP_DECREMENT_AND_WRAP = 7;
const VkStencilOp STENCIL_OP_MAX_ENUM = 0x7FFFFFFF;

typedef VkLogicOp = inline CUInt;
const VkLogicOp LOGIC_OP_CLEAR = 0;
const VkLogicOp LOGIC_OP_AND = 1;
const VkLogicOp LOGIC_OP_AND_REVERSE = 2;
const VkLogicOp LOGIC_OP_COPY = 3;
const VkLogicOp LOGIC_OP_AND_INVERTED = 4;
const VkLogicOp LOGIC_OP_NO_OP = 5;
const VkLogicOp LOGIC_OP_XOR = 6;
const VkLogicOp LOGIC_OP_OR = 7;
const VkLogicOp LOGIC_OP_NOR = 8;
const VkLogicOp LOGIC_OP_EQUIVALENT = 9;
const VkLogicOp LOGIC_OP_INVERT = 10;
const VkLogicOp LOGIC_OP_OR_REVERSE = 11;
const VkLogicOp LOGIC_OP_COPY_INVERTED = 12;
const VkLogicOp LOGIC_OP_OR_INVERTED = 13;
const VkLogicOp LOGIC_OP_NAND = 14;
const VkLogicOp LOGIC_OP_SET = 15;
const VkLogicOp LOGIC_OP_MAX_ENUM = 0x7FFFFFFF;

typedef VkBorderColor = inline CUInt;
const VkBorderColor BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = 0;
const VkBorderColor BORDER_COLOR_INT_TRANSPARENT_BLACK = 1;
const VkBorderColor BORDER_COLOR_FLOAT_OPAQUE_BLACK = 2;
const VkBorderColor BORDER_COLOR_INT_OPAQUE_BLACK = 3;
const VkBorderColor BORDER_COLOR_FLOAT_OPAQUE_WHITE = 4;
const VkBorderColor BORDER_COLOR_INT_OPAQUE_WHITE = 5;
const VkBorderColor BORDER_COLOR_FLOAT_CUSTOM_EXT = 1000287003;
const VkBorderColor BORDER_COLOR_INT_CUSTOM_EXT = 1000287004;
const VkBorderColor BORDER_COLOR_MAX_ENUM = 0x7FFFFFFF;

typedef VkFilter = inline CUInt;
const VkFilter FILTER_NEAREST = 0;
const VkFilter FILTER_LINEAR = 1;
const VkFilter FILTER_CUBIC_IMG = 1000015000;
const VkFilter FILTER_CUBIC_EXT = FILTER_CUBIC_IMG;
const VkFilter FILTER_MAX_ENUM = 0x7FFFFFFF;

typedef VkSamplerAddressMode = inline CUInt;
const VkSamplerAddressMode SAMPLER_ADDRESS_MODE_REPEAT = 0;
const VkSamplerAddressMode SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT = 1;
const VkSamplerAddressMode SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE = 2;
const VkSamplerAddressMode SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER = 3;
const VkSamplerAddressMode SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE = 4;
const VkSamplerAddressMode SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE_KHR = SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE;
const VkSamplerAddressMode SAMPLER_ADDRESS_MODE_MAX_ENUM = 0x7FFFFFFF;

typedef VkSamplerMipmapMode = inline CUInt;
const VkSamplerMipmapMode SAMPLER_MIPMAP_MODE_NEAREST = 0;
const VkSamplerMipmapMode SAMPLER_MIPMAP_MODE_LINEAR = 1;
const VkSamplerMipmapMode SAMPLER_MIPMAP_MODE_MAX_ENUM = 0x7FFFFFFF;

typedef VkDescriptorType = inline CUInt;
const VkDescriptorType DESCRIPTOR_TYPE_SAMPLER = 0;
const VkDescriptorType DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = 1;
const VkDescriptorType DESCRIPTOR_TYPE_SAMPLED_IMAGE = 2;
const VkDescriptorType DESCRIPTOR_TYPE_STORAGE_IMAGE = 3;
const VkDescriptorType DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = 4;
const VkDescriptorType DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = 5;
const VkDescriptorType DESCRIPTOR_TYPE_UNIFORM_BUFFER = 6;
const VkDescriptorType DESCRIPTOR_TYPE_STORAGE_BUFFER = 7;
const VkDescriptorType DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = 8;
const VkDescriptorType DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = 9;
const VkDescriptorType DESCRIPTOR_TYPE_INPUT_ATTACHMENT = 10;
const VkDescriptorType DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT = 1000138000;
const VkDescriptorType DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR = 1000150000;
const VkDescriptorType DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV = 1000165000;
const VkDescriptorType DESCRIPTOR_TYPE_MUTABLE_VALVE = 1000351000;
const VkDescriptorType DESCRIPTOR_TYPE_MAX_ENUM = 0x7FFFFFFF;

typedef VkAttachmentLoadOp = inline CUInt;
const VkAttachmentLoadOp ATTACHMENT_LOAD_OP_LOAD = 0;
const VkAttachmentLoadOp ATTACHMENT_LOAD_OP_CLEAR = 1;
const VkAttachmentLoadOp ATTACHMENT_LOAD_OP_DONT_CARE = 2;
const VkAttachmentLoadOp ATTACHMENT_LOAD_OP_NONE_EXT = 1000400000;
const VkAttachmentLoadOp ATTACHMENT_LOAD_OP_MAX_ENUM = 0x7FFFFFFF;

typedef VkAttachmentStoreOp = inline CUInt;
const VkAttachmentStoreOp ATTACHMENT_STORE_OP_STORE = 0;
const VkAttachmentStoreOp ATTACHMENT_STORE_OP_DONT_CARE = 1;
const VkAttachmentStoreOp ATTACHMENT_STORE_OP_NONE_KHR = 1000301000;
const VkAttachmentStoreOp ATTACHMENT_STORE_OP_NONE_QCOM = ATTACHMENT_STORE_OP_NONE_KHR;
const VkAttachmentStoreOp ATTACHMENT_STORE_OP_NONE_EXT = ATTACHMENT_STORE_OP_NONE_KHR;
const VkAttachmentStoreOp ATTACHMENT_STORE_OP_MAX_ENUM = 0x7FFFFFFF;

typedef VkPipelineBindPoint = inline CUInt;
const VkPipelineBindPoint PIPELINE_BIND_POINT_GRAPHICS = 0;
const VkPipelineBindPoint PIPELINE_BIND_POINT_COMPUTE = 1;
const VkPipelineBindPoint PIPELINE_BIND_POINT_RAY_TRACING_KHR = 1000165000;
const VkPipelineBindPoint PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI = 1000369003;
const VkPipelineBindPoint PIPELINE_BIND_POINT_RAY_TRACING_NV = PIPELINE_BIND_POINT_RAY_TRACING_KHR;
const VkPipelineBindPoint PIPELINE_BIND_POINT_MAX_ENUM = 0x7FFFFFFF;

typedef VkCommandBufferLevel = inline CUInt;
const VkCommandBufferLevel COMMAND_BUFFER_LEVEL_PRIMARY = 0;
const VkCommandBufferLevel COMMAND_BUFFER_LEVEL_SECONDARY = 1;
const VkCommandBufferLevel COMMAND_BUFFER_LEVEL_MAX_ENUM = 0x7FFFFFFF;

typedef VkIndexType = inline CUInt;
const VkIndexType INDEX_TYPE_UINT16 = 0;
const VkIndexType INDEX_TYPE_UINT32 = 1;
const VkIndexType INDEX_TYPE_NONE_KHR = 1000165000;
const VkIndexType INDEX_TYPE_UINT8_EXT = 1000265000;
const VkIndexType INDEX_TYPE_NONE_NV = INDEX_TYPE_NONE_KHR;
const VkIndexType INDEX_TYPE_MAX_ENUM = 0x7FFFFFFF;

typedef VkSubpassContents = inline CUInt;
const VkSubpassContents SUBPASS_CONTENTS_INLINE = 0;
const VkSubpassContents SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = 1;
const VkSubpassContents SUBPASS_CONTENTS_MAX_ENUM = 0x7FFFFFFF;

typedef VkAccessFlagBits = inline CUInt;
const VkAccessFlagBits ACCESS_INDIRECT_COMMAND_READ_BIT = 0x00000001;
const VkAccessFlagBits ACCESS_INDEX_READ_BIT = 0x00000002;
const VkAccessFlagBits ACCESS_VERTEX_ATTRIBUTE_READ_BIT = 0x00000004;
const VkAccessFlagBits ACCESS_UNIFORM_READ_BIT = 0x00000008;
const VkAccessFlagBits ACCESS_INPUT_ATTACHMENT_READ_BIT = 0x00000010;
const VkAccessFlagBits ACCESS_SHADER_READ_BIT = 0x00000020;
const VkAccessFlagBits ACCESS_SHADER_WRITE_BIT = 0x00000040;
const VkAccessFlagBits ACCESS_COLOR_ATTACHMENT_READ_BIT = 0x00000080;
const VkAccessFlagBits ACCESS_COLOR_ATTACHMENT_WRITE_BIT = 0x00000100;
const VkAccessFlagBits ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 0x00000200;
const VkAccessFlagBits ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 0x00000400;
const VkAccessFlagBits ACCESS_TRANSFER_READ_BIT = 0x00000800;
const VkAccessFlagBits ACCESS_TRANSFER_WRITE_BIT = 0x00001000;
const VkAccessFlagBits ACCESS_HOST_READ_BIT = 0x00002000;
const VkAccessFlagBits ACCESS_HOST_WRITE_BIT = 0x00004000;
const VkAccessFlagBits ACCESS_MEMORY_READ_BIT = 0x00008000;
const VkAccessFlagBits ACCESS_MEMORY_WRITE_BIT = 0x00010000;
const VkAccessFlagBits ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT = 0x02000000;
const VkAccessFlagBits ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT = 0x04000000;
const VkAccessFlagBits ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT = 0x08000000;
const VkAccessFlagBits ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT = 0x00100000;
const VkAccessFlagBits ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = 0x00080000;
const VkAccessFlagBits ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR = 0x00200000;
const VkAccessFlagBits ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR = 0x00400000;
const VkAccessFlagBits ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT = 0x01000000;
const VkAccessFlagBits ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR = 0x00800000;
const VkAccessFlagBits ACCESS_COMMAND_PREPROCESS_READ_BIT_NV = 0x00020000;
const VkAccessFlagBits ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV = 0x00040000;
const VkAccessFlagBits ACCESS_NONE_KHR = 0;
const VkAccessFlagBits ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV = ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR;
const VkAccessFlagBits ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV = ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR;
const VkAccessFlagBits ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV = ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR;
const VkAccessFlagBits ACCESS_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkAccessFlags = VkFlags;

typedef VkImageAspectFlagBits = inline CUInt;
const VkImageAspectFlagBits IMAGE_ASPECT_COLOR_BIT = 0x00000001;
const VkImageAspectFlagBits IMAGE_ASPECT_DEPTH_BIT = 0x00000002;
const VkImageAspectFlagBits IMAGE_ASPECT_STENCIL_BIT = 0x00000004;
const VkImageAspectFlagBits IMAGE_ASPECT_METADATA_BIT = 0x00000008;
const VkImageAspectFlagBits IMAGE_ASPECT_PLANE_0_BIT = 0x00000010;
const VkImageAspectFlagBits IMAGE_ASPECT_PLANE_1_BIT = 0x00000020;
const VkImageAspectFlagBits IMAGE_ASPECT_PLANE_2_BIT = 0x00000040;
const VkImageAspectFlagBits IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT = 0x00000080;
const VkImageAspectFlagBits IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT = 0x00000100;
const VkImageAspectFlagBits IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT = 0x00000200;
const VkImageAspectFlagBits IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT = 0x00000400;
const VkImageAspectFlagBits IMAGE_ASPECT_NONE_KHR = 0;
const VkImageAspectFlagBits IMAGE_ASPECT_PLANE_0_BIT_KHR = IMAGE_ASPECT_PLANE_0_BIT;
const VkImageAspectFlagBits IMAGE_ASPECT_PLANE_1_BIT_KHR = IMAGE_ASPECT_PLANE_1_BIT;
const VkImageAspectFlagBits IMAGE_ASPECT_PLANE_2_BIT_KHR = IMAGE_ASPECT_PLANE_2_BIT;
const VkImageAspectFlagBits IMAGE_ASPECT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkImageAspectFlags = VkFlags;

typedef VkFormatFeatureFlagBits = inline CUInt;
const VkFormatFeatureFlagBits FORMAT_FEATURE_SAMPLED_IMAGE_BIT = 0x00000001;
const VkFormatFeatureFlagBits FORMAT_FEATURE_STORAGE_IMAGE_BIT = 0x00000002;
const VkFormatFeatureFlagBits FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT = 0x00000004;
const VkFormatFeatureFlagBits FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000008;
const VkFormatFeatureFlagBits FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT = 0x00000010;
const VkFormatFeatureFlagBits FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = 0x00000020;
const VkFormatFeatureFlagBits FORMAT_FEATURE_VERTEX_BUFFER_BIT = 0x00000040;
const VkFormatFeatureFlagBits FORMAT_FEATURE_COLOR_ATTACHMENT_BIT = 0x00000080;
const VkFormatFeatureFlagBits FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT = 0x00000100;
const VkFormatFeatureFlagBits FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000200;
const VkFormatFeatureFlagBits FORMAT_FEATURE_BLIT_SRC_BIT = 0x00000400;
const VkFormatFeatureFlagBits FORMAT_FEATURE_BLIT_DST_BIT = 0x00000800;
const VkFormatFeatureFlagBits FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT = 0x00001000;
const VkFormatFeatureFlagBits FORMAT_FEATURE_TRANSFER_SRC_BIT = 0x00004000;
const VkFormatFeatureFlagBits FORMAT_FEATURE_TRANSFER_DST_BIT = 0x00008000;
const VkFormatFeatureFlagBits FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT = 0x00020000;
const VkFormatFeatureFlagBits FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT = 0x00040000;
const VkFormatFeatureFlagBits FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT = 0x00080000;
const VkFormatFeatureFlagBits FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT = 0x00100000;
const VkFormatFeatureFlagBits FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT = 0x00200000;
const VkFormatFeatureFlagBits FORMAT_FEATURE_DISJOINT_BIT = 0x00400000;
const VkFormatFeatureFlagBits FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT = 0x00800000;
const VkFormatFeatureFlagBits FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT = 0x00010000;
const VkFormatFeatureFlagBits FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG = 0x00002000;
const VkFormatFeatureFlagBits FORMAT_FEATURE_VIDEO_DECODE_OUTPUT_BIT_KHR = 0x02000000;
const VkFormatFeatureFlagBits FORMAT_FEATURE_VIDEO_DECODE_DPB_BIT_KHR = 0x04000000;
const VkFormatFeatureFlagBits FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR = 0x20000000;
const VkFormatFeatureFlagBits FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT = 0x01000000;
const VkFormatFeatureFlagBits FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x40000000;
const VkFormatFeatureFlagBits FORMAT_FEATURE_VIDEO_ENCODE_INPUT_BIT_KHR = 0x08000000;
const VkFormatFeatureFlagBits FORMAT_FEATURE_VIDEO_ENCODE_DPB_BIT_KHR = 0x10000000;
const VkFormatFeatureFlagBits FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR = FORMAT_FEATURE_TRANSFER_SRC_BIT;
const VkFormatFeatureFlagBits FORMAT_FEATURE_TRANSFER_DST_BIT_KHR = FORMAT_FEATURE_TRANSFER_DST_BIT;
const VkFormatFeatureFlagBits FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT = FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT;
const VkFormatFeatureFlagBits FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR = FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT;
const VkFormatFeatureFlagBits FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR = FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT;
const VkFormatFeatureFlagBits FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR = FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT;
const VkFormatFeatureFlagBits FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR = FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT;
const VkFormatFeatureFlagBits FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR = FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT;
const VkFormatFeatureFlagBits FORMAT_FEATURE_DISJOINT_BIT_KHR = FORMAT_FEATURE_DISJOINT_BIT;
const VkFormatFeatureFlagBits FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR = FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT;
const VkFormatFeatureFlagBits FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT = FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG;
const VkFormatFeatureFlagBits FORMAT_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkFormatFeatureFlags = VkFlags;

typedef VkImageCreateFlagBits = inline CUInt;
const VkImageCreateFlagBits IMAGE_CREATE_SPARSE_BINDING_BIT = 0x00000001;
const VkImageCreateFlagBits IMAGE_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002;
const VkImageCreateFlagBits IMAGE_CREATE_SPARSE_ALIASED_BIT = 0x00000004;
const VkImageCreateFlagBits IMAGE_CREATE_MUTABLE_FORMAT_BIT = 0x00000008;
const VkImageCreateFlagBits IMAGE_CREATE_CUBE_COMPATIBLE_BIT = 0x00000010;
const VkImageCreateFlagBits IMAGE_CREATE_ALIAS_BIT = 0x00000400;
const VkImageCreateFlagBits IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT = 0x00000040;
const VkImageCreateFlagBits IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT = 0x00000020;
const VkImageCreateFlagBits IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT = 0x00000080;
const VkImageCreateFlagBits IMAGE_CREATE_EXTENDED_USAGE_BIT = 0x00000100;
const VkImageCreateFlagBits IMAGE_CREATE_PROTECTED_BIT = 0x00000800;
const VkImageCreateFlagBits IMAGE_CREATE_DISJOINT_BIT = 0x00000200;
const VkImageCreateFlagBits IMAGE_CREATE_CORNER_SAMPLED_BIT_NV = 0x00002000;
const VkImageCreateFlagBits IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT = 0x00001000;
const VkImageCreateFlagBits IMAGE_CREATE_SUBSAMPLED_BIT_EXT = 0x00004000;
const VkImageCreateFlagBits IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM = 0x00008000;
const VkImageCreateFlagBits IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT;
const VkImageCreateFlagBits IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR = IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT;
const VkImageCreateFlagBits IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR = IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT;
const VkImageCreateFlagBits IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR = IMAGE_CREATE_EXTENDED_USAGE_BIT;
const VkImageCreateFlagBits IMAGE_CREATE_DISJOINT_BIT_KHR = IMAGE_CREATE_DISJOINT_BIT;
const VkImageCreateFlagBits IMAGE_CREATE_ALIAS_BIT_KHR = IMAGE_CREATE_ALIAS_BIT;
const VkImageCreateFlagBits IMAGE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkImageCreateFlags = VkFlags;

typedef VkSampleCountFlagBits = inline CUInt;
const VkSampleCountFlagBits SAMPLE_COUNT_1_BIT = 0x00000001;
const VkSampleCountFlagBits SAMPLE_COUNT_2_BIT = 0x00000002;
const VkSampleCountFlagBits SAMPLE_COUNT_4_BIT = 0x00000004;
const VkSampleCountFlagBits SAMPLE_COUNT_8_BIT = 0x00000008;
const VkSampleCountFlagBits SAMPLE_COUNT_16_BIT = 0x00000010;
const VkSampleCountFlagBits SAMPLE_COUNT_32_BIT = 0x00000020;
const VkSampleCountFlagBits SAMPLE_COUNT_64_BIT = 0x00000040;
const VkSampleCountFlagBits SAMPLE_COUNT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkSampleCountFlags = VkFlags;

typedef VkImageUsageFlagBits = inline CUInt;
const VkImageUsageFlagBits IMAGE_USAGE_TRANSFER_SRC_BIT = 0x00000001;
const VkImageUsageFlagBits IMAGE_USAGE_TRANSFER_DST_BIT = 0x00000002;
const VkImageUsageFlagBits IMAGE_USAGE_SAMPLED_BIT = 0x00000004;
const VkImageUsageFlagBits IMAGE_USAGE_STORAGE_BIT = 0x00000008;
const VkImageUsageFlagBits IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 0x00000010;
const VkImageUsageFlagBits IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000020;
const VkImageUsageFlagBits IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 0x00000040;
const VkImageUsageFlagBits IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 0x00000080;
const VkImageUsageFlagBits IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR = 0x00000400;
const VkImageUsageFlagBits IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR = 0x00000800;
const VkImageUsageFlagBits IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR = 0x00001000;
const VkImageUsageFlagBits IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT = 0x00000200;
const VkImageUsageFlagBits IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00000100;
const VkImageUsageFlagBits IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR = 0x00002000;
const VkImageUsageFlagBits IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR = 0x00004000;
const VkImageUsageFlagBits IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR = 0x00008000;
const VkImageUsageFlagBits IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI = 0x00040000;
const VkImageUsageFlagBits IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV = IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;
const VkImageUsageFlagBits IMAGE_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkImageUsageFlags = VkFlags;

alias VkInstanceCreateFlags = VkFlags;

typedef VkMemoryHeapFlagBits = inline CUInt;
const VkMemoryHeapFlagBits MEMORY_HEAP_DEVICE_LOCAL_BIT = 0x00000001;
const VkMemoryHeapFlagBits MEMORY_HEAP_MULTI_INSTANCE_BIT = 0x00000002;
const VkMemoryHeapFlagBits MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR = MEMORY_HEAP_MULTI_INSTANCE_BIT;
const VkMemoryHeapFlagBits MEMORY_HEAP_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkMemoryHeapFlags = VkFlags;

typedef VkMemoryPropertyFlagBits = inline CUInt;
const VkMemoryPropertyFlagBits MEMORY_PROPERTY_DEVICE_LOCAL_BIT = 0x00000001;
const VkMemoryPropertyFlagBits MEMORY_PROPERTY_HOST_VISIBLE_BIT = 0x00000002;
const VkMemoryPropertyFlagBits MEMORY_PROPERTY_HOST_COHERENT_BIT = 0x00000004;
const VkMemoryPropertyFlagBits MEMORY_PROPERTY_HOST_CACHED_BIT = 0x00000008;
const VkMemoryPropertyFlagBits MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 0x00000010;
const VkMemoryPropertyFlagBits MEMORY_PROPERTY_PROTECTED_BIT = 0x00000020;
const VkMemoryPropertyFlagBits MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD = 0x00000040;
const VkMemoryPropertyFlagBits MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD = 0x00000080;
const VkMemoryPropertyFlagBits MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV = 0x00000100;
const VkMemoryPropertyFlagBits MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkMemoryPropertyFlags = VkFlags;

typedef VkQueueFlagBits = inline CUInt;
const VkQueueFlagBits QUEUE_GRAPHICS_BIT = 0x00000001;
const VkQueueFlagBits QUEUE_COMPUTE_BIT = 0x00000002;
const VkQueueFlagBits QUEUE_TRANSFER_BIT = 0x00000004;
const VkQueueFlagBits QUEUE_SPARSE_BINDING_BIT = 0x00000008;
const VkQueueFlagBits QUEUE_PROTECTED_BIT = 0x00000010;
const VkQueueFlagBits QUEUE_VIDEO_DECODE_BIT_KHR = 0x00000020;
const VkQueueFlagBits QUEUE_VIDEO_ENCODE_BIT_KHR = 0x00000040;
const VkQueueFlagBits QUEUE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkQueueFlags = VkFlags;

alias VkDeviceCreateFlags = VkFlags;

typedef VkDeviceQueueCreateFlagBits = inline CUInt;
const VkDeviceQueueCreateFlagBits DEVICE_QUEUE_CREATE_PROTECTED_BIT = 0x00000001;
const VkDeviceQueueCreateFlagBits DEVICE_QUEUE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkDeviceQueueCreateFlags = VkFlags;

typedef VkPipelineStageFlagBits = inline CUInt;
const VkPipelineStageFlagBits PIPELINE_STAGE_TOP_OF_PIPE_BIT = 0x00000001;
const VkPipelineStageFlagBits PIPELINE_STAGE_DRAW_INDIRECT_BIT = 0x00000002;
const VkPipelineStageFlagBits PIPELINE_STAGE_VERTEX_INPUT_BIT = 0x00000004;
const VkPipelineStageFlagBits PIPELINE_STAGE_VERTEX_SHADER_BIT = 0x00000008;
const VkPipelineStageFlagBits PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = 0x00000010;
const VkPipelineStageFlagBits PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = 0x00000020;
const VkPipelineStageFlagBits PIPELINE_STAGE_GEOMETRY_SHADER_BIT = 0x00000040;
const VkPipelineStageFlagBits PIPELINE_STAGE_FRAGMENT_SHADER_BIT = 0x00000080;
const VkPipelineStageFlagBits PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = 0x00000100;
const VkPipelineStageFlagBits PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = 0x00000200;
const VkPipelineStageFlagBits PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = 0x00000400;
const VkPipelineStageFlagBits PIPELINE_STAGE_COMPUTE_SHADER_BIT = 0x00000800;
const VkPipelineStageFlagBits PIPELINE_STAGE_TRANSFER_BIT = 0x00001000;
const VkPipelineStageFlagBits PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = 0x00002000;
const VkPipelineStageFlagBits PIPELINE_STAGE_HOST_BIT = 0x00004000;
const VkPipelineStageFlagBits PIPELINE_STAGE_ALL_GRAPHICS_BIT = 0x00008000;
const VkPipelineStageFlagBits PIPELINE_STAGE_ALL_COMMANDS_BIT = 0x00010000;
const VkPipelineStageFlagBits PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT = 0x01000000;
const VkPipelineStageFlagBits PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT = 0x00040000;
const VkPipelineStageFlagBits PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR = 0x02000000;
const VkPipelineStageFlagBits PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR = 0x00200000;
const VkPipelineStageFlagBits PIPELINE_STAGE_TASK_SHADER_BIT_NV = 0x00080000;
const VkPipelineStageFlagBits PIPELINE_STAGE_MESH_SHADER_BIT_NV = 0x00100000;
const VkPipelineStageFlagBits PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT = 0x00800000;
const VkPipelineStageFlagBits PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00400000;
const VkPipelineStageFlagBits PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV = 0x00020000;
const VkPipelineStageFlagBits PIPELINE_STAGE_NONE_KHR = 0;
const VkPipelineStageFlagBits PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV = PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;
const VkPipelineStageFlagBits PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV = PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR;
const VkPipelineStageFlagBits PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV = PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR;
const VkPipelineStageFlagBits PIPELINE_STAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkPipelineStageFlags = VkFlags;

alias VkMemoryMapFlags = VkFlags;

typedef VkSparseMemoryBindFlagBits = inline CUInt;
const VkSparseMemoryBindFlagBits SPARSE_MEMORY_BIND_METADATA_BIT = 0x00000001;
const VkSparseMemoryBindFlagBits SPARSE_MEMORY_BIND_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkSparseMemoryBindFlags = VkFlags;

typedef VkSparseImageFormatFlagBits = inline CUInt;
const VkSparseImageFormatFlagBits SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT = 0x00000001;
const VkSparseImageFormatFlagBits SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT = 0x00000002;
const VkSparseImageFormatFlagBits SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT = 0x00000004;
const VkSparseImageFormatFlagBits SPARSE_IMAGE_FORMAT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkSparseImageFormatFlags = VkFlags;

typedef VkFenceCreateFlagBits = inline CUInt;
const VkFenceCreateFlagBits FENCE_CREATE_SIGNALED_BIT = 0x00000001;
const VkFenceCreateFlagBits FENCE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkFenceCreateFlags = VkFlags;

alias VkSemaphoreCreateFlags = VkFlags;

typedef VkEventCreateFlagBits = inline CUInt;
const VkEventCreateFlagBits EVENT_CREATE_DEVICE_ONLY_BIT_KHR = 0x00000001;
const VkEventCreateFlagBits EVENT_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkEventCreateFlags = VkFlags;

typedef VkQueryPipelineStatisticFlagBits = inline CUInt;
const VkQueryPipelineStatisticFlagBits QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT = 0x00000001;
const VkQueryPipelineStatisticFlagBits QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT = 0x00000002;
const VkQueryPipelineStatisticFlagBits QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT = 0x00000004;
const VkQueryPipelineStatisticFlagBits QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT = 0x00000008;
const VkQueryPipelineStatisticFlagBits QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT = 0x00000010;
const VkQueryPipelineStatisticFlagBits QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT = 0x00000020;
const VkQueryPipelineStatisticFlagBits QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT = 0x00000040;
const VkQueryPipelineStatisticFlagBits QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT = 0x00000080;
const VkQueryPipelineStatisticFlagBits QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT = 0x00000100;
const VkQueryPipelineStatisticFlagBits QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT = 0x00000200;
const VkQueryPipelineStatisticFlagBits QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT = 0x00000400;
const VkQueryPipelineStatisticFlagBits QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkQueryPipelineStatisticFlags = VkFlags;

alias VkQueryPoolCreateFlags = VkFlags;

typedef VkQueryResultFlagBits = inline CUInt;
const VkQueryResultFlagBits QUERY_RESULT_64_BIT = 0x00000001;
const VkQueryResultFlagBits QUERY_RESULT_WAIT_BIT = 0x00000002;
const VkQueryResultFlagBits QUERY_RESULT_WITH_AVAILABILITY_BIT = 0x00000004;
const VkQueryResultFlagBits QUERY_RESULT_PARTIAL_BIT = 0x00000008;
const VkQueryResultFlagBits QUERY_RESULT_WITH_STATUS_BIT_KHR = 0x00000010;
const VkQueryResultFlagBits QUERY_RESULT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkQueryResultFlags = VkFlags;

typedef VkBufferCreateFlagBits = inline CUInt;
const VkBufferCreateFlagBits BUFFER_CREATE_SPARSE_BINDING_BIT = 0x00000001;
const VkBufferCreateFlagBits BUFFER_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002;
const VkBufferCreateFlagBits BUFFER_CREATE_SPARSE_ALIASED_BIT = 0x00000004;
const VkBufferCreateFlagBits BUFFER_CREATE_PROTECTED_BIT = 0x00000008;
const VkBufferCreateFlagBits BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT = 0x00000010;
const VkBufferCreateFlagBits BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT = BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT;
const VkBufferCreateFlagBits BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR = BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT;
const VkBufferCreateFlagBits BUFFER_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkBufferCreateFlags = VkFlags;

typedef VkBufferUsageFlagBits = inline CUInt;
const VkBufferUsageFlagBits BUFFER_USAGE_TRANSFER_SRC_BIT = 0x00000001;
const VkBufferUsageFlagBits BUFFER_USAGE_TRANSFER_DST_BIT = 0x00000002;
const VkBufferUsageFlagBits BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000004;
const VkBufferUsageFlagBits BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = 0x00000008;
const VkBufferUsageFlagBits BUFFER_USAGE_UNIFORM_BUFFER_BIT = 0x00000010;
const VkBufferUsageFlagBits BUFFER_USAGE_STORAGE_BUFFER_BIT = 0x00000020;
const VkBufferUsageFlagBits BUFFER_USAGE_INDEX_BUFFER_BIT = 0x00000040;
const VkBufferUsageFlagBits BUFFER_USAGE_VERTEX_BUFFER_BIT = 0x00000080;
const VkBufferUsageFlagBits BUFFER_USAGE_INDIRECT_BUFFER_BIT = 0x00000100;
const VkBufferUsageFlagBits BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT = 0x00020000;
const VkBufferUsageFlagBits BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR = 0x00002000;
const VkBufferUsageFlagBits BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR = 0x00004000;
const VkBufferUsageFlagBits BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT = 0x00000800;
const VkBufferUsageFlagBits BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT = 0x00001000;
const VkBufferUsageFlagBits BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT = 0x00000200;
const VkBufferUsageFlagBits BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR = 0x00080000;
const VkBufferUsageFlagBits BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR = 0x00100000;
const VkBufferUsageFlagBits BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR = 0x00000400;
const VkBufferUsageFlagBits BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR = 0x00008000;
const VkBufferUsageFlagBits BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR = 0x00010000;
const VkBufferUsageFlagBits BUFFER_USAGE_RAY_TRACING_BIT_NV = BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR;
const VkBufferUsageFlagBits BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT = BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT;
const VkBufferUsageFlagBits BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR = BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT;
const VkBufferUsageFlagBits BUFFER_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkBufferUsageFlags = VkFlags;

alias VkBufferViewCreateFlags = VkFlags;

typedef VkImageViewCreateFlagBits = inline CUInt;
const VkImageViewCreateFlagBits IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT = 0x00000001;
const VkImageViewCreateFlagBits IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT = 0x00000002;
const VkImageViewCreateFlagBits IMAGE_VIEW_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkImageViewCreateFlags = VkFlags;

alias VkShaderModuleCreateFlags = VkFlags;

typedef VkPipelineCacheCreateFlagBits = inline CUInt;
const VkPipelineCacheCreateFlagBits PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT = 0x00000001;
const VkPipelineCacheCreateFlagBits PIPELINE_CACHE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkPipelineCacheCreateFlags = VkFlags;

typedef VkColorComponentFlagBits = inline CUInt;
const VkColorComponentFlagBits COLOR_COMPONENT_R_BIT = 0x00000001;
const VkColorComponentFlagBits COLOR_COMPONENT_G_BIT = 0x00000002;
const VkColorComponentFlagBits COLOR_COMPONENT_B_BIT = 0x00000004;
const VkColorComponentFlagBits COLOR_COMPONENT_A_BIT = 0x00000008;
const VkColorComponentFlagBits COLOR_COMPONENT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkColorComponentFlags = VkFlags;

typedef VkPipelineCreateFlagBits = inline CUInt;
const VkPipelineCreateFlagBits PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT = 0x00000001;
const VkPipelineCreateFlagBits PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT = 0x00000002;
const VkPipelineCreateFlagBits PIPELINE_CREATE_DERIVATIVE_BIT = 0x00000004;
const VkPipelineCreateFlagBits PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT = 0x00000008;
const VkPipelineCreateFlagBits PIPELINE_CREATE_DISPATCH_BASE_BIT = 0x00000010;
const VkPipelineCreateFlagBits PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00200000;
const VkPipelineCreateFlagBits PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = 0x00400000;
const VkPipelineCreateFlagBits PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR = 0x00004000;
const VkPipelineCreateFlagBits PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR = 0x00008000;
const VkPipelineCreateFlagBits PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR = 0x00010000;
const VkPipelineCreateFlagBits PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR = 0x00020000;
const VkPipelineCreateFlagBits PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR = 0x00001000;
const VkPipelineCreateFlagBits PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR = 0x00002000;
const VkPipelineCreateFlagBits PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR = 0x00080000;
const VkPipelineCreateFlagBits PIPELINE_CREATE_DEFER_COMPILE_BIT_NV = 0x00000020;
const VkPipelineCreateFlagBits PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR = 0x00000040;
const VkPipelineCreateFlagBits PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR = 0x00000080;
const VkPipelineCreateFlagBits PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV = 0x00040000;
const VkPipelineCreateFlagBits PIPELINE_CREATE_LIBRARY_BIT_KHR = 0x00000800;
const VkPipelineCreateFlagBits PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT = 0x00000100;
const VkPipelineCreateFlagBits PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT = 0x00000200;
const VkPipelineCreateFlagBits PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV = 0x00100000;
const VkPipelineCreateFlagBits PIPELINE_CREATE_DISPATCH_BASE = PIPELINE_CREATE_DISPATCH_BASE_BIT;
const VkPipelineCreateFlagBits PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;
const VkPipelineCreateFlagBits PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT;
const VkPipelineCreateFlagBits PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR = PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT;
const VkPipelineCreateFlagBits PIPELINE_CREATE_DISPATCH_BASE_KHR = PIPELINE_CREATE_DISPATCH_BASE;
const VkPipelineCreateFlagBits PIPELINE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkPipelineCreateFlags = VkFlags;

typedef VkPipelineShaderStageCreateFlagBits = inline CUInt;
const VkPipelineShaderStageCreateFlagBits PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT = 0x00000001;
const VkPipelineShaderStageCreateFlagBits PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT = 0x00000002;
const VkPipelineShaderStageCreateFlagBits PIPELINE_SHADER_STAGE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkPipelineShaderStageCreateFlags = VkFlags;

typedef VkShaderStageFlagBits = inline CUInt;
const VkShaderStageFlagBits SHADER_STAGE_VERTEX_BIT = 0x00000001;
const VkShaderStageFlagBits SHADER_STAGE_TESSELLATION_CONTROL_BIT = 0x00000002;
const VkShaderStageFlagBits SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 0x00000004;
const VkShaderStageFlagBits SHADER_STAGE_GEOMETRY_BIT = 0x00000008;
const VkShaderStageFlagBits SHADER_STAGE_FRAGMENT_BIT = 0x00000010;
const VkShaderStageFlagBits SHADER_STAGE_COMPUTE_BIT = 0x00000020;
const VkShaderStageFlagBits SHADER_STAGE_ALL_GRAPHICS = 0x0000001F;
const VkShaderStageFlagBits SHADER_STAGE_ALL = 0x7FFFFFFF;
const VkShaderStageFlagBits SHADER_STAGE_RAYGEN_BIT_KHR = 0x00000100;
const VkShaderStageFlagBits SHADER_STAGE_ANY_HIT_BIT_KHR = 0x00000200;
const VkShaderStageFlagBits SHADER_STAGE_CLOSEST_HIT_BIT_KHR = 0x00000400;
const VkShaderStageFlagBits SHADER_STAGE_MISS_BIT_KHR = 0x00000800;
const VkShaderStageFlagBits SHADER_STAGE_INTERSECTION_BIT_KHR = 0x00001000;
const VkShaderStageFlagBits SHADER_STAGE_CALLABLE_BIT_KHR = 0x00002000;
const VkShaderStageFlagBits SHADER_STAGE_TASK_BIT_NV = 0x00000040;
const VkShaderStageFlagBits SHADER_STAGE_MESH_BIT_NV = 0x00000080;
const VkShaderStageFlagBits SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI = 0x00004000;
const VkShaderStageFlagBits SHADER_STAGE_RAYGEN_BIT_NV = SHADER_STAGE_RAYGEN_BIT_KHR;
const VkShaderStageFlagBits SHADER_STAGE_ANY_HIT_BIT_NV = SHADER_STAGE_ANY_HIT_BIT_KHR;
const VkShaderStageFlagBits SHADER_STAGE_CLOSEST_HIT_BIT_NV = SHADER_STAGE_CLOSEST_HIT_BIT_KHR;
const VkShaderStageFlagBits SHADER_STAGE_MISS_BIT_NV = SHADER_STAGE_MISS_BIT_KHR;
const VkShaderStageFlagBits SHADER_STAGE_INTERSECTION_BIT_NV = SHADER_STAGE_INTERSECTION_BIT_KHR;
const VkShaderStageFlagBits SHADER_STAGE_CALLABLE_BIT_NV = SHADER_STAGE_CALLABLE_BIT_KHR;
const VkShaderStageFlagBits SHADER_STAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

typedef VkCullModeFlagBits = inline CUInt;
const VkCullModeFlagBits CULL_MODE_NONE = 0;
const VkCullModeFlagBits CULL_MODE_FRONT_BIT = 0x00000001;
const VkCullModeFlagBits CULL_MODE_BACK_BIT = 0x00000002;
const VkCullModeFlagBits CULL_MODE_FRONT_AND_BACK = 0x00000003;
const VkCullModeFlagBits CULL_MODE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkCullModeFlags = VkFlags;

alias VkPipelineVertexInputStateCreateFlags = VkFlags;

alias VkPipelineInputAssemblyStateCreateFlags = VkFlags;

alias VkPipelineTessellationStateCreateFlags = VkFlags;

alias VkPipelineViewportStateCreateFlags = VkFlags;

alias VkPipelineRasterizationStateCreateFlags = VkFlags;

alias VkPipelineMultisampleStateCreateFlags = VkFlags;

typedef VkPipelineDepthStencilStateCreateFlagBits = inline CUInt;
const VkPipelineDepthStencilStateCreateFlagBits PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM = 0x00000001;
const VkPipelineDepthStencilStateCreateFlagBits PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM = 0x00000002;
const VkPipelineDepthStencilStateCreateFlagBits PIPELINE_DEPTH_STENCIL_STATE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkPipelineDepthStencilStateCreateFlags = VkFlags;

typedef VkPipelineColorBlendStateCreateFlagBits = inline CUInt;
const VkPipelineColorBlendStateCreateFlagBits PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_ARM = 0x00000001;
const VkPipelineColorBlendStateCreateFlagBits PIPELINE_COLOR_BLEND_STATE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkPipelineColorBlendStateCreateFlags = VkFlags;

alias VkPipelineDynamicStateCreateFlags = VkFlags;

alias VkPipelineLayoutCreateFlags = VkFlags;

alias VkShaderStageFlags = VkFlags;

typedef VkSamplerCreateFlagBits = inline CUInt;
const VkSamplerCreateFlagBits SAMPLER_CREATE_SUBSAMPLED_BIT_EXT = 0x00000001;
const VkSamplerCreateFlagBits SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT = 0x00000002;
const VkSamplerCreateFlagBits SAMPLER_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkSamplerCreateFlags = VkFlags;

typedef VkDescriptorPoolCreateFlagBits = inline CUInt;
const VkDescriptorPoolCreateFlagBits DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = 0x00000001;
const VkDescriptorPoolCreateFlagBits DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT = 0x00000002;
const VkDescriptorPoolCreateFlagBits DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE = 0x00000004;
const VkDescriptorPoolCreateFlagBits DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT = DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT;
const VkDescriptorPoolCreateFlagBits DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkDescriptorPoolCreateFlags = VkFlags;

alias VkDescriptorPoolResetFlags = VkFlags;

typedef VkDescriptorSetLayoutCreateFlagBits = inline CUInt;
const VkDescriptorSetLayoutCreateFlagBits DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT = 0x00000002;
const VkDescriptorSetLayoutCreateFlagBits DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR = 0x00000001;
const VkDescriptorSetLayoutCreateFlagBits DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE = 0x00000004;
const VkDescriptorSetLayoutCreateFlagBits DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT = DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT;
const VkDescriptorSetLayoutCreateFlagBits DESCRIPTOR_SET_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkDescriptorSetLayoutCreateFlags = VkFlags;

typedef VkAttachmentDescriptionFlagBits = inline CUInt;
const VkAttachmentDescriptionFlagBits ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = 0x00000001;
const VkAttachmentDescriptionFlagBits ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkAttachmentDescriptionFlags = VkFlags;

typedef VkDependencyFlagBits = inline CUInt;
const VkDependencyFlagBits DEPENDENCY_BY_REGION_BIT = 0x00000001;
const VkDependencyFlagBits DEPENDENCY_DEVICE_GROUP_BIT = 0x00000004;
const VkDependencyFlagBits DEPENDENCY_VIEW_LOCAL_BIT = 0x00000002;
const VkDependencyFlagBits DEPENDENCY_VIEW_LOCAL_BIT_KHR = DEPENDENCY_VIEW_LOCAL_BIT;
const VkDependencyFlagBits DEPENDENCY_DEVICE_GROUP_BIT_KHR = DEPENDENCY_DEVICE_GROUP_BIT;
const VkDependencyFlagBits DEPENDENCY_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkDependencyFlags = VkFlags;

typedef VkFramebufferCreateFlagBits = inline CUInt;
const VkFramebufferCreateFlagBits FRAMEBUFFER_CREATE_IMAGELESS_BIT = 0x00000001;
const VkFramebufferCreateFlagBits FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR = FRAMEBUFFER_CREATE_IMAGELESS_BIT;
const VkFramebufferCreateFlagBits FRAMEBUFFER_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkFramebufferCreateFlags = VkFlags;

typedef VkRenderPassCreateFlagBits = inline CUInt;
const VkRenderPassCreateFlagBits RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM = 0x00000002;
const VkRenderPassCreateFlagBits RENDER_PASS_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkRenderPassCreateFlags = VkFlags;

typedef VkSubpassDescriptionFlagBits = inline CUInt;
const VkSubpassDescriptionFlagBits SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX = 0x00000001;
const VkSubpassDescriptionFlagBits SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX = 0x00000002;
const VkSubpassDescriptionFlagBits SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM = 0x00000004;
const VkSubpassDescriptionFlagBits SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM = 0x00000008;
const VkSubpassDescriptionFlagBits SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_ARM = 0x00000010;
const VkSubpassDescriptionFlagBits SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM = 0x00000020;
const VkSubpassDescriptionFlagBits SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM = 0x00000040;
const VkSubpassDescriptionFlagBits SUBPASS_DESCRIPTION_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkSubpassDescriptionFlags = VkFlags;

typedef VkCommandPoolCreateFlagBits = inline CUInt;
const VkCommandPoolCreateFlagBits COMMAND_POOL_CREATE_TRANSIENT_BIT = 0x00000001;
const VkCommandPoolCreateFlagBits COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = 0x00000002;
const VkCommandPoolCreateFlagBits COMMAND_POOL_CREATE_PROTECTED_BIT = 0x00000004;
const VkCommandPoolCreateFlagBits COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkCommandPoolCreateFlags = VkFlags;

typedef VkCommandPoolResetFlagBits = inline CUInt;
const VkCommandPoolResetFlagBits COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT = 0x00000001;
const VkCommandPoolResetFlagBits COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkCommandPoolResetFlags = VkFlags;

typedef VkCommandBufferUsageFlagBits = inline CUInt;
const VkCommandBufferUsageFlagBits COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = 0x00000001;
const VkCommandBufferUsageFlagBits COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = 0x00000002;
const VkCommandBufferUsageFlagBits COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = 0x00000004;
const VkCommandBufferUsageFlagBits COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkCommandBufferUsageFlags = VkFlags;

typedef VkQueryControlFlagBits = inline CUInt;
const VkQueryControlFlagBits QUERY_CONTROL_PRECISE_BIT = 0x00000001;
const VkQueryControlFlagBits QUERY_CONTROL_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkQueryControlFlags = VkFlags;

typedef VkCommandBufferResetFlagBits = inline CUInt;
const VkCommandBufferResetFlagBits COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = 0x00000001;
const VkCommandBufferResetFlagBits COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkCommandBufferResetFlags = VkFlags;

typedef VkStencilFaceFlagBits = inline CUInt;
const VkStencilFaceFlagBits STENCIL_FACE_FRONT_BIT = 0x00000001;
const VkStencilFaceFlagBits STENCIL_FACE_BACK_BIT = 0x00000002;
const VkStencilFaceFlagBits STENCIL_FACE_FRONT_AND_BACK = 0x00000003;
const VkStencilFaceFlagBits STENCIL_FRONT_AND_BACK = STENCIL_FACE_FRONT_AND_BACK;
const VkStencilFaceFlagBits STENCIL_FACE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkStencilFaceFlags = VkFlags;

struct VkExtent2D {
  uint width;
  uint height;
}

struct VkExtent3D {
  uint width;
  uint height;
  uint depth;
}

struct VkOffset2D {
  int x;
  int y;
}

struct VkOffset3D {
  int x;
  int y;
  int z;
}

struct VkRect2D {
  VkOffset2D offset;
  VkExtent2D extent;
}

struct VkBaseInStructure {
  VkStructureType sType;
  VkBaseInStructure * pNext;
}

struct VkBaseOutStructure {
  VkStructureType sType;
  VkBaseOutStructure * pNext;
}

struct VkBufferMemoryBarrier {
  VkStructureType sType;
  void * pNext;
  VkAccessFlags srcAccessMask;
  VkAccessFlags dstAccessMask;
  uint srcQueueFamilyIndex;
  uint dstQueueFamilyIndex;
  VkBuffer buffer;
  VkDeviceSize offset;
  VkDeviceSize size;
}

struct VkDispatchIndirectCommand {
  uint x;
  uint y;
  uint z;
}

struct VkDrawIndexedIndirectCommand {
  uint indexCount;
  uint instanceCount;
  uint firstIndex;
  int vertexOffset;
  uint firstInstance;
}

struct VkDrawIndirectCommand {
  uint vertexCount;
  uint instanceCount;
  uint firstVertex;
  uint firstInstance;
}

struct VkImageSubresourceRange {
  VkImageAspectFlags aspectMask;
  uint baseMipLevel;
  uint levelCount;
  uint baseArrayLayer;
  uint layerCount;
}

struct VkImageMemoryBarrier {
  VkStructureType sType;
  void * pNext;
  VkAccessFlags srcAccessMask;
  VkAccessFlags dstAccessMask;
  VkImageLayout oldLayout;
  VkImageLayout newLayout;
  uint srcQueueFamilyIndex;
  uint dstQueueFamilyIndex;
  VkImage image;
  VkImageSubresourceRange subresourceRange;
}

struct VkMemoryBarrier {
  VkStructureType sType;
  void * pNext;
  VkAccessFlags srcAccessMask;
  VkAccessFlags dstAccessMask;
}

struct VkPipelineCacheHeaderVersionOne {
  uint headerSize;
  VkPipelineCacheHeaderVersion headerVersion;
  uint vendorID;
  uint deviceID;
  char[16] pipelineCacheUUID;
}

alias PFN_vkAllocationFunction = fn void *(
  void * pUserData, 
  usz size, 
  usz alignment, 
  VkSystemAllocationScope allocationScope);

alias PFN_vkFreeFunction = fn void(
  void * pUserData, 
  void * pMemory);

alias PFN_vkInternalAllocationNotification = fn void(
  void * pUserData, 
  usz size, 
  VkInternalAllocationType allocationType, 
  VkSystemAllocationScope allocationScope);

alias PFN_vkInternalFreeNotification = fn void(
  void * pUserData, 
  usz size, 
  VkInternalAllocationType allocationType, 
  VkSystemAllocationScope allocationScope);

alias PFN_vkReallocationFunction = fn void *(
  void * pUserData, 
  void * pOriginal, 
  usz size, 
  usz alignment, 
  VkSystemAllocationScope allocationScope);

alias PFN_vkVoidFunction = fn void();

struct VkAllocationCallbacks {
  void * pUserData;
  PFN_vkAllocationFunction pfnAllocation;
  PFN_vkReallocationFunction pfnReallocation;
  PFN_vkFreeFunction pfnFree;
  PFN_vkInternalAllocationNotification pfnInternalAllocation;
  PFN_vkInternalFreeNotification pfnInternalFree;
}

struct VkApplicationInfo {
  VkStructureType sType;
  void * pNext;
  CChar * pApplicationName;
  uint applicationVersion;
  CChar * pEngineName;
  uint engineVersion;
  uint apiVersion;
}

struct VkFormatProperties {
  VkFormatFeatureFlags linearTilingFeatures;
  VkFormatFeatureFlags optimalTilingFeatures;
  VkFormatFeatureFlags bufferFeatures;
}

struct VkImageFormatProperties {
  VkExtent3D maxExtent;
  uint maxMipLevels;
  uint maxArrayLayers;
  VkSampleCountFlags sampleCounts;
  VkDeviceSize maxResourceSize;
}

struct VkInstanceCreateInfo {
  VkStructureType sType;
  void * pNext;
  VkInstanceCreateFlags flags;
  VkApplicationInfo * pApplicationInfo;
  uint enabledLayerCount;
  CChar ** ppEnabledLayerNames;
  uint enabledExtensionCount;
  CChar ** ppEnabledExtensionNames;
}

struct VkMemoryHeap {
  VkDeviceSize size;
  VkMemoryHeapFlags flags;
}

struct VkMemoryType {
  VkMemoryPropertyFlags propertyFlags;
  uint heapIndex;
}

struct VkPhysicalDeviceFeatures {
  VkBool32 robustBufferAccess;
  VkBool32 fullDrawIndexUint32;
  VkBool32 imageCubeArray;
  VkBool32 independentBlend;
  VkBool32 geometryShader;
  VkBool32 tessellationShader;
  VkBool32 sampleRateShading;
  VkBool32 dualSrcBlend;
  VkBool32 logicOp;
  VkBool32 multiDrawIndirect;
  VkBool32 drawIndirectFirstInstance;
  VkBool32 depthClamp;
  VkBool32 depthBiasClamp;
  VkBool32 fillModeNonSolid;
  VkBool32 depthBounds;
  VkBool32 wideLines;
  VkBool32 largePoints;
  VkBool32 alphaToOne;
  VkBool32 multiViewport;
  VkBool32 samplerAnisotropy;
  VkBool32 textureCompressionETC2;
  VkBool32 textureCompressionASTC_LDR;
  VkBool32 textureCompressionBC;
  VkBool32 occlusionQueryPrecise;
  VkBool32 pipelineStatisticsQuery;
  VkBool32 vertexPipelineStoresAndAtomics;
  VkBool32 fragmentStoresAndAtomics;
  VkBool32 shaderTessellationAndGeometryPointSize;
  VkBool32 shaderImageGatherExtended;
  VkBool32 shaderStorageImageExtendedFormats;
  VkBool32 shaderStorageImageMultisample;
  VkBool32 shaderStorageImageReadWithoutFormat;
  VkBool32 shaderStorageImageWriteWithoutFormat;
  VkBool32 shaderUniformBufferArrayDynamicIndexing;
  VkBool32 shaderSampledImageArrayDynamicIndexing;
  VkBool32 shaderStorageBufferArrayDynamicIndexing;
  VkBool32 shaderStorageImageArrayDynamicIndexing;
  VkBool32 shaderClipDistance;
  VkBool32 shaderCullDistance;
  VkBool32 shaderFloat64;
  VkBool32 shaderInt64;
  VkBool32 shaderInt16;
  VkBool32 shaderResourceResidency;
  VkBool32 shaderResourceMinLod;
  VkBool32 sparseBinding;
  VkBool32 sparseResidencyBuffer;
  VkBool32 sparseResidencyImage2D;
  VkBool32 sparseResidencyImage3D;
  VkBool32 sparseResidency2Samples;
  VkBool32 sparseResidency4Samples;
  VkBool32 sparseResidency8Samples;
  VkBool32 sparseResidency16Samples;
  VkBool32 sparseResidencyAliased;
  VkBool32 variableMultisampleRate;
  VkBool32 inheritedQueries;
}

struct VkPhysicalDeviceLimits {
  uint maxImageDimension1D;
  uint maxImageDimension2D;
  uint maxImageDimension3D;
  uint maxImageDimensionCube;
  uint maxImageArrayLayers;
  uint maxTexelBufferElements;
  uint maxUniformBufferRange;
  uint maxStorageBufferRange;
  uint maxPushConstantsSize;
  uint maxMemoryAllocationCount;
  uint maxSamplerAllocationCount;
  VkDeviceSize bufferImageGranularity;
  VkDeviceSize sparseAddressSpaceSize;
  uint maxBoundDescriptorSets;
  uint maxPerStageDescriptorSamplers;
  uint maxPerStageDescriptorUniformBuffers;
  uint maxPerStageDescriptorStorageBuffers;
  uint maxPerStageDescriptorSampledImages;
  uint maxPerStageDescriptorStorageImages;
  uint maxPerStageDescriptorInputAttachments;
  uint maxPerStageResources;
  uint maxDescriptorSetSamplers;
  uint maxDescriptorSetUniformBuffers;
  uint maxDescriptorSetUniformBuffersDynamic;
  uint maxDescriptorSetStorageBuffers;
  uint maxDescriptorSetStorageBuffersDynamic;
  uint maxDescriptorSetSampledImages;
  uint maxDescriptorSetStorageImages;
  uint maxDescriptorSetInputAttachments;
  uint maxVertexInputAttributes;
  uint maxVertexInputBindings;
  uint maxVertexInputAttributeOffset;
  uint maxVertexInputBindingStride;
  uint maxVertexOutputComponents;
  uint maxTessellationGenerationLevel;
  uint maxTessellationPatchSize;
  uint maxTessellationControlPerVertexInputComponents;
  uint maxTessellationControlPerVertexOutputComponents;
  uint maxTessellationControlPerPatchOutputComponents;
  uint maxTessellationControlTotalOutputComponents;
  uint maxTessellationEvaluationInputComponents;
  uint maxTessellationEvaluationOutputComponents;
  uint maxGeometryShaderInvocations;
  uint maxGeometryInputComponents;
  uint maxGeometryOutputComponents;
  uint maxGeometryOutputVertices;
  uint maxGeometryTotalOutputComponents;
  uint maxFragmentInputComponents;
  uint maxFragmentOutputAttachments;
  uint maxFragmentDualSrcAttachments;
  uint maxFragmentCombinedOutputResources;
  uint maxComputeSharedMemorySize;
  uint[3] maxComputeWorkGroupCount;
  uint maxComputeWorkGroupInvocations;
  uint[3] maxComputeWorkGroupSize;
  uint subPixelPrecisionBits;
  uint subTexelPrecisionBits;
  uint mipmapPrecisionBits;
  uint maxDrawIndexedIndexValue;
  uint maxDrawIndirectCount;
  float maxSamplerLodBias;
  float maxSamplerAnisotropy;
  uint maxViewports;
  uint[2] maxViewportDimensions;
  float[2] viewportBoundsRange;
  uint viewportSubPixelBits;
  usz minMemoryMapAlignment;
  VkDeviceSize minTexelBufferOffsetAlignment;
  VkDeviceSize minUniformBufferOffsetAlignment;
  VkDeviceSize minStorageBufferOffsetAlignment;
  int minTexelOffset;
  uint maxTexelOffset;
  int minTexelGatherOffset;
  uint maxTexelGatherOffset;
  float minInterpolationOffset;
  float maxInterpolationOffset;
  uint subPixelInterpolationOffsetBits;
  uint maxFramebufferWidth;
  uint maxFramebufferHeight;
  uint maxFramebufferLayers;
  VkSampleCountFlags framebufferColorSampleCounts;
  VkSampleCountFlags framebufferDepthSampleCounts;
  VkSampleCountFlags framebufferStencilSampleCounts;
  VkSampleCountFlags framebufferNoAttachmentsSampleCounts;
  uint maxColorAttachments;
  VkSampleCountFlags sampledImageColorSampleCounts;
  VkSampleCountFlags sampledImageIntegerSampleCounts;
  VkSampleCountFlags sampledImageDepthSampleCounts;
  VkSampleCountFlags sampledImageStencilSampleCounts;
  VkSampleCountFlags storageImageSampleCounts;
  uint maxSampleMaskWords;
  VkBool32 timestampComputeAndGraphics;
  float timestampPeriod;
  uint maxClipDistances;
  uint maxCullDistances;
  uint maxCombinedClipAndCullDistances;
  uint discreteQueuePriorities;
  float[2] pointSizeRange;
  float[2] lineWidthRange;
  float pointSizeGranularity;
  float lineWidthGranularity;
  VkBool32 strictLines;
  VkBool32 standardSampleLocations;
  VkDeviceSize optimalBufferCopyOffsetAlignment;
  VkDeviceSize optimalBufferCopyRowPitchAlignment;
  VkDeviceSize nonCoherentAtomSize;
}

struct VkPhysicalDeviceMemoryProperties {
  uint memoryTypeCount;
  VkMemoryType[32] memoryTypes;
  uint memoryHeapCount;
  VkMemoryHeap[16] memoryHeaps;
}

struct VkPhysicalDeviceSparseProperties {
  VkBool32 residencyStandard2DBlockShape;
  VkBool32 residencyStandard2DMultisampleBlockShape;
  VkBool32 residencyStandard3DBlockShape;
  VkBool32 residencyAlignedMipSize;
  VkBool32 residencyNonResidentStrict;
}

struct VkPhysicalDeviceProperties {
  uint apiVersion;
  uint driverVersion;
  uint vendorID;
  uint deviceID;
  VkPhysicalDeviceType deviceType;
  CChar[256] deviceName;
  char[16] pipelineCacheUUID;
  VkPhysicalDeviceLimits limits;
  VkPhysicalDeviceSparseProperties sparseProperties;
}

struct VkQueueFamilyProperties {
  VkQueueFlags queueFlags;
  uint queueCount;
  uint timestampValidBits;
  VkExtent3D minImageTransferGranularity;
}

struct VkDeviceQueueCreateInfo {
  VkStructureType sType;
  void * pNext;
  VkDeviceQueueCreateFlags flags;
  uint queueFamilyIndex;
  uint queueCount;
  float * pQueuePriorities;
}

struct VkDeviceCreateInfo {
  VkStructureType sType;
  void * pNext;
  VkDeviceCreateFlags flags;
  uint queueCreateInfoCount;
  VkDeviceQueueCreateInfo * pQueueCreateInfos;
  uint enabledLayerCount;
  CChar ** ppEnabledLayerNames;
  uint enabledExtensionCount;
  CChar ** ppEnabledExtensionNames;
  VkPhysicalDeviceFeatures * pEnabledFeatures;
}

struct VkExtensionProperties {
  CChar[256] extensionName;
  uint specVersion;
}

struct VkLayerProperties {
  CChar[256] layerName;
  uint specVersion;
  uint implementationVersion;
  CChar[256] description;
}

struct VkSubmitInfo {
  VkStructureType sType;
  void * pNext;
  uint waitSemaphoreCount;
  VkSemaphore * pWaitSemaphores;
  VkPipelineStageFlags * pWaitDstStageMask;
  uint commandBufferCount;
  VkCommandBuffer * pCommandBuffers;
  uint signalSemaphoreCount;
  VkSemaphore * pSignalSemaphores;
}

struct VkMappedMemoryRange {
  VkStructureType sType;
  void * pNext;
  VkDeviceMemory memory;
  VkDeviceSize offset;
  VkDeviceSize size;
}

struct VkMemoryAllocateInfo {
  VkStructureType sType;
  void * pNext;
  VkDeviceSize allocationSize;
  uint memoryTypeIndex;
}

struct VkMemoryRequirements {
  VkDeviceSize size;
  VkDeviceSize alignment;
  uint memoryTypeBits;
}

struct VkSparseMemoryBind {
  VkDeviceSize resourceOffset;
  VkDeviceSize size;
  VkDeviceMemory memory;
  VkDeviceSize memoryOffset;
  VkSparseMemoryBindFlags flags;
}

struct VkSparseBufferMemoryBindInfo {
  VkBuffer buffer;
  uint bindCount;
  VkSparseMemoryBind * pBinds;
}

struct VkSparseImageOpaqueMemoryBindInfo {
  VkImage image;
  uint bindCount;
  VkSparseMemoryBind * pBinds;
}

struct VkImageSubresource {
  VkImageAspectFlags aspectMask;
  uint mipLevel;
  uint arrayLayer;
}

struct VkSparseImageMemoryBind {
  VkImageSubresource subresource;
  VkOffset3D offset;
  VkExtent3D extent;
  VkDeviceMemory memory;
  VkDeviceSize memoryOffset;
  VkSparseMemoryBindFlags flags;
}

struct VkSparseImageMemoryBindInfo {
  VkImage image;
  uint bindCount;
  VkSparseImageMemoryBind * pBinds;
}

struct VkBindSparseInfo {
  VkStructureType sType;
  void * pNext;
  uint waitSemaphoreCount;
  VkSemaphore * pWaitSemaphores;
  uint bufferBindCount;
  VkSparseBufferMemoryBindInfo * pBufferBinds;
  uint imageOpaqueBindCount;
  VkSparseImageOpaqueMemoryBindInfo * pImageOpaqueBinds;
  uint imageBindCount;
  VkSparseImageMemoryBindInfo * pImageBinds;
  uint signalSemaphoreCount;
  VkSemaphore * pSignalSemaphores;
}

struct VkSparseImageFormatProperties {
  VkImageAspectFlags aspectMask;
  VkExtent3D imageGranularity;
  VkSparseImageFormatFlags flags;
}

struct VkSparseImageMemoryRequirements {
  VkSparseImageFormatProperties formatProperties;
  uint imageMipTailFirstLod;
  VkDeviceSize imageMipTailSize;
  VkDeviceSize imageMipTailOffset;
  VkDeviceSize imageMipTailStride;
}

struct VkFenceCreateInfo {
  VkStructureType sType;
  void * pNext;
  VkFenceCreateFlags flags;
}

struct VkSemaphoreCreateInfo {
  VkStructureType sType;
  void * pNext;
  VkSemaphoreCreateFlags flags;
}

struct VkEventCreateInfo {
  VkStructureType sType;
  void * pNext;
  VkEventCreateFlags flags;
}

struct VkQueryPoolCreateInfo {
  VkStructureType sType;
  void * pNext;
  VkQueryPoolCreateFlags flags;
  VkQueryType queryType;
  uint queryCount;
  VkQueryPipelineStatisticFlags pipelineStatistics;
}

struct VkBufferCreateInfo {
  VkStructureType sType;
  void * pNext;
  VkBufferCreateFlags flags;
  VkDeviceSize size;
  VkBufferUsageFlags usage;
  VkSharingMode sharingMode;
  uint queueFamilyIndexCount;
  uint * pQueueFamilyIndices;
}

struct VkBufferViewCreateInfo {
  VkStructureType sType;
  void * pNext;
  VkBufferViewCreateFlags flags;
  VkBuffer buffer;
  VkFormat format;
  VkDeviceSize offset;
  VkDeviceSize range;
}

struct VkImageCreateInfo {
  VkStructureType sType;
  void * pNext;
  VkImageCreateFlags flags;
  VkImageType imageType;
  VkFormat format;
  VkExtent3D extent;
  uint mipLevels;
  uint arrayLayers;
  VkSampleCountFlagBits samples;
  VkImageTiling tiling;
  VkImageUsageFlags usage;
  VkSharingMode sharingMode;
  uint queueFamilyIndexCount;
  uint * pQueueFamilyIndices;
  VkImageLayout initialLayout;
}

struct VkSubresourceLayout {
  VkDeviceSize offset;
  VkDeviceSize size;
  VkDeviceSize rowPitch;
  VkDeviceSize arrayPitch;
  VkDeviceSize depthPitch;
}

struct VkComponentMapping {
  VkComponentSwizzle r;
  VkComponentSwizzle g;
  VkComponentSwizzle b;
  VkComponentSwizzle a;
}

struct VkImageViewCreateInfo {
  VkStructureType sType;
  void * pNext;
  VkImageViewCreateFlags flags;
  VkImage image;
  VkImageViewType viewType;
  VkFormat format;
  VkComponentMapping components;
  VkImageSubresourceRange subresourceRange;
}

struct VkShaderModuleCreateInfo {
  VkStructureType sType;
  void * pNext;
  VkShaderModuleCreateFlags flags;
  usz codeSize;
  uint * pCode;
}

struct VkPipelineCacheCreateInfo {
  VkStructureType sType;
  void * pNext;
  VkPipelineCacheCreateFlags flags;
  usz initialDataSize;
  void * pInitialData;
}

struct VkSpecializationMapEntry {
  uint constantID;
  uint offset;
  usz size;
}

struct VkSpecializationInfo {
  uint mapEntryCount;
  VkSpecializationMapEntry * pMapEntries;
  usz dataSize;
  void * pData;
}

struct VkPipelineShaderStageCreateInfo {
  VkStructureType sType;
  void * pNext;
  VkPipelineShaderStageCreateFlags flags;
  VkShaderStageFlagBits stage;
  VkShaderModule mod;
  CChar * pName;
  VkSpecializationInfo * pSpecializationInfo;
}

struct VkComputePipelineCreateInfo {
  VkStructureType sType;
  void * pNext;
  VkPipelineCreateFlags flags;
  VkPipelineShaderStageCreateInfo stage;
  VkPipelineLayout layout;
  VkPipeline basePipelineHandle;
  int basePipelineIndex;
}

struct VkVertexInputBindingDescription {
  uint binding;
  uint stride;
  VkVertexInputRate inputRate;
}

struct VkVertexInputAttributeDescription {
  uint location;
  uint binding;
  VkFormat format;
  uint offset;
}

struct VkPipelineVertexInputStateCreateInfo {
  VkStructureType sType;
  void * pNext;
  VkPipelineVertexInputStateCreateFlags flags;
  uint vertexBindingDescriptionCount;
  VkVertexInputBindingDescription * pVertexBindingDescriptions;
  uint vertexAttributeDescriptionCount;
  VkVertexInputAttributeDescription * pVertexAttributeDescriptions;
}

struct VkPipelineInputAssemblyStateCreateInfo {
  VkStructureType sType;
  void * pNext;
  VkPipelineInputAssemblyStateCreateFlags flags;
  VkPrimitiveTopology topology;
  VkBool32 primitiveRestartEnable;
}

struct VkPipelineTessellationStateCreateInfo {
  VkStructureType sType;
  void * pNext;
  VkPipelineTessellationStateCreateFlags flags;
  uint patchControlPoints;
}

struct VkViewport {
  float x;
  float y;
  float width;
  float height;
  float minDepth;
  float maxDepth;
}

struct VkPipelineViewportStateCreateInfo {
  VkStructureType sType;
  void * pNext;
  VkPipelineViewportStateCreateFlags flags;
  uint viewportCount;
  VkViewport * pViewports;
  uint scissorCount;
  VkRect2D * pScissors;
}

struct VkPipelineRasterizationStateCreateInfo {
  VkStructureType sType;
  void * pNext;
  VkPipelineRasterizationStateCreateFlags flags;
  VkBool32 depthClampEnable;
  VkBool32 rasterizerDiscardEnable;
  VkPolygonMode polygonMode;
  VkCullModeFlags cullMode;
  VkFrontFace frontFace;
  VkBool32 depthBiasEnable;
  float depthBiasConstantFactor;
  float depthBiasClamp;
  float depthBiasSlopeFactor;
  float lineWidth;
}

struct VkPipelineMultisampleStateCreateInfo {
  VkStructureType sType;
  void * pNext;
  VkPipelineMultisampleStateCreateFlags flags;
  VkSampleCountFlagBits rasterizationSamples;
  VkBool32 sampleShadingEnable;
  float minSampleShading;
  VkSampleMask * pSampleMask;
  VkBool32 alphaToCoverageEnable;
  VkBool32 alphaToOneEnable;
}

struct VkStencilOpState {
  VkStencilOp failOp;
  VkStencilOp passOp;
  VkStencilOp depthFailOp;
  VkCompareOp compareOp;
  uint compareMask;
  uint writeMask;
  uint reference;
}

struct VkPipelineDepthStencilStateCreateInfo {
  VkStructureType sType;
  void * pNext;
  VkPipelineDepthStencilStateCreateFlags flags;
  VkBool32 depthTestEnable;
  VkBool32 depthWriteEnable;
  VkCompareOp depthCompareOp;
  VkBool32 depthBoundsTestEnable;
  VkBool32 stencilTestEnable;
  VkStencilOpState front;
  VkStencilOpState back;
  float minDepthBounds;
  float maxDepthBounds;
}

struct VkPipelineColorBlendAttachmentState {
  VkBool32 blendEnable;
  VkBlendFactor srcColorBlendFactor;
  VkBlendFactor dstColorBlendFactor;
  VkBlendOp colorBlendOp;
  VkBlendFactor srcAlphaBlendFactor;
  VkBlendFactor dstAlphaBlendFactor;
  VkBlendOp alphaBlendOp;
  VkColorComponentFlags colorWriteMask;
}

struct VkPipelineColorBlendStateCreateInfo {
  VkStructureType sType;
  void * pNext;
  VkPipelineColorBlendStateCreateFlags flags;
  VkBool32 logicOpEnable;
  VkLogicOp logicOp;
  uint attachmentCount;
  VkPipelineColorBlendAttachmentState * pAttachments;
  float[4] blendConstants;
}

struct VkPipelineDynamicStateCreateInfo {
  VkStructureType sType;
  void * pNext;
  VkPipelineDynamicStateCreateFlags flags;
  uint dynamicStateCount;
  VkDynamicState * pDynamicStates;
}

struct VkGraphicsPipelineCreateInfo {
  VkStructureType sType;
  void * pNext;
  VkPipelineCreateFlags flags;
  uint stageCount;
  VkPipelineShaderStageCreateInfo * pStages;
  VkPipelineVertexInputStateCreateInfo * pVertexInputState;
  VkPipelineInputAssemblyStateCreateInfo * pInputAssemblyState;
  VkPipelineTessellationStateCreateInfo * pTessellationState;
  VkPipelineViewportStateCreateInfo * pViewportState;
  VkPipelineRasterizationStateCreateInfo * pRasterizationState;
  VkPipelineMultisampleStateCreateInfo * pMultisampleState;
  VkPipelineDepthStencilStateCreateInfo * pDepthStencilState;
  VkPipelineColorBlendStateCreateInfo * pColorBlendState;
  VkPipelineDynamicStateCreateInfo * pDynamicState;
  VkPipelineLayout layout;
  VkRenderPass renderPass;
  uint subpass;
  VkPipeline basePipelineHandle;
  int basePipelineIndex;
}

struct VkPushConstantRange {
  VkShaderStageFlags stageFlags;
  uint offset;
  uint size;
}

struct VkPipelineLayoutCreateInfo {
  VkStructureType sType;
  void * pNext;
  VkPipelineLayoutCreateFlags flags;
  uint setLayoutCount;
  VkDescriptorSetLayout * pSetLayouts;
  uint pushConstantRangeCount;
  VkPushConstantRange * pPushConstantRanges;
}

struct VkSamplerCreateInfo {
  VkStructureType sType;
  void * pNext;
  VkSamplerCreateFlags flags;
  VkFilter magFilter;
  VkFilter minFilter;
  VkSamplerMipmapMode mipmapMode;
  VkSamplerAddressMode addressModeU;
  VkSamplerAddressMode addressModeV;
  VkSamplerAddressMode addressModeW;
  float mipLodBias;
  VkBool32 anisotropyEnable;
  float maxAnisotropy;
  VkBool32 compareEnable;
  VkCompareOp compareOp;
  float minLod;
  float maxLod;
  VkBorderColor borderColor;
  VkBool32 unnormalizedCoordinates;
}

struct VkCopyDescriptorSet {
  VkStructureType sType;
  void * pNext;
  VkDescriptorSet srcSet;
  uint srcBinding;
  uint srcArrayElement;
  VkDescriptorSet dstSet;
  uint dstBinding;
  uint dstArrayElement;
  uint descriptorCount;
}

struct VkDescriptorBufferInfo {
  VkBuffer buffer;
  VkDeviceSize offset;
  VkDeviceSize range;
}

struct VkDescriptorImageInfo {
  VkSampler sampler;
  VkImageView imageView;
  VkImageLayout imageLayout;
}

struct VkDescriptorPoolSize {
  VkDescriptorType type;
  uint descriptorCount;
}

struct VkDescriptorPoolCreateInfo {
  VkStructureType sType;
  void * pNext;
  VkDescriptorPoolCreateFlags flags;
  uint maxSets;
  uint poolSizeCount;
  VkDescriptorPoolSize * pPoolSizes;
}

struct VkDescriptorSetAllocateInfo {
  VkStructureType sType;
  void * pNext;
  VkDescriptorPool descriptorPool;
  uint descriptorSetCount;
  VkDescriptorSetLayout * pSetLayouts;
}

struct VkDescriptorSetLayoutBinding {
  uint binding;
  VkDescriptorType descriptorType;
  uint descriptorCount;
  VkShaderStageFlags stageFlags;
  VkSampler * pImmutableSamplers;
}

struct VkDescriptorSetLayoutCreateInfo {
  VkStructureType sType;
  void * pNext;
  VkDescriptorSetLayoutCreateFlags flags;
  uint bindingCount;
  VkDescriptorSetLayoutBinding * pBindings;
}

struct VkWriteDescriptorSet {
  VkStructureType sType;
  void * pNext;
  VkDescriptorSet dstSet;
  uint dstBinding;
  uint dstArrayElement;
  uint descriptorCount;
  VkDescriptorType descriptorType;
  VkDescriptorImageInfo * pImageInfo;
  VkDescriptorBufferInfo * pBufferInfo;
  VkBufferView * pTexelBufferView;
}

struct VkAttachmentDescription {
  VkAttachmentDescriptionFlags flags;
  VkFormat format;
  VkSampleCountFlagBits samples;
  VkAttachmentLoadOp loadOp;
  VkAttachmentStoreOp storeOp;
  VkAttachmentLoadOp stencilLoadOp;
  VkAttachmentStoreOp stencilStoreOp;
  VkImageLayout initialLayout;
  VkImageLayout finalLayout;
}

struct VkAttachmentReference {
  uint attachment;
  VkImageLayout layout;
}

struct VkFramebufferCreateInfo {
  VkStructureType sType;
  void * pNext;
  VkFramebufferCreateFlags flags;
  VkRenderPass renderPass;
  uint attachmentCount;
  VkImageView * pAttachments;
  uint width;
  uint height;
  uint layers;
}

struct VkSubpassDescription {
  VkSubpassDescriptionFlags flags;
  VkPipelineBindPoint pipelineBindPoint;
  uint inputAttachmentCount;
  VkAttachmentReference * pInputAttachments;
  uint colorAttachmentCount;
  VkAttachmentReference * pColorAttachments;
  VkAttachmentReference * pResolveAttachments;
  VkAttachmentReference * pDepthStencilAttachment;
  uint preserveAttachmentCount;
  uint * pPreserveAttachments;
}

struct VkSubpassDependency {
  uint srcSubpass;
  uint dstSubpass;
  VkPipelineStageFlags srcStageMask;
  VkPipelineStageFlags dstStageMask;
  VkAccessFlags srcAccessMask;
  VkAccessFlags dstAccessMask;
  VkDependencyFlags dependencyFlags;
}

struct VkRenderPassCreateInfo {
  VkStructureType sType;
  void * pNext;
  VkRenderPassCreateFlags flags;
  uint attachmentCount;
  VkAttachmentDescription * pAttachments;
  uint subpassCount;
  VkSubpassDescription * pSubpasses;
  uint dependencyCount;
  VkSubpassDependency * pDependencies;
}

struct VkCommandPoolCreateInfo {
  VkStructureType sType;
  void * pNext;
  VkCommandPoolCreateFlags flags;
  uint queueFamilyIndex;
}

struct VkCommandBufferAllocateInfo {
  VkStructureType sType;
  void * pNext;
  VkCommandPool commandPool;
  VkCommandBufferLevel level;
  uint commandBufferCount;
}

struct VkCommandBufferInheritanceInfo {
  VkStructureType sType;
  void * pNext;
  VkRenderPass renderPass;
  uint subpass;
  VkFramebuffer framebuffer;
  VkBool32 occlusionQueryEnable;
  VkQueryControlFlags queryFlags;
  VkQueryPipelineStatisticFlags pipelineStatistics;
}

struct VkCommandBufferBeginInfo {
  VkStructureType sType;
  void * pNext;
  VkCommandBufferUsageFlags flags;
  VkCommandBufferInheritanceInfo * pInheritanceInfo;
}

struct VkBufferCopy {
  VkDeviceSize srcOffset;
  VkDeviceSize dstOffset;
  VkDeviceSize size;
}

struct VkImageSubresourceLayers {
  VkImageAspectFlags aspectMask;
  uint mipLevel;
  uint baseArrayLayer;
  uint layerCount;
}

struct VkBufferImageCopy {
  VkDeviceSize bufferOffset;
  uint bufferRowLength;
  uint bufferImageHeight;
  VkImageSubresourceLayers imageSubresource;
  VkOffset3D imageOffset;
  VkExtent3D imageExtent;
}

union VkClearColorValue {
  float[4] float32;
  int[4] int32;
  uint[4] uint32;
}

struct VkClearDepthStencilValue {
  float depth;
  uint stencil;
}

union VkClearValue {
  VkClearColorValue color;
  VkClearDepthStencilValue depthStencil;
}

struct VkClearAttachment {
  VkImageAspectFlags aspectMask;
  uint colorAttachment;
  VkClearValue clearValue;
}

struct VkClearRect {
  VkRect2D rect;
  uint baseArrayLayer;
  uint layerCount;
}

struct VkImageBlit {
  VkImageSubresourceLayers srcSubresource;
  VkOffset3D[2] srcOffsets;
  VkImageSubresourceLayers dstSubresource;
  VkOffset3D[2] dstOffsets;
}

struct VkImageCopy {
  VkImageSubresourceLayers srcSubresource;
  VkOffset3D srcOffset;
  VkImageSubresourceLayers dstSubresource;
  VkOffset3D dstOffset;
  VkExtent3D extent;
}

struct VkImageResolve {
  VkImageSubresourceLayers srcSubresource;
  VkOffset3D srcOffset;
  VkImageSubresourceLayers dstSubresource;
  VkOffset3D dstOffset;
  VkExtent3D extent;
}

struct VkRenderPassBeginInfo {
  VkStructureType sType;
  void * pNext;
  VkRenderPass renderPass;
  VkFramebuffer framebuffer;
  VkRect2D renderArea;
  uint clearValueCount;
  VkClearValue * pClearValues;
}

alias PFN_vkCreateInstance = fn VkResult(
  VkInstanceCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkInstance * pInstance);

alias PFN_vkDestroyInstance = fn void(
  VkInstance instance, 
  VkAllocationCallbacks * pAllocator);

alias PFN_vkEnumeratePhysicalDevices = fn VkResult(
  VkInstance instance, 
  uint * pPhysicalDeviceCount, 
  VkPhysicalDevice * pPhysicalDevices);

alias PFN_vkGetPhysicalDeviceFeatures = fn void(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceFeatures * pFeatures);

alias PFN_vkGetPhysicalDeviceFormatProperties = fn void(
  VkPhysicalDevice physicalDevice, 
  VkFormat format, 
  VkFormatProperties * pFormatProperties);

alias PFN_vkGetPhysicalDeviceImageFormatProperties = fn VkResult(
  VkPhysicalDevice physicalDevice, 
  VkFormat format, 
  VkImageType type, 
  VkImageTiling tiling, 
  VkImageUsageFlags usage, 
  VkImageCreateFlags flags, 
  VkImageFormatProperties * pImageFormatProperties);

alias PFN_vkGetPhysicalDeviceProperties = fn void(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceProperties * pProperties);

alias PFN_vkGetPhysicalDeviceQueueFamilyProperties = fn void(
  VkPhysicalDevice physicalDevice, 
  uint * pQueueFamilyPropertyCount, 
  VkQueueFamilyProperties * pQueueFamilyProperties);

alias PFN_vkGetPhysicalDeviceMemoryProperties = fn void(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceMemoryProperties * pMemoryProperties);

alias PFN_vkGetInstanceProcAddr = fn PFN_vkVoidFunction(
  VkInstance instance, 
  CChar * pName);

alias PFN_vkGetDeviceProcAddr = fn PFN_vkVoidFunction(
  VkDevice device, 
  CChar * pName);

alias PFN_vkCreateDevice = fn VkResult(
  VkPhysicalDevice physicalDevice, 
  VkDeviceCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkDevice * pDevice);

alias PFN_vkDestroyDevice = fn void(
  VkDevice device, 
  VkAllocationCallbacks * pAllocator);

alias PFN_vkEnumerateInstanceExtensionProperties = fn VkResult(
  CChar * pLayerName, 
  uint * pPropertyCount, 
  VkExtensionProperties * pProperties);

alias PFN_vkEnumerateDeviceExtensionProperties = fn VkResult(
  VkPhysicalDevice physicalDevice, 
  CChar * pLayerName, 
  uint * pPropertyCount, 
  VkExtensionProperties * pProperties);

alias PFN_vkEnumerateInstanceLayerProperties = fn VkResult(
  uint * pPropertyCount, 
  VkLayerProperties * pProperties);

alias PFN_vkEnumerateDeviceLayerProperties = fn VkResult(
  VkPhysicalDevice physicalDevice, 
  uint * pPropertyCount, 
  VkLayerProperties * pProperties);

alias PFN_vkGetDeviceQueue = fn void(
  VkDevice device, 
  uint queueFamilyIndex, 
  uint queueIndex, 
  VkQueue * pQueue);

alias PFN_vkQueueSubmit = fn VkResult(
  VkQueue queue, 
  uint submitCount, 
  VkSubmitInfo * pSubmits, 
  VkFence fence);

alias PFN_vkQueueWaitIdle = fn VkResult(  VkQueue queue);

alias PFN_vkDeviceWaitIdle = fn VkResult(  VkDevice device);

alias PFN_vkAllocateMemory = fn VkResult(
  VkDevice device, 
  VkMemoryAllocateInfo * pAllocateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkDeviceMemory * pMemory);

alias PFN_vkFreeMemory = fn void(
  VkDevice device, 
  VkDeviceMemory memory, 
  VkAllocationCallbacks * pAllocator);

alias PFN_vkMapMemory = fn VkResult(
  VkDevice device, 
  VkDeviceMemory memory, 
  VkDeviceSize offset, 
  VkDeviceSize size, 
  VkMemoryMapFlags flags, 
  void ** ppData);

alias PFN_vkUnmapMemory = fn void(
  VkDevice device, 
  VkDeviceMemory memory);

alias PFN_vkFlushMappedMemoryRanges = fn VkResult(
  VkDevice device, 
  uint memoryRangeCount, 
  VkMappedMemoryRange * pMemoryRanges);

alias PFN_vkInvalidateMappedMemoryRanges = fn VkResult(
  VkDevice device, 
  uint memoryRangeCount, 
  VkMappedMemoryRange * pMemoryRanges);

alias PFN_vkGetDeviceMemoryCommitment = fn void(
  VkDevice device, 
  VkDeviceMemory memory, 
  VkDeviceSize * pCommittedMemoryInBytes);

alias PFN_vkBindBufferMemory = fn VkResult(
  VkDevice device, 
  VkBuffer buffer, 
  VkDeviceMemory memory, 
  VkDeviceSize memoryOffset);

alias PFN_vkBindImageMemory = fn VkResult(
  VkDevice device, 
  VkImage image, 
  VkDeviceMemory memory, 
  VkDeviceSize memoryOffset);

alias PFN_vkGetBufferMemoryRequirements = fn void(
  VkDevice device, 
  VkBuffer buffer, 
  VkMemoryRequirements * pMemoryRequirements);

alias PFN_vkGetImageMemoryRequirements = fn void(
  VkDevice device, 
  VkImage image, 
  VkMemoryRequirements * pMemoryRequirements);

alias PFN_vkGetImageSparseMemoryRequirements = fn void(
  VkDevice device, 
  VkImage image, 
  uint * pSparseMemoryRequirementCount, 
  VkSparseImageMemoryRequirements * pSparseMemoryRequirements);

alias PFN_vkGetPhysicalDeviceSparseImageFormatProperties = fn void(
  VkPhysicalDevice physicalDevice, 
  VkFormat format, 
  VkImageType type, 
  VkSampleCountFlagBits samples, 
  VkImageUsageFlags usage, 
  VkImageTiling tiling, 
  uint * pPropertyCount, 
  VkSparseImageFormatProperties * pProperties);

alias PFN_vkQueueBindSparse = fn VkResult(
  VkQueue queue, 
  uint bindInfoCount, 
  VkBindSparseInfo * pBindInfo, 
  VkFence fence);

alias PFN_vkCreateFence = fn VkResult(
  VkDevice device, 
  VkFenceCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkFence * pFence);

alias PFN_vkDestroyFence = fn void(
  VkDevice device, 
  VkFence fence, 
  VkAllocationCallbacks * pAllocator);

alias PFN_vkResetFences = fn VkResult(
  VkDevice device, 
  uint fenceCount, 
  VkFence * pFences);

alias PFN_vkGetFenceStatus = fn VkResult(
  VkDevice device, 
  VkFence fence);

alias PFN_vkWaitForFences = fn VkResult(
  VkDevice device, 
  uint fenceCount, 
  VkFence * pFences, 
  VkBool32 waitAll, 
  ulong timeout);

alias PFN_vkCreateSemaphore = fn VkResult(
  VkDevice device, 
  VkSemaphoreCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkSemaphore * pSemaphore);

alias PFN_vkDestroySemaphore = fn void(
  VkDevice device, 
  VkSemaphore semaphore, 
  VkAllocationCallbacks * pAllocator);

alias PFN_vkCreateEvent = fn VkResult(
  VkDevice device, 
  VkEventCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkEvent * pEvent);

alias PFN_vkDestroyEvent = fn void(
  VkDevice device, 
  VkEvent event, 
  VkAllocationCallbacks * pAllocator);

alias PFN_vkGetEventStatus = fn VkResult(
  VkDevice device, 
  VkEvent event);

alias PFN_vkSetEvent = fn VkResult(
  VkDevice device, 
  VkEvent event);

alias PFN_vkResetEvent = fn VkResult(
  VkDevice device, 
  VkEvent event);

alias PFN_vkCreateQueryPool = fn VkResult(
  VkDevice device, 
  VkQueryPoolCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkQueryPool * pQueryPool);

alias PFN_vkDestroyQueryPool = fn void(
  VkDevice device, 
  VkQueryPool queryPool, 
  VkAllocationCallbacks * pAllocator);

alias PFN_vkGetQueryPoolResults = fn VkResult(
  VkDevice device, 
  VkQueryPool queryPool, 
  uint firstQuery, 
  uint queryCount, 
  usz dataSize, 
  void * pData, 
  VkDeviceSize stride, 
  VkQueryResultFlags flags);

alias PFN_vkCreateBuffer = fn VkResult(
  VkDevice device, 
  VkBufferCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkBuffer * pBuffer);

alias PFN_vkDestroyBuffer = fn void(
  VkDevice device, 
  VkBuffer buffer, 
  VkAllocationCallbacks * pAllocator);

alias PFN_vkCreateBufferView = fn VkResult(
  VkDevice device, 
  VkBufferViewCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkBufferView * pView);

alias PFN_vkDestroyBufferView = fn void(
  VkDevice device, 
  VkBufferView bufferView, 
  VkAllocationCallbacks * pAllocator);

alias PFN_vkCreateImage = fn VkResult(
  VkDevice device, 
  VkImageCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkImage * pImage);

alias PFN_vkDestroyImage = fn void(
  VkDevice device, 
  VkImage image, 
  VkAllocationCallbacks * pAllocator);

alias PFN_vkGetImageSubresourceLayout = fn void(
  VkDevice device, 
  VkImage image, 
  VkImageSubresource * pSubresource, 
  VkSubresourceLayout * pLayout);

alias PFN_vkCreateImageView = fn VkResult(
  VkDevice device, 
  VkImageViewCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkImageView * pView);

alias PFN_vkDestroyImageView = fn void(
  VkDevice device, 
  VkImageView imageView, 
  VkAllocationCallbacks * pAllocator);

alias PFN_vkCreateShaderModule = fn VkResult(
  VkDevice device, 
  VkShaderModuleCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkShaderModule * pShaderModule);

alias PFN_vkDestroyShaderModule = fn void(
  VkDevice device, 
  VkShaderModule shaderModule, 
  VkAllocationCallbacks * pAllocator);

alias PFN_vkCreatePipelineCache = fn VkResult(
  VkDevice device, 
  VkPipelineCacheCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkPipelineCache * pPipelineCache);

alias PFN_vkDestroyPipelineCache = fn void(
  VkDevice device, 
  VkPipelineCache pipelineCache, 
  VkAllocationCallbacks * pAllocator);

alias PFN_vkGetPipelineCacheData = fn VkResult(
  VkDevice device, 
  VkPipelineCache pipelineCache, 
  usz * pDataSize, 
  void * pData);

alias PFN_vkMergePipelineCaches = fn VkResult(
  VkDevice device, 
  VkPipelineCache dstCache, 
  uint srcCacheCount, 
  VkPipelineCache * pSrcCaches);

alias PFN_vkCreateGraphicsPipelines = fn VkResult(
  VkDevice device, 
  VkPipelineCache pipelineCache, 
  uint createInfoCount, 
  VkGraphicsPipelineCreateInfo * pCreateInfos, 
  VkAllocationCallbacks * pAllocator, 
  VkPipeline * pPipelines);

alias PFN_vkCreateComputePipelines = fn VkResult(
  VkDevice device, 
  VkPipelineCache pipelineCache, 
  uint createInfoCount, 
  VkComputePipelineCreateInfo * pCreateInfos, 
  VkAllocationCallbacks * pAllocator, 
  VkPipeline * pPipelines);

alias PFN_vkDestroyPipeline = fn void(
  VkDevice device, 
  VkPipeline pipeline, 
  VkAllocationCallbacks * pAllocator);

alias PFN_vkCreatePipelineLayout = fn VkResult(
  VkDevice device, 
  VkPipelineLayoutCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkPipelineLayout * pPipelineLayout);

alias PFN_vkDestroyPipelineLayout = fn void(
  VkDevice device, 
  VkPipelineLayout pipelineLayout, 
  VkAllocationCallbacks * pAllocator);

alias PFN_vkCreateSampler = fn VkResult(
  VkDevice device, 
  VkSamplerCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkSampler * pSampler);

alias PFN_vkDestroySampler = fn void(
  VkDevice device, 
  VkSampler sampler, 
  VkAllocationCallbacks * pAllocator);

alias PFN_vkCreateDescriptorSetLayout = fn VkResult(
  VkDevice device, 
  VkDescriptorSetLayoutCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkDescriptorSetLayout * pSetLayout);

alias PFN_vkDestroyDescriptorSetLayout = fn void(
  VkDevice device, 
  VkDescriptorSetLayout descriptorSetLayout, 
  VkAllocationCallbacks * pAllocator);

alias PFN_vkCreateDescriptorPool = fn VkResult(
  VkDevice device, 
  VkDescriptorPoolCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkDescriptorPool * pDescriptorPool);

alias PFN_vkDestroyDescriptorPool = fn void(
  VkDevice device, 
  VkDescriptorPool descriptorPool, 
  VkAllocationCallbacks * pAllocator);

alias PFN_vkResetDescriptorPool = fn VkResult(
  VkDevice device, 
  VkDescriptorPool descriptorPool, 
  VkDescriptorPoolResetFlags flags);

alias PFN_vkAllocateDescriptorSets = fn VkResult(
  VkDevice device, 
  VkDescriptorSetAllocateInfo * pAllocateInfo, 
  VkDescriptorSet * pDescriptorSets);

alias PFN_vkFreeDescriptorSets = fn VkResult(
  VkDevice device, 
  VkDescriptorPool descriptorPool, 
  uint descriptorSetCount, 
  VkDescriptorSet * pDescriptorSets);

alias PFN_vkUpdateDescriptorSets = fn void(
  VkDevice device, 
  uint descriptorWriteCount, 
  VkWriteDescriptorSet * pDescriptorWrites, 
  uint descriptorCopyCount, 
  VkCopyDescriptorSet * pDescriptorCopies);

alias PFN_vkCreateFramebuffer = fn VkResult(
  VkDevice device, 
  VkFramebufferCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkFramebuffer * pFramebuffer);

alias PFN_vkDestroyFramebuffer = fn void(
  VkDevice device, 
  VkFramebuffer framebuffer, 
  VkAllocationCallbacks * pAllocator);

alias PFN_vkCreateRenderPass = fn VkResult(
  VkDevice device, 
  VkRenderPassCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkRenderPass * pRenderPass);

alias PFN_vkDestroyRenderPass = fn void(
  VkDevice device, 
  VkRenderPass renderPass, 
  VkAllocationCallbacks * pAllocator);

alias PFN_vkGetRenderAreaGranularity = fn void(
  VkDevice device, 
  VkRenderPass renderPass, 
  VkExtent2D * pGranularity);

alias PFN_vkCreateCommandPool = fn VkResult(
  VkDevice device, 
  VkCommandPoolCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkCommandPool * pCommandPool);

alias PFN_vkDestroyCommandPool = fn void(
  VkDevice device, 
  VkCommandPool commandPool, 
  VkAllocationCallbacks * pAllocator);

alias PFN_vkResetCommandPool = fn VkResult(
  VkDevice device, 
  VkCommandPool commandPool, 
  VkCommandPoolResetFlags flags);

alias PFN_vkAllocateCommandBuffers = fn VkResult(
  VkDevice device, 
  VkCommandBufferAllocateInfo * pAllocateInfo, 
  VkCommandBuffer * pCommandBuffers);

alias PFN_vkFreeCommandBuffers = fn void(
  VkDevice device, 
  VkCommandPool commandPool, 
  uint commandBufferCount, 
  VkCommandBuffer * pCommandBuffers);

alias PFN_vkBeginCommandBuffer = fn VkResult(
  VkCommandBuffer commandBuffer, 
  VkCommandBufferBeginInfo * pBeginInfo);

alias PFN_vkEndCommandBuffer = fn VkResult(  VkCommandBuffer commandBuffer);

alias PFN_vkResetCommandBuffer = fn VkResult(
  VkCommandBuffer commandBuffer, 
  VkCommandBufferResetFlags flags);

alias PFN_vkCmdBindPipeline = fn void(
  VkCommandBuffer commandBuffer, 
  VkPipelineBindPoint pipelineBindPoint, 
  VkPipeline pipeline);

alias PFN_vkCmdSetViewport = fn void(
  VkCommandBuffer commandBuffer, 
  uint firstViewport, 
  uint viewportCount, 
  VkViewport * pViewports);

alias PFN_vkCmdSetScissor = fn void(
  VkCommandBuffer commandBuffer, 
  uint firstScissor, 
  uint scissorCount, 
  VkRect2D * pScissors);

alias PFN_vkCmdSetLineWidth = fn void(
  VkCommandBuffer commandBuffer, 
  float lineWidth);

alias PFN_vkCmdSetDepthBias = fn void(
  VkCommandBuffer commandBuffer, 
  float depthBiasConstantFactor, 
  float depthBiasClamp, 
  float depthBiasSlopeFactor);

alias PFN_vkCmdSetBlendConstants = fn void(
  VkCommandBuffer commandBuffer, 
  float[4] blendConstants);

alias PFN_vkCmdSetDepthBounds = fn void(
  VkCommandBuffer commandBuffer, 
  float minDepthBounds, 
  float maxDepthBounds);

alias PFN_vkCmdSetStencilCompareMask = fn void(
  VkCommandBuffer commandBuffer, 
  VkStencilFaceFlags faceMask, 
  uint compareMask);

alias PFN_vkCmdSetStencilWriteMask = fn void(
  VkCommandBuffer commandBuffer, 
  VkStencilFaceFlags faceMask, 
  uint writeMask);

alias PFN_vkCmdSetStencilReference = fn void(
  VkCommandBuffer commandBuffer, 
  VkStencilFaceFlags faceMask, 
  uint reference);

alias PFN_vkCmdBindDescriptorSets = fn void(
  VkCommandBuffer commandBuffer, 
  VkPipelineBindPoint pipelineBindPoint, 
  VkPipelineLayout layout, 
  uint firstSet, 
  uint descriptorSetCount, 
  VkDescriptorSet * pDescriptorSets, 
  uint dynamicOffsetCount, 
  uint * pDynamicOffsets);

alias PFN_vkCmdBindIndexBuffer = fn void(
  VkCommandBuffer commandBuffer, 
  VkBuffer buffer, 
  VkDeviceSize offset, 
  VkIndexType indexType);

alias PFN_vkCmdBindVertexBuffers = fn void(
  VkCommandBuffer commandBuffer, 
  uint firstBinding, 
  uint bindingCount, 
  VkBuffer * pBuffers, 
  VkDeviceSize * pOffsets);

alias PFN_vkCmdDraw = fn void(
  VkCommandBuffer commandBuffer, 
  uint vertexCount, 
  uint instanceCount, 
  uint firstVertex, 
  uint firstInstance);

alias PFN_vkCmdDrawIndexed = fn void(
  VkCommandBuffer commandBuffer, 
  uint indexCount, 
  uint instanceCount, 
  uint firstIndex, 
  int vertexOffset, 
  uint firstInstance);

alias PFN_vkCmdDrawIndirect = fn void(
  VkCommandBuffer commandBuffer, 
  VkBuffer buffer, 
  VkDeviceSize offset, 
  uint drawCount, 
  uint stride);

alias PFN_vkCmdDrawIndexedIndirect = fn void(
  VkCommandBuffer commandBuffer, 
  VkBuffer buffer, 
  VkDeviceSize offset, 
  uint drawCount, 
  uint stride);

alias PFN_vkCmdDispatch = fn void(
  VkCommandBuffer commandBuffer, 
  uint groupCountX, 
  uint groupCountY, 
  uint groupCountZ);

alias PFN_vkCmdDispatchIndirect = fn void(
  VkCommandBuffer commandBuffer, 
  VkBuffer buffer, 
  VkDeviceSize offset);

alias PFN_vkCmdCopyBuffer = fn void(
  VkCommandBuffer commandBuffer, 
  VkBuffer srcBuffer, 
  VkBuffer dstBuffer, 
  uint regionCount, 
  VkBufferCopy * pRegions);

alias PFN_vkCmdCopyImage = fn void(
  VkCommandBuffer commandBuffer, 
  VkImage srcImage, 
  VkImageLayout srcImageLayout, 
  VkImage dstImage, 
  VkImageLayout dstImageLayout, 
  uint regionCount, 
  VkImageCopy * pRegions);

alias PFN_vkCmdBlitImage = fn void(
  VkCommandBuffer commandBuffer, 
  VkImage srcImage, 
  VkImageLayout srcImageLayout, 
  VkImage dstImage, 
  VkImageLayout dstImageLayout, 
  uint regionCount, 
  VkImageBlit * pRegions, 
  VkFilter filter);

alias PFN_vkCmdCopyBufferToImage = fn void(
  VkCommandBuffer commandBuffer, 
  VkBuffer srcBuffer, 
  VkImage dstImage, 
  VkImageLayout dstImageLayout, 
  uint regionCount, 
  VkBufferImageCopy * pRegions);

alias PFN_vkCmdCopyImageToBuffer = fn void(
  VkCommandBuffer commandBuffer, 
  VkImage srcImage, 
  VkImageLayout srcImageLayout, 
  VkBuffer dstBuffer, 
  uint regionCount, 
  VkBufferImageCopy * pRegions);

alias PFN_vkCmdUpdateBuffer = fn void(
  VkCommandBuffer commandBuffer, 
  VkBuffer dstBuffer, 
  VkDeviceSize dstOffset, 
  VkDeviceSize dataSize, 
  void * pData);

alias PFN_vkCmdFillBuffer = fn void(
  VkCommandBuffer commandBuffer, 
  VkBuffer dstBuffer, 
  VkDeviceSize dstOffset, 
  VkDeviceSize size, 
  uint data);

alias PFN_vkCmdClearColorImage = fn void(
  VkCommandBuffer commandBuffer, 
  VkImage image, 
  VkImageLayout imageLayout, 
  VkClearColorValue * pColor, 
  uint rangeCount, 
  VkImageSubresourceRange * pRanges);

alias PFN_vkCmdClearDepthStencilImage = fn void(
  VkCommandBuffer commandBuffer, 
  VkImage image, 
  VkImageLayout imageLayout, 
  VkClearDepthStencilValue * pDepthStencil, 
  uint rangeCount, 
  VkImageSubresourceRange * pRanges);

alias PFN_vkCmdClearAttachments = fn void(
  VkCommandBuffer commandBuffer, 
  uint attachmentCount, 
  VkClearAttachment * pAttachments, 
  uint rectCount, 
  VkClearRect * pRects);

alias PFN_vkCmdResolveImage = fn void(
  VkCommandBuffer commandBuffer, 
  VkImage srcImage, 
  VkImageLayout srcImageLayout, 
  VkImage dstImage, 
  VkImageLayout dstImageLayout, 
  uint regionCount, 
  VkImageResolve * pRegions);

alias PFN_vkCmdSetEvent = fn void(
  VkCommandBuffer commandBuffer, 
  VkEvent event, 
  VkPipelineStageFlags stageMask);

alias PFN_vkCmdResetEvent = fn void(
  VkCommandBuffer commandBuffer, 
  VkEvent event, 
  VkPipelineStageFlags stageMask);

alias PFN_vkCmdWaitEvents = fn void(
  VkCommandBuffer commandBuffer, 
  uint eventCount, 
  VkEvent * pEvents, 
  VkPipelineStageFlags srcStageMask, 
  VkPipelineStageFlags dstStageMask, 
  uint memoryBarrierCount, 
  VkMemoryBarrier * pMemoryBarriers, 
  uint bufferMemoryBarrierCount, 
  VkBufferMemoryBarrier * pBufferMemoryBarriers, 
  uint imageMemoryBarrierCount, 
  VkImageMemoryBarrier * pImageMemoryBarriers);

alias PFN_vkCmdPipelineBarrier = fn void(
  VkCommandBuffer commandBuffer, 
  VkPipelineStageFlags srcStageMask, 
  VkPipelineStageFlags dstStageMask, 
  VkDependencyFlags dependencyFlags, 
  uint memoryBarrierCount, 
  VkMemoryBarrier * pMemoryBarriers, 
  uint bufferMemoryBarrierCount, 
  VkBufferMemoryBarrier * pBufferMemoryBarriers, 
  uint imageMemoryBarrierCount, 
  VkImageMemoryBarrier * pImageMemoryBarriers);

alias PFN_vkCmdBeginQuery = fn void(
  VkCommandBuffer commandBuffer, 
  VkQueryPool queryPool, 
  uint query, 
  VkQueryControlFlags flags);

alias PFN_vkCmdEndQuery = fn void(
  VkCommandBuffer commandBuffer, 
  VkQueryPool queryPool, 
  uint query);

alias PFN_vkCmdResetQueryPool = fn void(
  VkCommandBuffer commandBuffer, 
  VkQueryPool queryPool, 
  uint firstQuery, 
  uint queryCount);

alias PFN_vkCmdWriteTimestamp = fn void(
  VkCommandBuffer commandBuffer, 
  VkPipelineStageFlagBits pipelineStage, 
  VkQueryPool queryPool, 
  uint query);

alias PFN_vkCmdCopyQueryPoolResults = fn void(
  VkCommandBuffer commandBuffer, 
  VkQueryPool queryPool, 
  uint firstQuery, 
  uint queryCount, 
  VkBuffer dstBuffer, 
  VkDeviceSize dstOffset, 
  VkDeviceSize stride, 
  VkQueryResultFlags flags);

alias PFN_vkCmdPushConstants = fn void(
  VkCommandBuffer commandBuffer, 
  VkPipelineLayout layout, 
  VkShaderStageFlags stageFlags, 
  uint offset, 
  uint size, 
  void * pValues);

alias PFN_vkCmdBeginRenderPass = fn void(
  VkCommandBuffer commandBuffer, 
  VkRenderPassBeginInfo * pRenderPassBegin, 
  VkSubpassContents contents);

alias PFN_vkCmdNextSubpass = fn void(
  VkCommandBuffer commandBuffer, 
  VkSubpassContents contents);

alias PFN_vkCmdEndRenderPass = fn void(  VkCommandBuffer commandBuffer);

alias PFN_vkCmdExecuteCommands = fn void(
  VkCommandBuffer commandBuffer, 
  uint commandBufferCount, 
  VkCommandBuffer * pCommandBuffers);

fn VkResult createInstance(
  VkInstanceCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkInstance * pInstance)
@extern("vkCreateInstance");

fn void destroyInstance(
  VkInstance instance, 
  VkAllocationCallbacks * pAllocator)
@extern("vkDestroyInstance");

fn VkResult enumeratePhysicalDevices(
  VkInstance instance, 
  uint * pPhysicalDeviceCount, 
  VkPhysicalDevice * pPhysicalDevices)
@extern("vkEnumeratePhysicalDevices");

fn void getPhysicalDeviceFeatures(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceFeatures * pFeatures)
@extern("vkGetPhysicalDeviceFeatures");

fn void getPhysicalDeviceFormatProperties(
  VkPhysicalDevice physicalDevice, 
  VkFormat format, 
  VkFormatProperties * pFormatProperties)
@extern("vkGetPhysicalDeviceFormatProperties");

fn VkResult getPhysicalDeviceImageFormatProperties(
  VkPhysicalDevice physicalDevice, 
  VkFormat format, 
  VkImageType type, 
  VkImageTiling tiling, 
  VkImageUsageFlags usage, 
  VkImageCreateFlags flags, 
  VkImageFormatProperties * pImageFormatProperties)
@extern("vkGetPhysicalDeviceImageFormatProperties");

fn void getPhysicalDeviceProperties(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceProperties * pProperties)
@extern("vkGetPhysicalDeviceProperties");

fn void getPhysicalDeviceQueueFamilyProperties(
  VkPhysicalDevice physicalDevice, 
  uint * pQueueFamilyPropertyCount, 
  VkQueueFamilyProperties * pQueueFamilyProperties)
@extern("vkGetPhysicalDeviceQueueFamilyProperties");

fn void getPhysicalDeviceMemoryProperties(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceMemoryProperties * pMemoryProperties)
@extern("vkGetPhysicalDeviceMemoryProperties");

fn PFN_vkVoidFunction getInstanceProcAddr(
  VkInstance instance, 
  CChar * pName)
@extern("vkGetInstanceProcAddr");

fn PFN_vkVoidFunction getDeviceProcAddr(
  VkDevice device, 
  CChar * pName)
@extern("vkGetDeviceProcAddr");

fn VkResult createDevice(
  VkPhysicalDevice physicalDevice, 
  VkDeviceCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkDevice * pDevice)
@extern("vkCreateDevice");

fn void destroyDevice(
  VkDevice device, 
  VkAllocationCallbacks * pAllocator)
@extern("vkDestroyDevice");

fn VkResult enumerateInstanceExtensionProperties(
  CChar * pLayerName, 
  uint * pPropertyCount, 
  VkExtensionProperties * pProperties)
@extern("vkEnumerateInstanceExtensionProperties");

fn VkResult enumerateDeviceExtensionProperties(
  VkPhysicalDevice physicalDevice, 
  CChar * pLayerName, 
  uint * pPropertyCount, 
  VkExtensionProperties * pProperties)
@extern("vkEnumerateDeviceExtensionProperties");

fn VkResult enumerateInstanceLayerProperties(
  uint * pPropertyCount, 
  VkLayerProperties * pProperties)
@extern("vkEnumerateInstanceLayerProperties");

fn VkResult enumerateDeviceLayerProperties(
  VkPhysicalDevice physicalDevice, 
  uint * pPropertyCount, 
  VkLayerProperties * pProperties)
@extern("vkEnumerateDeviceLayerProperties");

fn void getDeviceQueue(
  VkDevice device, 
  uint queueFamilyIndex, 
  uint queueIndex, 
  VkQueue * pQueue)
@extern("vkGetDeviceQueue");

fn VkResult queueSubmit(
  VkQueue queue, 
  uint submitCount, 
  VkSubmitInfo * pSubmits, 
  VkFence fence)
@extern("vkQueueSubmit");

fn VkResult queueWaitIdle(
  VkQueue queue)
@extern("vkQueueWaitIdle");

fn VkResult deviceWaitIdle(
  VkDevice device)
@extern("vkDeviceWaitIdle");

fn VkResult allocateMemory(
  VkDevice device, 
  VkMemoryAllocateInfo * pAllocateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkDeviceMemory * pMemory)
@extern("vkAllocateMemory");

fn void freeMemory(
  VkDevice device, 
  VkDeviceMemory memory, 
  VkAllocationCallbacks * pAllocator)
@extern("vkFreeMemory");

fn VkResult mapMemory(
  VkDevice device, 
  VkDeviceMemory memory, 
  VkDeviceSize offset, 
  VkDeviceSize size, 
  VkMemoryMapFlags flags, 
  void ** ppData)
@extern("vkMapMemory");

fn void unmapMemory(
  VkDevice device, 
  VkDeviceMemory memory)
@extern("vkUnmapMemory");

fn VkResult flushMappedMemoryRanges(
  VkDevice device, 
  uint memoryRangeCount, 
  VkMappedMemoryRange * pMemoryRanges)
@extern("vkFlushMappedMemoryRanges");

fn VkResult invalidateMappedMemoryRanges(
  VkDevice device, 
  uint memoryRangeCount, 
  VkMappedMemoryRange * pMemoryRanges)
@extern("vkInvalidateMappedMemoryRanges");

fn void getDeviceMemoryCommitment(
  VkDevice device, 
  VkDeviceMemory memory, 
  VkDeviceSize * pCommittedMemoryInBytes)
@extern("vkGetDeviceMemoryCommitment");

fn VkResult bindBufferMemory(
  VkDevice device, 
  VkBuffer buffer, 
  VkDeviceMemory memory, 
  VkDeviceSize memoryOffset)
@extern("vkBindBufferMemory");

fn VkResult bindImageMemory(
  VkDevice device, 
  VkImage image, 
  VkDeviceMemory memory, 
  VkDeviceSize memoryOffset)
@extern("vkBindImageMemory");

fn void getBufferMemoryRequirements(
  VkDevice device, 
  VkBuffer buffer, 
  VkMemoryRequirements * pMemoryRequirements)
@extern("vkGetBufferMemoryRequirements");

fn void getImageMemoryRequirements(
  VkDevice device, 
  VkImage image, 
  VkMemoryRequirements * pMemoryRequirements)
@extern("vkGetImageMemoryRequirements");

fn void getImageSparseMemoryRequirements(
  VkDevice device, 
  VkImage image, 
  uint * pSparseMemoryRequirementCount, 
  VkSparseImageMemoryRequirements * pSparseMemoryRequirements)
@extern("vkGetImageSparseMemoryRequirements");

fn void getPhysicalDeviceSparseImageFormatProperties(
  VkPhysicalDevice physicalDevice, 
  VkFormat format, 
  VkImageType type, 
  VkSampleCountFlagBits samples, 
  VkImageUsageFlags usage, 
  VkImageTiling tiling, 
  uint * pPropertyCount, 
  VkSparseImageFormatProperties * pProperties)
@extern("vkGetPhysicalDeviceSparseImageFormatProperties");

fn VkResult queueBindSparse(
  VkQueue queue, 
  uint bindInfoCount, 
  VkBindSparseInfo * pBindInfo, 
  VkFence fence)
@extern("vkQueueBindSparse");

fn VkResult createFence(
  VkDevice device, 
  VkFenceCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkFence * pFence)
@extern("vkCreateFence");

fn void destroyFence(
  VkDevice device, 
  VkFence fence, 
  VkAllocationCallbacks * pAllocator)
@extern("vkDestroyFence");

fn VkResult resetFences(
  VkDevice device, 
  uint fenceCount, 
  VkFence * pFences)
@extern("vkResetFences");

fn VkResult getFenceStatus(
  VkDevice device, 
  VkFence fence)
@extern("vkGetFenceStatus");

fn VkResult waitForFences(
  VkDevice device, 
  uint fenceCount, 
  VkFence * pFences, 
  VkBool32 waitAll, 
  ulong timeout)
@extern("vkWaitForFences");

fn VkResult createSemaphore(
  VkDevice device, 
  VkSemaphoreCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkSemaphore * pSemaphore)
@extern("vkCreateSemaphore");

fn void destroySemaphore(
  VkDevice device, 
  VkSemaphore semaphore, 
  VkAllocationCallbacks * pAllocator)
@extern("vkDestroySemaphore");

fn VkResult createEvent(
  VkDevice device, 
  VkEventCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkEvent * pEvent)
@extern("vkCreateEvent");

fn void destroyEvent(
  VkDevice device, 
  VkEvent event, 
  VkAllocationCallbacks * pAllocator)
@extern("vkDestroyEvent");

fn VkResult getEventStatus(
  VkDevice device, 
  VkEvent event)
@extern("vkGetEventStatus");

fn VkResult setEvent(
  VkDevice device, 
  VkEvent event)
@extern("vkSetEvent");

fn VkResult resetEvent(
  VkDevice device, 
  VkEvent event)
@extern("vkResetEvent");

fn VkResult createQueryPool(
  VkDevice device, 
  VkQueryPoolCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkQueryPool * pQueryPool)
@extern("vkCreateQueryPool");

fn void destroyQueryPool(
  VkDevice device, 
  VkQueryPool queryPool, 
  VkAllocationCallbacks * pAllocator)
@extern("vkDestroyQueryPool");

fn VkResult getQueryPoolResults(
  VkDevice device, 
  VkQueryPool queryPool, 
  uint firstQuery, 
  uint queryCount, 
  usz dataSize, 
  void * pData, 
  VkDeviceSize stride, 
  VkQueryResultFlags flags)
@extern("vkGetQueryPoolResults");

fn VkResult createBuffer(
  VkDevice device, 
  VkBufferCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkBuffer * pBuffer)
@extern("vkCreateBuffer");

fn void destroyBuffer(
  VkDevice device, 
  VkBuffer buffer, 
  VkAllocationCallbacks * pAllocator)
@extern("vkDestroyBuffer");

fn VkResult createBufferView(
  VkDevice device, 
  VkBufferViewCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkBufferView * pView)
@extern("vkCreateBufferView");

fn void destroyBufferView(
  VkDevice device, 
  VkBufferView bufferView, 
  VkAllocationCallbacks * pAllocator)
@extern("vkDestroyBufferView");

fn VkResult createImage(
  VkDevice device, 
  VkImageCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkImage * pImage)
@extern("vkCreateImage");

fn void destroyImage(
  VkDevice device, 
  VkImage image, 
  VkAllocationCallbacks * pAllocator)
@extern("vkDestroyImage");

fn void getImageSubresourceLayout(
  VkDevice device, 
  VkImage image, 
  VkImageSubresource * pSubresource, 
  VkSubresourceLayout * pLayout)
@extern("vkGetImageSubresourceLayout");

fn VkResult createImageView(
  VkDevice device, 
  VkImageViewCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkImageView * pView)
@extern("vkCreateImageView");

fn void destroyImageView(
  VkDevice device, 
  VkImageView imageView, 
  VkAllocationCallbacks * pAllocator)
@extern("vkDestroyImageView");

fn VkResult createShaderModule(
  VkDevice device, 
  VkShaderModuleCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkShaderModule * pShaderModule)
@extern("vkCreateShaderModule");

fn void destroyShaderModule(
  VkDevice device, 
  VkShaderModule shaderModule, 
  VkAllocationCallbacks * pAllocator)
@extern("vkDestroyShaderModule");

fn VkResult createPipelineCache(
  VkDevice device, 
  VkPipelineCacheCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkPipelineCache * pPipelineCache)
@extern("vkCreatePipelineCache");

fn void destroyPipelineCache(
  VkDevice device, 
  VkPipelineCache pipelineCache, 
  VkAllocationCallbacks * pAllocator)
@extern("vkDestroyPipelineCache");

fn VkResult getPipelineCacheData(
  VkDevice device, 
  VkPipelineCache pipelineCache, 
  usz * pDataSize, 
  void * pData)
@extern("vkGetPipelineCacheData");

fn VkResult mergePipelineCaches(
  VkDevice device, 
  VkPipelineCache dstCache, 
  uint srcCacheCount, 
  VkPipelineCache * pSrcCaches)
@extern("vkMergePipelineCaches");

fn VkResult createGraphicsPipelines(
  VkDevice device, 
  VkPipelineCache pipelineCache, 
  uint createInfoCount, 
  VkGraphicsPipelineCreateInfo * pCreateInfos, 
  VkAllocationCallbacks * pAllocator, 
  VkPipeline * pPipelines)
@extern("vkCreateGraphicsPipelines");

fn VkResult createComputePipelines(
  VkDevice device, 
  VkPipelineCache pipelineCache, 
  uint createInfoCount, 
  VkComputePipelineCreateInfo * pCreateInfos, 
  VkAllocationCallbacks * pAllocator, 
  VkPipeline * pPipelines)
@extern("vkCreateComputePipelines");

fn void destroyPipeline(
  VkDevice device, 
  VkPipeline pipeline, 
  VkAllocationCallbacks * pAllocator)
@extern("vkDestroyPipeline");

fn VkResult createPipelineLayout(
  VkDevice device, 
  VkPipelineLayoutCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkPipelineLayout * pPipelineLayout)
@extern("vkCreatePipelineLayout");

fn void destroyPipelineLayout(
  VkDevice device, 
  VkPipelineLayout pipelineLayout, 
  VkAllocationCallbacks * pAllocator)
@extern("vkDestroyPipelineLayout");

fn VkResult createSampler(
  VkDevice device, 
  VkSamplerCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkSampler * pSampler)
@extern("vkCreateSampler");

fn void destroySampler(
  VkDevice device, 
  VkSampler sampler, 
  VkAllocationCallbacks * pAllocator)
@extern("vkDestroySampler");

fn VkResult createDescriptorSetLayout(
  VkDevice device, 
  VkDescriptorSetLayoutCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkDescriptorSetLayout * pSetLayout)
@extern("vkCreateDescriptorSetLayout");

fn void destroyDescriptorSetLayout(
  VkDevice device, 
  VkDescriptorSetLayout descriptorSetLayout, 
  VkAllocationCallbacks * pAllocator)
@extern("vkDestroyDescriptorSetLayout");

fn VkResult createDescriptorPool(
  VkDevice device, 
  VkDescriptorPoolCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkDescriptorPool * pDescriptorPool)
@extern("vkCreateDescriptorPool");

fn void destroyDescriptorPool(
  VkDevice device, 
  VkDescriptorPool descriptorPool, 
  VkAllocationCallbacks * pAllocator)
@extern("vkDestroyDescriptorPool");

fn VkResult resetDescriptorPool(
  VkDevice device, 
  VkDescriptorPool descriptorPool, 
  VkDescriptorPoolResetFlags flags)
@extern("vkResetDescriptorPool");

fn VkResult allocateDescriptorSets(
  VkDevice device, 
  VkDescriptorSetAllocateInfo * pAllocateInfo, 
  VkDescriptorSet * pDescriptorSets)
@extern("vkAllocateDescriptorSets");

fn VkResult freeDescriptorSets(
  VkDevice device, 
  VkDescriptorPool descriptorPool, 
  uint descriptorSetCount, 
  VkDescriptorSet * pDescriptorSets)
@extern("vkFreeDescriptorSets");

fn void updateDescriptorSets(
  VkDevice device, 
  uint descriptorWriteCount, 
  VkWriteDescriptorSet * pDescriptorWrites, 
  uint descriptorCopyCount, 
  VkCopyDescriptorSet * pDescriptorCopies)
@extern("vkUpdateDescriptorSets");

fn VkResult createFramebuffer(
  VkDevice device, 
  VkFramebufferCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkFramebuffer * pFramebuffer)
@extern("vkCreateFramebuffer");

fn void destroyFramebuffer(
  VkDevice device, 
  VkFramebuffer framebuffer, 
  VkAllocationCallbacks * pAllocator)
@extern("vkDestroyFramebuffer");

fn VkResult createRenderPass(
  VkDevice device, 
  VkRenderPassCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkRenderPass * pRenderPass)
@extern("vkCreateRenderPass");

fn void destroyRenderPass(
  VkDevice device, 
  VkRenderPass renderPass, 
  VkAllocationCallbacks * pAllocator)
@extern("vkDestroyRenderPass");

fn void getRenderAreaGranularity(
  VkDevice device, 
  VkRenderPass renderPass, 
  VkExtent2D * pGranularity)
@extern("vkGetRenderAreaGranularity");

fn VkResult createCommandPool(
  VkDevice device, 
  VkCommandPoolCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkCommandPool * pCommandPool)
@extern("vkCreateCommandPool");

fn void destroyCommandPool(
  VkDevice device, 
  VkCommandPool commandPool, 
  VkAllocationCallbacks * pAllocator)
@extern("vkDestroyCommandPool");

fn VkResult resetCommandPool(
  VkDevice device, 
  VkCommandPool commandPool, 
  VkCommandPoolResetFlags flags)
@extern("vkResetCommandPool");

fn VkResult allocateCommandBuffers(
  VkDevice device, 
  VkCommandBufferAllocateInfo * pAllocateInfo, 
  VkCommandBuffer * pCommandBuffers)
@extern("vkAllocateCommandBuffers");

fn void freeCommandBuffers(
  VkDevice device, 
  VkCommandPool commandPool, 
  uint commandBufferCount, 
  VkCommandBuffer * pCommandBuffers)
@extern("vkFreeCommandBuffers");

fn VkResult beginCommandBuffer(
  VkCommandBuffer commandBuffer, 
  VkCommandBufferBeginInfo * pBeginInfo)
@extern("vkBeginCommandBuffer");

fn VkResult endCommandBuffer(
  VkCommandBuffer commandBuffer)
@extern("vkEndCommandBuffer");

fn VkResult resetCommandBuffer(
  VkCommandBuffer commandBuffer, 
  VkCommandBufferResetFlags flags)
@extern("vkResetCommandBuffer");

fn void cmdBindPipeline(
  VkCommandBuffer commandBuffer, 
  VkPipelineBindPoint pipelineBindPoint, 
  VkPipeline pipeline)
@extern("vkCmdBindPipeline");

fn void cmdSetViewport(
  VkCommandBuffer commandBuffer, 
  uint firstViewport, 
  uint viewportCount, 
  VkViewport * pViewports)
@extern("vkCmdSetViewport");

fn void cmdSetScissor(
  VkCommandBuffer commandBuffer, 
  uint firstScissor, 
  uint scissorCount, 
  VkRect2D * pScissors)
@extern("vkCmdSetScissor");

fn void cmdSetLineWidth(
  VkCommandBuffer commandBuffer, 
  float lineWidth)
@extern("vkCmdSetLineWidth");

fn void cmdSetDepthBias(
  VkCommandBuffer commandBuffer, 
  float depthBiasConstantFactor, 
  float depthBiasClamp, 
  float depthBiasSlopeFactor)
@extern("vkCmdSetDepthBias");

fn void cmdSetBlendConstants(
  VkCommandBuffer commandBuffer, 
  float[4] blendConstants)
@extern("vkCmdSetBlendConstants");

fn void cmdSetDepthBounds(
  VkCommandBuffer commandBuffer, 
  float minDepthBounds, 
  float maxDepthBounds)
@extern("vkCmdSetDepthBounds");

fn void cmdSetStencilCompareMask(
  VkCommandBuffer commandBuffer, 
  VkStencilFaceFlags faceMask, 
  uint compareMask)
@extern("vkCmdSetStencilCompareMask");

fn void cmdSetStencilWriteMask(
  VkCommandBuffer commandBuffer, 
  VkStencilFaceFlags faceMask, 
  uint writeMask)
@extern("vkCmdSetStencilWriteMask");

fn void cmdSetStencilReference(
  VkCommandBuffer commandBuffer, 
  VkStencilFaceFlags faceMask, 
  uint reference)
@extern("vkCmdSetStencilReference");

fn void cmdBindDescriptorSets(
  VkCommandBuffer commandBuffer, 
  VkPipelineBindPoint pipelineBindPoint, 
  VkPipelineLayout layout, 
  uint firstSet, 
  uint descriptorSetCount, 
  VkDescriptorSet * pDescriptorSets, 
  uint dynamicOffsetCount, 
  uint * pDynamicOffsets)
@extern("vkCmdBindDescriptorSets");

fn void cmdBindIndexBuffer(
  VkCommandBuffer commandBuffer, 
  VkBuffer buffer, 
  VkDeviceSize offset, 
  VkIndexType indexType)
@extern("vkCmdBindIndexBuffer");

fn void cmdBindVertexBuffers(
  VkCommandBuffer commandBuffer, 
  uint firstBinding, 
  uint bindingCount, 
  VkBuffer * pBuffers, 
  VkDeviceSize * pOffsets)
@extern("vkCmdBindVertexBuffers");

fn void cmdDraw(
  VkCommandBuffer commandBuffer, 
  uint vertexCount, 
  uint instanceCount, 
  uint firstVertex, 
  uint firstInstance)
@extern("vkCmdDraw");

fn void cmdDrawIndexed(
  VkCommandBuffer commandBuffer, 
  uint indexCount, 
  uint instanceCount, 
  uint firstIndex, 
  int vertexOffset, 
  uint firstInstance)
@extern("vkCmdDrawIndexed");

fn void cmdDrawIndirect(
  VkCommandBuffer commandBuffer, 
  VkBuffer buffer, 
  VkDeviceSize offset, 
  uint drawCount, 
  uint stride)
@extern("vkCmdDrawIndirect");

fn void cmdDrawIndexedIndirect(
  VkCommandBuffer commandBuffer, 
  VkBuffer buffer, 
  VkDeviceSize offset, 
  uint drawCount, 
  uint stride)
@extern("vkCmdDrawIndexedIndirect");

fn void cmdDispatch(
  VkCommandBuffer commandBuffer, 
  uint groupCountX, 
  uint groupCountY, 
  uint groupCountZ)
@extern("vkCmdDispatch");

fn void cmdDispatchIndirect(
  VkCommandBuffer commandBuffer, 
  VkBuffer buffer, 
  VkDeviceSize offset)
@extern("vkCmdDispatchIndirect");

fn void cmdCopyBuffer(
  VkCommandBuffer commandBuffer, 
  VkBuffer srcBuffer, 
  VkBuffer dstBuffer, 
  uint regionCount, 
  VkBufferCopy * pRegions)
@extern("vkCmdCopyBuffer");

fn void cmdCopyImage(
  VkCommandBuffer commandBuffer, 
  VkImage srcImage, 
  VkImageLayout srcImageLayout, 
  VkImage dstImage, 
  VkImageLayout dstImageLayout, 
  uint regionCount, 
  VkImageCopy * pRegions)
@extern("vkCmdCopyImage");

fn void cmdBlitImage(
  VkCommandBuffer commandBuffer, 
  VkImage srcImage, 
  VkImageLayout srcImageLayout, 
  VkImage dstImage, 
  VkImageLayout dstImageLayout, 
  uint regionCount, 
  VkImageBlit * pRegions, 
  VkFilter filter)
@extern("vkCmdBlitImage");

fn void cmdCopyBufferToImage(
  VkCommandBuffer commandBuffer, 
  VkBuffer srcBuffer, 
  VkImage dstImage, 
  VkImageLayout dstImageLayout, 
  uint regionCount, 
  VkBufferImageCopy * pRegions)
@extern("vkCmdCopyBufferToImage");

fn void cmdCopyImageToBuffer(
  VkCommandBuffer commandBuffer, 
  VkImage srcImage, 
  VkImageLayout srcImageLayout, 
  VkBuffer dstBuffer, 
  uint regionCount, 
  VkBufferImageCopy * pRegions)
@extern("vkCmdCopyImageToBuffer");

fn void cmdUpdateBuffer(
  VkCommandBuffer commandBuffer, 
  VkBuffer dstBuffer, 
  VkDeviceSize dstOffset, 
  VkDeviceSize dataSize, 
  void * pData)
@extern("vkCmdUpdateBuffer");

fn void cmdFillBuffer(
  VkCommandBuffer commandBuffer, 
  VkBuffer dstBuffer, 
  VkDeviceSize dstOffset, 
  VkDeviceSize size, 
  uint data)
@extern("vkCmdFillBuffer");

fn void cmdClearColorImage(
  VkCommandBuffer commandBuffer, 
  VkImage image, 
  VkImageLayout imageLayout, 
  VkClearColorValue * pColor, 
  uint rangeCount, 
  VkImageSubresourceRange * pRanges)
@extern("vkCmdClearColorImage");

fn void cmdClearDepthStencilImage(
  VkCommandBuffer commandBuffer, 
  VkImage image, 
  VkImageLayout imageLayout, 
  VkClearDepthStencilValue * pDepthStencil, 
  uint rangeCount, 
  VkImageSubresourceRange * pRanges)
@extern("vkCmdClearDepthStencilImage");

fn void cmdClearAttachments(
  VkCommandBuffer commandBuffer, 
  uint attachmentCount, 
  VkClearAttachment * pAttachments, 
  uint rectCount, 
  VkClearRect * pRects)
@extern("vkCmdClearAttachments");

fn void cmdResolveImage(
  VkCommandBuffer commandBuffer, 
  VkImage srcImage, 
  VkImageLayout srcImageLayout, 
  VkImage dstImage, 
  VkImageLayout dstImageLayout, 
  uint regionCount, 
  VkImageResolve * pRegions)
@extern("vkCmdResolveImage");

fn void cmdSetEvent(
  VkCommandBuffer commandBuffer, 
  VkEvent event, 
  VkPipelineStageFlags stageMask)
@extern("vkCmdSetEvent");

fn void cmdResetEvent(
  VkCommandBuffer commandBuffer, 
  VkEvent event, 
  VkPipelineStageFlags stageMask)
@extern("vkCmdResetEvent");

fn void cmdWaitEvents(
  VkCommandBuffer commandBuffer, 
  uint eventCount, 
  VkEvent * pEvents, 
  VkPipelineStageFlags srcStageMask, 
  VkPipelineStageFlags dstStageMask, 
  uint memoryBarrierCount, 
  VkMemoryBarrier * pMemoryBarriers, 
  uint bufferMemoryBarrierCount, 
  VkBufferMemoryBarrier * pBufferMemoryBarriers, 
  uint imageMemoryBarrierCount, 
  VkImageMemoryBarrier * pImageMemoryBarriers)
@extern("vkCmdWaitEvents");

fn void cmdPipelineBarrier(
  VkCommandBuffer commandBuffer, 
  VkPipelineStageFlags srcStageMask, 
  VkPipelineStageFlags dstStageMask, 
  VkDependencyFlags dependencyFlags, 
  uint memoryBarrierCount, 
  VkMemoryBarrier * pMemoryBarriers, 
  uint bufferMemoryBarrierCount, 
  VkBufferMemoryBarrier * pBufferMemoryBarriers, 
  uint imageMemoryBarrierCount, 
  VkImageMemoryBarrier * pImageMemoryBarriers)
@extern("vkCmdPipelineBarrier");

fn void cmdBeginQuery(
  VkCommandBuffer commandBuffer, 
  VkQueryPool queryPool, 
  uint query, 
  VkQueryControlFlags flags)
@extern("vkCmdBeginQuery");

fn void cmdEndQuery(
  VkCommandBuffer commandBuffer, 
  VkQueryPool queryPool, 
  uint query)
@extern("vkCmdEndQuery");

fn void cmdResetQueryPool(
  VkCommandBuffer commandBuffer, 
  VkQueryPool queryPool, 
  uint firstQuery, 
  uint queryCount)
@extern("vkCmdResetQueryPool");

fn void cmdWriteTimestamp(
  VkCommandBuffer commandBuffer, 
  VkPipelineStageFlagBits pipelineStage, 
  VkQueryPool queryPool, 
  uint query)
@extern("vkCmdWriteTimestamp");

fn void cmdCopyQueryPoolResults(
  VkCommandBuffer commandBuffer, 
  VkQueryPool queryPool, 
  uint firstQuery, 
  uint queryCount, 
  VkBuffer dstBuffer, 
  VkDeviceSize dstOffset, 
  VkDeviceSize stride, 
  VkQueryResultFlags flags)
@extern("vkCmdCopyQueryPoolResults");

fn void cmdPushConstants(
  VkCommandBuffer commandBuffer, 
  VkPipelineLayout layout, 
  VkShaderStageFlags stageFlags, 
  uint offset, 
  uint size, 
  void * pValues)
@extern("vkCmdPushConstants");

fn void cmdBeginRenderPass(
  VkCommandBuffer commandBuffer, 
  VkRenderPassBeginInfo * pRenderPassBegin, 
  VkSubpassContents contents)
@extern("vkCmdBeginRenderPass");

fn void cmdNextSubpass(
  VkCommandBuffer commandBuffer, 
  VkSubpassContents contents)
@extern("vkCmdNextSubpass");

fn void cmdEndRenderPass(
  VkCommandBuffer commandBuffer)
@extern("vkCmdEndRenderPass");

fn void cmdExecuteCommands(
  VkCommandBuffer commandBuffer, 
  uint commandBufferCount, 
  VkCommandBuffer * pCommandBuffers)
@extern("vkCmdExecuteCommands");

typedef VkSamplerYcbcrConversion_T = void;

alias VkSamplerYcbcrConversion = VkSamplerYcbcrConversion_T *;

typedef VkDescriptorUpdateTemplate_T = void;

alias VkDescriptorUpdateTemplate = VkDescriptorUpdateTemplate_T *;

typedef VkPointClippingBehavior = inline CUInt;
const VkPointClippingBehavior POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES = 0;
const VkPointClippingBehavior POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY = 1;
const VkPointClippingBehavior POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR = POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES;
const VkPointClippingBehavior POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR = POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY;
const VkPointClippingBehavior POINT_CLIPPING_BEHAVIOR_MAX_ENUM = 0x7FFFFFFF;

typedef VkTessellationDomainOrigin = inline CUInt;
const VkTessellationDomainOrigin TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT = 0;
const VkTessellationDomainOrigin TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT = 1;
const VkTessellationDomainOrigin TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR = TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT;
const VkTessellationDomainOrigin TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR = TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT;
const VkTessellationDomainOrigin TESSELLATION_DOMAIN_ORIGIN_MAX_ENUM = 0x7FFFFFFF;

typedef VkSamplerYcbcrModelConversion = inline CUInt;
const VkSamplerYcbcrModelConversion SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY = 0;
const VkSamplerYcbcrModelConversion SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY = 1;
const VkSamplerYcbcrModelConversion SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709 = 2;
const VkSamplerYcbcrModelConversion SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601 = 3;
const VkSamplerYcbcrModelConversion SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020 = 4;
const VkSamplerYcbcrModelConversion SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR = SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY;
const VkSamplerYcbcrModelConversion SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR = SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY;
const VkSamplerYcbcrModelConversion SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR = SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709;
const VkSamplerYcbcrModelConversion SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR = SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601;
const VkSamplerYcbcrModelConversion SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR = SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020;
const VkSamplerYcbcrModelConversion SAMPLER_YCBCR_MODEL_CONVERSION_MAX_ENUM = 0x7FFFFFFF;

typedef VkSamplerYcbcrRange = inline CUInt;
const VkSamplerYcbcrRange SAMPLER_YCBCR_RANGE_ITU_FULL = 0;
const VkSamplerYcbcrRange SAMPLER_YCBCR_RANGE_ITU_NARROW = 1;
const VkSamplerYcbcrRange SAMPLER_YCBCR_RANGE_ITU_FULL_KHR = SAMPLER_YCBCR_RANGE_ITU_FULL;
const VkSamplerYcbcrRange SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR = SAMPLER_YCBCR_RANGE_ITU_NARROW;
const VkSamplerYcbcrRange SAMPLER_YCBCR_RANGE_MAX_ENUM = 0x7FFFFFFF;

typedef VkChromaLocation = inline CUInt;
const VkChromaLocation CHROMA_LOCATION_COSITED_EVEN = 0;
const VkChromaLocation CHROMA_LOCATION_MIDPOINT = 1;
const VkChromaLocation CHROMA_LOCATION_COSITED_EVEN_KHR = CHROMA_LOCATION_COSITED_EVEN;
const VkChromaLocation CHROMA_LOCATION_MIDPOINT_KHR = CHROMA_LOCATION_MIDPOINT;
const VkChromaLocation CHROMA_LOCATION_MAX_ENUM = 0x7FFFFFFF;

typedef VkDescriptorUpdateTemplateType = inline CUInt;
const VkDescriptorUpdateTemplateType DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET = 0;
const VkDescriptorUpdateTemplateType DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR = 1;
const VkDescriptorUpdateTemplateType DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR = DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET;
const VkDescriptorUpdateTemplateType DESCRIPTOR_UPDATE_TEMPLATE_TYPE_MAX_ENUM = 0x7FFFFFFF;

typedef VkSubgroupFeatureFlagBits = inline CUInt;
const VkSubgroupFeatureFlagBits SUBGROUP_FEATURE_BASIC_BIT = 0x00000001;
const VkSubgroupFeatureFlagBits SUBGROUP_FEATURE_VOTE_BIT = 0x00000002;
const VkSubgroupFeatureFlagBits SUBGROUP_FEATURE_ARITHMETIC_BIT = 0x00000004;
const VkSubgroupFeatureFlagBits SUBGROUP_FEATURE_BALLOT_BIT = 0x00000008;
const VkSubgroupFeatureFlagBits SUBGROUP_FEATURE_SHUFFLE_BIT = 0x00000010;
const VkSubgroupFeatureFlagBits SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT = 0x00000020;
const VkSubgroupFeatureFlagBits SUBGROUP_FEATURE_CLUSTERED_BIT = 0x00000040;
const VkSubgroupFeatureFlagBits SUBGROUP_FEATURE_QUAD_BIT = 0x00000080;
const VkSubgroupFeatureFlagBits SUBGROUP_FEATURE_PARTITIONED_BIT_NV = 0x00000100;
const VkSubgroupFeatureFlagBits SUBGROUP_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkSubgroupFeatureFlags = VkFlags;

typedef VkPeerMemoryFeatureFlagBits = inline CUInt;
const VkPeerMemoryFeatureFlagBits PEER_MEMORY_FEATURE_COPY_SRC_BIT = 0x00000001;
const VkPeerMemoryFeatureFlagBits PEER_MEMORY_FEATURE_COPY_DST_BIT = 0x00000002;
const VkPeerMemoryFeatureFlagBits PEER_MEMORY_FEATURE_GENERIC_SRC_BIT = 0x00000004;
const VkPeerMemoryFeatureFlagBits PEER_MEMORY_FEATURE_GENERIC_DST_BIT = 0x00000008;
const VkPeerMemoryFeatureFlagBits PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR = PEER_MEMORY_FEATURE_COPY_SRC_BIT;
const VkPeerMemoryFeatureFlagBits PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR = PEER_MEMORY_FEATURE_COPY_DST_BIT;
const VkPeerMemoryFeatureFlagBits PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR = PEER_MEMORY_FEATURE_GENERIC_SRC_BIT;
const VkPeerMemoryFeatureFlagBits PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR = PEER_MEMORY_FEATURE_GENERIC_DST_BIT;
const VkPeerMemoryFeatureFlagBits PEER_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkPeerMemoryFeatureFlags = VkFlags;

typedef VkMemoryAllocateFlagBits = inline CUInt;
const VkMemoryAllocateFlagBits MEMORY_ALLOCATE_DEVICE_MASK_BIT = 0x00000001;
const VkMemoryAllocateFlagBits MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT = 0x00000002;
const VkMemoryAllocateFlagBits MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT = 0x00000004;
const VkMemoryAllocateFlagBits MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR = MEMORY_ALLOCATE_DEVICE_MASK_BIT;
const VkMemoryAllocateFlagBits MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR = MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT;
const VkMemoryAllocateFlagBits MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR = MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT;
const VkMemoryAllocateFlagBits MEMORY_ALLOCATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkMemoryAllocateFlags = VkFlags;

alias VkCommandPoolTrimFlags = VkFlags;

alias VkDescriptorUpdateTemplateCreateFlags = VkFlags;

typedef VkExternalMemoryHandleTypeFlagBits = inline CUInt;
const VkExternalMemoryHandleTypeFlagBits EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT = 0x00000001;
const VkExternalMemoryHandleTypeFlagBits EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT = 0x00000002;
const VkExternalMemoryHandleTypeFlagBits EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 0x00000004;
const VkExternalMemoryHandleTypeFlagBits EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT = 0x00000008;
const VkExternalMemoryHandleTypeFlagBits EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT = 0x00000010;
const VkExternalMemoryHandleTypeFlagBits EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT = 0x00000020;
const VkExternalMemoryHandleTypeFlagBits EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT = 0x00000040;
const VkExternalMemoryHandleTypeFlagBits EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT = 0x00000200;
const VkExternalMemoryHandleTypeFlagBits EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID = 0x00000400;
const VkExternalMemoryHandleTypeFlagBits EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT = 0x00000080;
const VkExternalMemoryHandleTypeFlagBits EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT = 0x00000100;
const VkExternalMemoryHandleTypeFlagBits EXTERNAL_MEMORY_HANDLE_TYPE_ZIRCON_VMO_BIT_FUCHSIA = 0x00000800;
const VkExternalMemoryHandleTypeFlagBits EXTERNAL_MEMORY_HANDLE_TYPE_RDMA_ADDRESS_BIT_NV = 0x00001000;
const VkExternalMemoryHandleTypeFlagBits EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
const VkExternalMemoryHandleTypeFlagBits EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT;
const VkExternalMemoryHandleTypeFlagBits EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT;
const VkExternalMemoryHandleTypeFlagBits EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR = EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT;
const VkExternalMemoryHandleTypeFlagBits EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR = EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT;
const VkExternalMemoryHandleTypeFlagBits EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR = EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT;
const VkExternalMemoryHandleTypeFlagBits EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR = EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT;
const VkExternalMemoryHandleTypeFlagBits EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkExternalMemoryHandleTypeFlags = VkFlags;

typedef VkExternalMemoryFeatureFlagBits = inline CUInt;
const VkExternalMemoryFeatureFlagBits EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT = 0x00000001;
const VkExternalMemoryFeatureFlagBits EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT = 0x00000002;
const VkExternalMemoryFeatureFlagBits EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT = 0x00000004;
const VkExternalMemoryFeatureFlagBits EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR = EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT;
const VkExternalMemoryFeatureFlagBits EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR = EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT;
const VkExternalMemoryFeatureFlagBits EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR = EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT;
const VkExternalMemoryFeatureFlagBits EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkExternalMemoryFeatureFlags = VkFlags;

typedef VkExternalFenceHandleTypeFlagBits = inline CUInt;
const VkExternalFenceHandleTypeFlagBits EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT = 0x00000001;
const VkExternalFenceHandleTypeFlagBits EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 0x00000002;
const VkExternalFenceHandleTypeFlagBits EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 0x00000004;
const VkExternalFenceHandleTypeFlagBits EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT = 0x00000008;
const VkExternalFenceHandleTypeFlagBits EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT;
const VkExternalFenceHandleTypeFlagBits EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT;
const VkExternalFenceHandleTypeFlagBits EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT;
const VkExternalFenceHandleTypeFlagBits EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR = EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT;
const VkExternalFenceHandleTypeFlagBits EXTERNAL_FENCE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkExternalFenceHandleTypeFlags = VkFlags;

typedef VkExternalFenceFeatureFlagBits = inline CUInt;
const VkExternalFenceFeatureFlagBits EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT = 0x00000001;
const VkExternalFenceFeatureFlagBits EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT = 0x00000002;
const VkExternalFenceFeatureFlagBits EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR = EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT;
const VkExternalFenceFeatureFlagBits EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR = EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT;
const VkExternalFenceFeatureFlagBits EXTERNAL_FENCE_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkExternalFenceFeatureFlags = VkFlags;

typedef VkFenceImportFlagBits = inline CUInt;
const VkFenceImportFlagBits FENCE_IMPORT_TEMPORARY_BIT = 0x00000001;
const VkFenceImportFlagBits FENCE_IMPORT_TEMPORARY_BIT_KHR = FENCE_IMPORT_TEMPORARY_BIT;
const VkFenceImportFlagBits FENCE_IMPORT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkFenceImportFlags = VkFlags;

typedef VkSemaphoreImportFlagBits = inline CUInt;
const VkSemaphoreImportFlagBits SEMAPHORE_IMPORT_TEMPORARY_BIT = 0x00000001;
const VkSemaphoreImportFlagBits SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR = SEMAPHORE_IMPORT_TEMPORARY_BIT;
const VkSemaphoreImportFlagBits SEMAPHORE_IMPORT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkSemaphoreImportFlags = VkFlags;

typedef VkExternalSemaphoreHandleTypeFlagBits = inline CUInt;
const VkExternalSemaphoreHandleTypeFlagBits EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT = 0x00000001;
const VkExternalSemaphoreHandleTypeFlagBits EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 0x00000002;
const VkExternalSemaphoreHandleTypeFlagBits EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 0x00000004;
const VkExternalSemaphoreHandleTypeFlagBits EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT = 0x00000008;
const VkExternalSemaphoreHandleTypeFlagBits EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT = 0x00000010;
const VkExternalSemaphoreHandleTypeFlagBits EXTERNAL_SEMAPHORE_HANDLE_TYPE_ZIRCON_EVENT_BIT_FUCHSIA = 0x00000080;
const VkExternalSemaphoreHandleTypeFlagBits EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE_BIT = EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT;
const VkExternalSemaphoreHandleTypeFlagBits EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
const VkExternalSemaphoreHandleTypeFlagBits EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT;
const VkExternalSemaphoreHandleTypeFlagBits EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT;
const VkExternalSemaphoreHandleTypeFlagBits EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR = EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT;
const VkExternalSemaphoreHandleTypeFlagBits EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR = EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT;
const VkExternalSemaphoreHandleTypeFlagBits EXTERNAL_SEMAPHORE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkExternalSemaphoreHandleTypeFlags = VkFlags;

typedef VkExternalSemaphoreFeatureFlagBits = inline CUInt;
const VkExternalSemaphoreFeatureFlagBits EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT = 0x00000001;
const VkExternalSemaphoreFeatureFlagBits EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT = 0x00000002;
const VkExternalSemaphoreFeatureFlagBits EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR = EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT;
const VkExternalSemaphoreFeatureFlagBits EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR = EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT;
const VkExternalSemaphoreFeatureFlagBits EXTERNAL_SEMAPHORE_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkExternalSemaphoreFeatureFlags = VkFlags;

struct VkPhysicalDeviceSubgroupProperties {
  VkStructureType sType;
  void * pNext;
  uint subgroupSize;
  VkShaderStageFlags supportedStages;
  VkSubgroupFeatureFlags supportedOperations;
  VkBool32 quadOperationsInAllStages;
}

struct VkBindBufferMemoryInfo {
  VkStructureType sType;
  void * pNext;
  VkBuffer buffer;
  VkDeviceMemory memory;
  VkDeviceSize memoryOffset;
}

struct VkBindImageMemoryInfo {
  VkStructureType sType;
  void * pNext;
  VkImage image;
  VkDeviceMemory memory;
  VkDeviceSize memoryOffset;
}

struct VkPhysicalDevice16BitStorageFeatures {
  VkStructureType sType;
  void * pNext;
  VkBool32 storageBuffer16BitAccess;
  VkBool32 uniformAndStorageBuffer16BitAccess;
  VkBool32 storagePushConstant16;
  VkBool32 storageInputOutput16;
}

struct VkMemoryDedicatedRequirements {
  VkStructureType sType;
  void * pNext;
  VkBool32 prefersDedicatedAllocation;
  VkBool32 requiresDedicatedAllocation;
}

struct VkMemoryDedicatedAllocateInfo {
  VkStructureType sType;
  void * pNext;
  VkImage image;
  VkBuffer buffer;
}

struct VkMemoryAllocateFlagsInfo {
  VkStructureType sType;
  void * pNext;
  VkMemoryAllocateFlags flags;
  uint deviceMask;
}

struct VkDeviceGroupRenderPassBeginInfo {
  VkStructureType sType;
  void * pNext;
  uint deviceMask;
  uint deviceRenderAreaCount;
  VkRect2D * pDeviceRenderAreas;
}

struct VkDeviceGroupCommandBufferBeginInfo {
  VkStructureType sType;
  void * pNext;
  uint deviceMask;
}

struct VkDeviceGroupSubmitInfo {
  VkStructureType sType;
  void * pNext;
  uint waitSemaphoreCount;
  uint * pWaitSemaphoreDeviceIndices;
  uint commandBufferCount;
  uint * pCommandBufferDeviceMasks;
  uint signalSemaphoreCount;
  uint * pSignalSemaphoreDeviceIndices;
}

struct VkDeviceGroupBindSparseInfo {
  VkStructureType sType;
  void * pNext;
  uint resourceDeviceIndex;
  uint memoryDeviceIndex;
}

struct VkBindBufferMemoryDeviceGroupInfo {
  VkStructureType sType;
  void * pNext;
  uint deviceIndexCount;
  uint * pDeviceIndices;
}

struct VkBindImageMemoryDeviceGroupInfo {
  VkStructureType sType;
  void * pNext;
  uint deviceIndexCount;
  uint * pDeviceIndices;
  uint splitInstanceBindRegionCount;
  VkRect2D * pSplitInstanceBindRegions;
}

struct VkPhysicalDeviceGroupProperties {
  VkStructureType sType;
  void * pNext;
  uint physicalDeviceCount;
  VkPhysicalDevice[32] physicalDevices;
  VkBool32 subsetAllocation;
}

struct VkDeviceGroupDeviceCreateInfo {
  VkStructureType sType;
  void * pNext;
  uint physicalDeviceCount;
  VkPhysicalDevice * pPhysicalDevices;
}

struct VkBufferMemoryRequirementsInfo2 {
  VkStructureType sType;
  void * pNext;
  VkBuffer buffer;
}

struct VkImageMemoryRequirementsInfo2 {
  VkStructureType sType;
  void * pNext;
  VkImage image;
}

struct VkImageSparseMemoryRequirementsInfo2 {
  VkStructureType sType;
  void * pNext;
  VkImage image;
}

struct VkMemoryRequirements2 {
  VkStructureType sType;
  void * pNext;
  VkMemoryRequirements memoryRequirements;
}

struct VkSparseImageMemoryRequirements2 {
  VkStructureType sType;
  void * pNext;
  VkSparseImageMemoryRequirements memoryRequirements;
}

struct VkPhysicalDeviceFeatures2 {
  VkStructureType sType;
  void * pNext;
  VkPhysicalDeviceFeatures features;
}

struct VkPhysicalDeviceProperties2 {
  VkStructureType sType;
  void * pNext;
  VkPhysicalDeviceProperties properties;
}

struct VkFormatProperties2 {
  VkStructureType sType;
  void * pNext;
  VkFormatProperties formatProperties;
}

struct VkImageFormatProperties2 {
  VkStructureType sType;
  void * pNext;
  VkImageFormatProperties imageFormatProperties;
}

struct VkPhysicalDeviceImageFormatInfo2 {
  VkStructureType sType;
  void * pNext;
  VkFormat format;
  VkImageType type;
  VkImageTiling tiling;
  VkImageUsageFlags usage;
  VkImageCreateFlags flags;
}

struct VkQueueFamilyProperties2 {
  VkStructureType sType;
  void * pNext;
  VkQueueFamilyProperties queueFamilyProperties;
}

struct VkPhysicalDeviceMemoryProperties2 {
  VkStructureType sType;
  void * pNext;
  VkPhysicalDeviceMemoryProperties memoryProperties;
}

struct VkSparseImageFormatProperties2 {
  VkStructureType sType;
  void * pNext;
  VkSparseImageFormatProperties properties;
}

struct VkPhysicalDeviceSparseImageFormatInfo2 {
  VkStructureType sType;
  void * pNext;
  VkFormat format;
  VkImageType type;
  VkSampleCountFlagBits samples;
  VkImageUsageFlags usage;
  VkImageTiling tiling;
}

struct VkPhysicalDevicePointClippingProperties {
  VkStructureType sType;
  void * pNext;
  VkPointClippingBehavior pointClippingBehavior;
}

struct VkInputAttachmentAspectReference {
  uint subpass;
  uint inputAttachmentIndex;
  VkImageAspectFlags aspectMask;
}

struct VkRenderPassInputAttachmentAspectCreateInfo {
  VkStructureType sType;
  void * pNext;
  uint aspectReferenceCount;
  VkInputAttachmentAspectReference * pAspectReferences;
}

struct VkImageViewUsageCreateInfo {
  VkStructureType sType;
  void * pNext;
  VkImageUsageFlags usage;
}

struct VkPipelineTessellationDomainOriginStateCreateInfo {
  VkStructureType sType;
  void * pNext;
  VkTessellationDomainOrigin domainOrigin;
}

struct VkRenderPassMultiviewCreateInfo {
  VkStructureType sType;
  void * pNext;
  uint subpassCount;
  uint * pViewMasks;
  uint dependencyCount;
  int * pViewOffsets;
  uint correlationMaskCount;
  uint * pCorrelationMasks;
}

struct VkPhysicalDeviceMultiviewFeatures {
  VkStructureType sType;
  void * pNext;
  VkBool32 multiview;
  VkBool32 multiviewGeometryShader;
  VkBool32 multiviewTessellationShader;
}

struct VkPhysicalDeviceMultiviewProperties {
  VkStructureType sType;
  void * pNext;
  uint maxMultiviewViewCount;
  uint maxMultiviewInstanceIndex;
}

struct VkPhysicalDeviceVariablePointersFeatures {
  VkStructureType sType;
  void * pNext;
  VkBool32 variablePointersStorageBuffer;
  VkBool32 variablePointers;
}

alias VkPhysicalDeviceVariablePointerFeatures = VkPhysicalDeviceVariablePointersFeatures;

struct VkPhysicalDeviceProtectedMemoryFeatures {
  VkStructureType sType;
  void * pNext;
  VkBool32 protectedMemory;
}

struct VkPhysicalDeviceProtectedMemoryProperties {
  VkStructureType sType;
  void * pNext;
  VkBool32 protectedNoFault;
}

struct VkDeviceQueueInfo2 {
  VkStructureType sType;
  void * pNext;
  VkDeviceQueueCreateFlags flags;
  uint queueFamilyIndex;
  uint queueIndex;
}

struct VkProtectedSubmitInfo {
  VkStructureType sType;
  void * pNext;
  VkBool32 protectedSubmit;
}

struct VkSamplerYcbcrConversionCreateInfo {
  VkStructureType sType;
  void * pNext;
  VkFormat format;
  VkSamplerYcbcrModelConversion ycbcrModel;
  VkSamplerYcbcrRange ycbcrRange;
  VkComponentMapping components;
  VkChromaLocation xChromaOffset;
  VkChromaLocation yChromaOffset;
  VkFilter chromaFilter;
  VkBool32 forceExplicitReconstruction;
}

struct VkSamplerYcbcrConversionInfo {
  VkStructureType sType;
  void * pNext;
  VkSamplerYcbcrConversion conversion;
}

struct VkBindImagePlaneMemoryInfo {
  VkStructureType sType;
  void * pNext;
  VkImageAspectFlagBits planeAspect;
}

struct VkImagePlaneMemoryRequirementsInfo {
  VkStructureType sType;
  void * pNext;
  VkImageAspectFlagBits planeAspect;
}

struct VkPhysicalDeviceSamplerYcbcrConversionFeatures {
  VkStructureType sType;
  void * pNext;
  VkBool32 samplerYcbcrConversion;
}

struct VkSamplerYcbcrConversionImageFormatProperties {
  VkStructureType sType;
  void * pNext;
  uint combinedImageSamplerDescriptorCount;
}

struct VkDescriptorUpdateTemplateEntry {
  uint dstBinding;
  uint dstArrayElement;
  uint descriptorCount;
  VkDescriptorType descriptorType;
  usz offset;
  usz stride;
}

struct VkDescriptorUpdateTemplateCreateInfo {
  VkStructureType sType;
  void * pNext;
  VkDescriptorUpdateTemplateCreateFlags flags;
  uint descriptorUpdateEntryCount;
  VkDescriptorUpdateTemplateEntry * pDescriptorUpdateEntries;
  VkDescriptorUpdateTemplateType templateType;
  VkDescriptorSetLayout descriptorSetLayout;
  VkPipelineBindPoint pipelineBindPoint;
  VkPipelineLayout pipelineLayout;
  uint set;
}

struct VkExternalMemoryProperties {
  VkExternalMemoryFeatureFlags externalMemoryFeatures;
  VkExternalMemoryHandleTypeFlags exportFromImportedHandleTypes;
  VkExternalMemoryHandleTypeFlags compatibleHandleTypes;
}

struct VkPhysicalDeviceExternalImageFormatInfo {
  VkStructureType sType;
  void * pNext;
  VkExternalMemoryHandleTypeFlagBits handleType;
}

struct VkExternalImageFormatProperties {
  VkStructureType sType;
  void * pNext;
  VkExternalMemoryProperties externalMemoryProperties;
}

struct VkPhysicalDeviceExternalBufferInfo {
  VkStructureType sType;
  void * pNext;
  VkBufferCreateFlags flags;
  VkBufferUsageFlags usage;
  VkExternalMemoryHandleTypeFlagBits handleType;
}

struct VkExternalBufferProperties {
  VkStructureType sType;
  void * pNext;
  VkExternalMemoryProperties externalMemoryProperties;
}

struct VkPhysicalDeviceIDProperties {
  VkStructureType sType;
  void * pNext;
  char[16] deviceUUID;
  char[16] driverUUID;
  char[8] deviceLUID;
  uint deviceNodeMask;
  VkBool32 deviceLUIDValid;
}

struct VkExternalMemoryImageCreateInfo {
  VkStructureType sType;
  void * pNext;
  VkExternalMemoryHandleTypeFlags handleTypes;
}

struct VkExternalMemoryBufferCreateInfo {
  VkStructureType sType;
  void * pNext;
  VkExternalMemoryHandleTypeFlags handleTypes;
}

struct VkExportMemoryAllocateInfo {
  VkStructureType sType;
  void * pNext;
  VkExternalMemoryHandleTypeFlags handleTypes;
}

struct VkPhysicalDeviceExternalFenceInfo {
  VkStructureType sType;
  void * pNext;
  VkExternalFenceHandleTypeFlagBits handleType;
}

struct VkExternalFenceProperties {
  VkStructureType sType;
  void * pNext;
  VkExternalFenceHandleTypeFlags exportFromImportedHandleTypes;
  VkExternalFenceHandleTypeFlags compatibleHandleTypes;
  VkExternalFenceFeatureFlags externalFenceFeatures;
}

struct VkExportFenceCreateInfo {
  VkStructureType sType;
  void * pNext;
  VkExternalFenceHandleTypeFlags handleTypes;
}

struct VkExportSemaphoreCreateInfo {
  VkStructureType sType;
  void * pNext;
  VkExternalSemaphoreHandleTypeFlags handleTypes;
}

struct VkPhysicalDeviceExternalSemaphoreInfo {
  VkStructureType sType;
  void * pNext;
  VkExternalSemaphoreHandleTypeFlagBits handleType;
}

struct VkExternalSemaphoreProperties {
  VkStructureType sType;
  void * pNext;
  VkExternalSemaphoreHandleTypeFlags exportFromImportedHandleTypes;
  VkExternalSemaphoreHandleTypeFlags compatibleHandleTypes;
  VkExternalSemaphoreFeatureFlags externalSemaphoreFeatures;
}

struct VkPhysicalDeviceMaintenance3Properties {
  VkStructureType sType;
  void * pNext;
  uint maxPerSetDescriptors;
  VkDeviceSize maxMemoryAllocationSize;
}

struct VkDescriptorSetLayoutSupport {
  VkStructureType sType;
  void * pNext;
  VkBool32 supported;
}

struct VkPhysicalDeviceShaderDrawParametersFeatures {
  VkStructureType sType;
  void * pNext;
  VkBool32 shaderDrawParameters;
}

alias VkPhysicalDeviceShaderDrawParameterFeatures = VkPhysicalDeviceShaderDrawParametersFeatures;

alias PFN_vkEnumerateInstanceVersion = fn VkResult(  uint * pApiVersion);

alias PFN_vkBindBufferMemory2 = fn VkResult(
  VkDevice device, 
  uint bindInfoCount, 
  VkBindBufferMemoryInfo * pBindInfos);

alias PFN_vkBindImageMemory2 = fn VkResult(
  VkDevice device, 
  uint bindInfoCount, 
  VkBindImageMemoryInfo * pBindInfos);

alias PFN_vkGetDeviceGroupPeerMemoryFeatures = fn void(
  VkDevice device, 
  uint heapIndex, 
  uint localDeviceIndex, 
  uint remoteDeviceIndex, 
  VkPeerMemoryFeatureFlags * pPeerMemoryFeatures);

alias PFN_vkCmdSetDeviceMask = fn void(
  VkCommandBuffer commandBuffer, 
  uint deviceMask);

alias PFN_vkCmdDispatchBase = fn void(
  VkCommandBuffer commandBuffer, 
  uint baseGroupX, 
  uint baseGroupY, 
  uint baseGroupZ, 
  uint groupCountX, 
  uint groupCountY, 
  uint groupCountZ);

alias PFN_vkEnumeratePhysicalDeviceGroups = fn VkResult(
  VkInstance instance, 
  uint * pPhysicalDeviceGroupCount, 
  VkPhysicalDeviceGroupProperties * pPhysicalDeviceGroupProperties);

alias PFN_vkGetImageMemoryRequirements2 = fn void(
  VkDevice device, 
  VkImageMemoryRequirementsInfo2 * pInfo, 
  VkMemoryRequirements2 * pMemoryRequirements);

alias PFN_vkGetBufferMemoryRequirements2 = fn void(
  VkDevice device, 
  VkBufferMemoryRequirementsInfo2 * pInfo, 
  VkMemoryRequirements2 * pMemoryRequirements);

alias PFN_vkGetImageSparseMemoryRequirements2 = fn void(
  VkDevice device, 
  VkImageSparseMemoryRequirementsInfo2 * pInfo, 
  uint * pSparseMemoryRequirementCount, 
  VkSparseImageMemoryRequirements2 * pSparseMemoryRequirements);

alias PFN_vkGetPhysicalDeviceFeatures2 = fn void(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceFeatures2 * pFeatures);

alias PFN_vkGetPhysicalDeviceProperties2 = fn void(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceProperties2 * pProperties);

alias PFN_vkGetPhysicalDeviceFormatProperties2 = fn void(
  VkPhysicalDevice physicalDevice, 
  VkFormat format, 
  VkFormatProperties2 * pFormatProperties);

alias PFN_vkGetPhysicalDeviceImageFormatProperties2 = fn VkResult(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceImageFormatInfo2 * pImageFormatInfo, 
  VkImageFormatProperties2 * pImageFormatProperties);

alias PFN_vkGetPhysicalDeviceQueueFamilyProperties2 = fn void(
  VkPhysicalDevice physicalDevice, 
  uint * pQueueFamilyPropertyCount, 
  VkQueueFamilyProperties2 * pQueueFamilyProperties);

alias PFN_vkGetPhysicalDeviceMemoryProperties2 = fn void(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceMemoryProperties2 * pMemoryProperties);

alias PFN_vkGetPhysicalDeviceSparseImageFormatProperties2 = fn void(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceSparseImageFormatInfo2 * pFormatInfo, 
  uint * pPropertyCount, 
  VkSparseImageFormatProperties2 * pProperties);

alias PFN_vkTrimCommandPool = fn void(
  VkDevice device, 
  VkCommandPool commandPool, 
  VkCommandPoolTrimFlags flags);

alias PFN_vkGetDeviceQueue2 = fn void(
  VkDevice device, 
  VkDeviceQueueInfo2 * pQueueInfo, 
  VkQueue * pQueue);

alias PFN_vkCreateSamplerYcbcrConversion = fn VkResult(
  VkDevice device, 
  VkSamplerYcbcrConversionCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkSamplerYcbcrConversion * pYcbcrConversion);

alias PFN_vkDestroySamplerYcbcrConversion = fn void(
  VkDevice device, 
  VkSamplerYcbcrConversion ycbcrConversion, 
  VkAllocationCallbacks * pAllocator);

alias PFN_vkCreateDescriptorUpdateTemplate = fn VkResult(
  VkDevice device, 
  VkDescriptorUpdateTemplateCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkDescriptorUpdateTemplate * pDescriptorUpdateTemplate);

alias PFN_vkDestroyDescriptorUpdateTemplate = fn void(
  VkDevice device, 
  VkDescriptorUpdateTemplate descriptorUpdateTemplate, 
  VkAllocationCallbacks * pAllocator);

alias PFN_vkUpdateDescriptorSetWithTemplate = fn void(
  VkDevice device, 
  VkDescriptorSet descriptorSet, 
  VkDescriptorUpdateTemplate descriptorUpdateTemplate, 
  void * pData);

alias PFN_vkGetPhysicalDeviceExternalBufferProperties = fn void(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceExternalBufferInfo * pExternalBufferInfo, 
  VkExternalBufferProperties * pExternalBufferProperties);

alias PFN_vkGetPhysicalDeviceExternalFenceProperties = fn void(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceExternalFenceInfo * pExternalFenceInfo, 
  VkExternalFenceProperties * pExternalFenceProperties);

alias PFN_vkGetPhysicalDeviceExternalSemaphoreProperties = fn void(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceExternalSemaphoreInfo * pExternalSemaphoreInfo, 
  VkExternalSemaphoreProperties * pExternalSemaphoreProperties);

alias PFN_vkGetDescriptorSetLayoutSupport = fn void(
  VkDevice device, 
  VkDescriptorSetLayoutCreateInfo * pCreateInfo, 
  VkDescriptorSetLayoutSupport * pSupport);

fn VkResult enumerateInstanceVersion(
  uint * pApiVersion)
@extern("vkEnumerateInstanceVersion");

fn VkResult bindBufferMemory2(
  VkDevice device, 
  uint bindInfoCount, 
  VkBindBufferMemoryInfo * pBindInfos)
@extern("vkBindBufferMemory2");

fn VkResult bindImageMemory2(
  VkDevice device, 
  uint bindInfoCount, 
  VkBindImageMemoryInfo * pBindInfos)
@extern("vkBindImageMemory2");

fn void getDeviceGroupPeerMemoryFeatures(
  VkDevice device, 
  uint heapIndex, 
  uint localDeviceIndex, 
  uint remoteDeviceIndex, 
  VkPeerMemoryFeatureFlags * pPeerMemoryFeatures)
@extern("vkGetDeviceGroupPeerMemoryFeatures");

fn void cmdSetDeviceMask(
  VkCommandBuffer commandBuffer, 
  uint deviceMask)
@extern("vkCmdSetDeviceMask");

fn void cmdDispatchBase(
  VkCommandBuffer commandBuffer, 
  uint baseGroupX, 
  uint baseGroupY, 
  uint baseGroupZ, 
  uint groupCountX, 
  uint groupCountY, 
  uint groupCountZ)
@extern("vkCmdDispatchBase");

fn VkResult enumeratePhysicalDeviceGroups(
  VkInstance instance, 
  uint * pPhysicalDeviceGroupCount, 
  VkPhysicalDeviceGroupProperties * pPhysicalDeviceGroupProperties)
@extern("vkEnumeratePhysicalDeviceGroups");

fn void getImageMemoryRequirements2(
  VkDevice device, 
  VkImageMemoryRequirementsInfo2 * pInfo, 
  VkMemoryRequirements2 * pMemoryRequirements)
@extern("vkGetImageMemoryRequirements2");

fn void getBufferMemoryRequirements2(
  VkDevice device, 
  VkBufferMemoryRequirementsInfo2 * pInfo, 
  VkMemoryRequirements2 * pMemoryRequirements)
@extern("vkGetBufferMemoryRequirements2");

fn void getImageSparseMemoryRequirements2(
  VkDevice device, 
  VkImageSparseMemoryRequirementsInfo2 * pInfo, 
  uint * pSparseMemoryRequirementCount, 
  VkSparseImageMemoryRequirements2 * pSparseMemoryRequirements)
@extern("vkGetImageSparseMemoryRequirements2");

fn void getPhysicalDeviceFeatures2(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceFeatures2 * pFeatures)
@extern("vkGetPhysicalDeviceFeatures2");

fn void getPhysicalDeviceProperties2(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceProperties2 * pProperties)
@extern("vkGetPhysicalDeviceProperties2");

fn void getPhysicalDeviceFormatProperties2(
  VkPhysicalDevice physicalDevice, 
  VkFormat format, 
  VkFormatProperties2 * pFormatProperties)
@extern("vkGetPhysicalDeviceFormatProperties2");

fn VkResult getPhysicalDeviceImageFormatProperties2(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceImageFormatInfo2 * pImageFormatInfo, 
  VkImageFormatProperties2 * pImageFormatProperties)
@extern("vkGetPhysicalDeviceImageFormatProperties2");

fn void getPhysicalDeviceQueueFamilyProperties2(
  VkPhysicalDevice physicalDevice, 
  uint * pQueueFamilyPropertyCount, 
  VkQueueFamilyProperties2 * pQueueFamilyProperties)
@extern("vkGetPhysicalDeviceQueueFamilyProperties2");

fn void getPhysicalDeviceMemoryProperties2(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceMemoryProperties2 * pMemoryProperties)
@extern("vkGetPhysicalDeviceMemoryProperties2");

fn void getPhysicalDeviceSparseImageFormatProperties2(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceSparseImageFormatInfo2 * pFormatInfo, 
  uint * pPropertyCount, 
  VkSparseImageFormatProperties2 * pProperties)
@extern("vkGetPhysicalDeviceSparseImageFormatProperties2");

fn void trimCommandPool(
  VkDevice device, 
  VkCommandPool commandPool, 
  VkCommandPoolTrimFlags flags)
@extern("vkTrimCommandPool");

fn void getDeviceQueue2(
  VkDevice device, 
  VkDeviceQueueInfo2 * pQueueInfo, 
  VkQueue * pQueue)
@extern("vkGetDeviceQueue2");

fn VkResult createSamplerYcbcrConversion(
  VkDevice device, 
  VkSamplerYcbcrConversionCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkSamplerYcbcrConversion * pYcbcrConversion)
@extern("vkCreateSamplerYcbcrConversion");

fn void destroySamplerYcbcrConversion(
  VkDevice device, 
  VkSamplerYcbcrConversion ycbcrConversion, 
  VkAllocationCallbacks * pAllocator)
@extern("vkDestroySamplerYcbcrConversion");

fn VkResult createDescriptorUpdateTemplate(
  VkDevice device, 
  VkDescriptorUpdateTemplateCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkDescriptorUpdateTemplate * pDescriptorUpdateTemplate)
@extern("vkCreateDescriptorUpdateTemplate");

fn void destroyDescriptorUpdateTemplate(
  VkDevice device, 
  VkDescriptorUpdateTemplate descriptorUpdateTemplate, 
  VkAllocationCallbacks * pAllocator)
@extern("vkDestroyDescriptorUpdateTemplate");

fn void updateDescriptorSetWithTemplate(
  VkDevice device, 
  VkDescriptorSet descriptorSet, 
  VkDescriptorUpdateTemplate descriptorUpdateTemplate, 
  void * pData)
@extern("vkUpdateDescriptorSetWithTemplate");

fn void getPhysicalDeviceExternalBufferProperties(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceExternalBufferInfo * pExternalBufferInfo, 
  VkExternalBufferProperties * pExternalBufferProperties)
@extern("vkGetPhysicalDeviceExternalBufferProperties");

fn void getPhysicalDeviceExternalFenceProperties(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceExternalFenceInfo * pExternalFenceInfo, 
  VkExternalFenceProperties * pExternalFenceProperties)
@extern("vkGetPhysicalDeviceExternalFenceProperties");

fn void getPhysicalDeviceExternalSemaphoreProperties(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceExternalSemaphoreInfo * pExternalSemaphoreInfo, 
  VkExternalSemaphoreProperties * pExternalSemaphoreProperties)
@extern("vkGetPhysicalDeviceExternalSemaphoreProperties");

fn void getDescriptorSetLayoutSupport(
  VkDevice device, 
  VkDescriptorSetLayoutCreateInfo * pCreateInfo, 
  VkDescriptorSetLayoutSupport * pSupport)
@extern("vkGetDescriptorSetLayoutSupport");

typedef VkDriverId = inline CUInt;
const VkDriverId DRIVER_ID_AMD_PROPRIETARY = 1;
const VkDriverId DRIVER_ID_AMD_OPEN_SOURCE = 2;
const VkDriverId DRIVER_ID_MESA_RADV = 3;
const VkDriverId DRIVER_ID_NVIDIA_PROPRIETARY = 4;
const VkDriverId DRIVER_ID_INTEL_PROPRIETARY_WINDOWS = 5;
const VkDriverId DRIVER_ID_INTEL_OPEN_SOURCE_MESA = 6;
const VkDriverId DRIVER_ID_IMAGINATION_PROPRIETARY = 7;
const VkDriverId DRIVER_ID_QUALCOMM_PROPRIETARY = 8;
const VkDriverId DRIVER_ID_ARM_PROPRIETARY = 9;
const VkDriverId DRIVER_ID_GOOGLE_SWIFTSHADER = 10;
const VkDriverId DRIVER_ID_GGP_PROPRIETARY = 11;
const VkDriverId DRIVER_ID_BROADCOM_PROPRIETARY = 12;
const VkDriverId DRIVER_ID_MESA_LLVMPIPE = 13;
const VkDriverId DRIVER_ID_MOLTENVK = 14;
const VkDriverId DRIVER_ID_COREAVI_PROPRIETARY = 15;
const VkDriverId DRIVER_ID_JUICE_PROPRIETARY = 16;
const VkDriverId DRIVER_ID_VERISILICON_PROPRIETARY = 17;
const VkDriverId DRIVER_ID_MESA_TURNIP = 18;
const VkDriverId DRIVER_ID_MESA_V3DV = 19;
const VkDriverId DRIVER_ID_MESA_PANVK = 20;
const VkDriverId DRIVER_ID_SAMSUNG_PROPRIETARY = 21;
const VkDriverId DRIVER_ID_AMD_PROPRIETARY_KHR = DRIVER_ID_AMD_PROPRIETARY;
const VkDriverId DRIVER_ID_AMD_OPEN_SOURCE_KHR = DRIVER_ID_AMD_OPEN_SOURCE;
const VkDriverId DRIVER_ID_MESA_RADV_KHR = DRIVER_ID_MESA_RADV;
const VkDriverId DRIVER_ID_NVIDIA_PROPRIETARY_KHR = DRIVER_ID_NVIDIA_PROPRIETARY;
const VkDriverId DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR = DRIVER_ID_INTEL_PROPRIETARY_WINDOWS;
const VkDriverId DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR = DRIVER_ID_INTEL_OPEN_SOURCE_MESA;
const VkDriverId DRIVER_ID_IMAGINATION_PROPRIETARY_KHR = DRIVER_ID_IMAGINATION_PROPRIETARY;
const VkDriverId DRIVER_ID_QUALCOMM_PROPRIETARY_KHR = DRIVER_ID_QUALCOMM_PROPRIETARY;
const VkDriverId DRIVER_ID_ARM_PROPRIETARY_KHR = DRIVER_ID_ARM_PROPRIETARY;
const VkDriverId DRIVER_ID_GOOGLE_SWIFTSHADER_KHR = DRIVER_ID_GOOGLE_SWIFTSHADER;
const VkDriverId DRIVER_ID_GGP_PROPRIETARY_KHR = DRIVER_ID_GGP_PROPRIETARY;
const VkDriverId DRIVER_ID_BROADCOM_PROPRIETARY_KHR = DRIVER_ID_BROADCOM_PROPRIETARY;
const VkDriverId DRIVER_ID_MAX_ENUM = 0x7FFFFFFF;

typedef VkShaderFloatControlsIndependence = inline CUInt;
const VkShaderFloatControlsIndependence SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY = 0;
const VkShaderFloatControlsIndependence SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL = 1;
const VkShaderFloatControlsIndependence SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE = 2;
const VkShaderFloatControlsIndependence SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR = SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY;
const VkShaderFloatControlsIndependence SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR = SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL;
const VkShaderFloatControlsIndependence SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR = SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE;
const VkShaderFloatControlsIndependence SHADER_FLOAT_CONTROLS_INDEPENDENCE_MAX_ENUM = 0x7FFFFFFF;

typedef VkSamplerReductionMode = inline CUInt;
const VkSamplerReductionMode SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE = 0;
const VkSamplerReductionMode SAMPLER_REDUCTION_MODE_MIN = 1;
const VkSamplerReductionMode SAMPLER_REDUCTION_MODE_MAX = 2;
const VkSamplerReductionMode SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT = SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE;
const VkSamplerReductionMode SAMPLER_REDUCTION_MODE_MIN_EXT = SAMPLER_REDUCTION_MODE_MIN;
const VkSamplerReductionMode SAMPLER_REDUCTION_MODE_MAX_EXT = SAMPLER_REDUCTION_MODE_MAX;
const VkSamplerReductionMode SAMPLER_REDUCTION_MODE_MAX_ENUM = 0x7FFFFFFF;

typedef VkSemaphoreType = inline CUInt;
const VkSemaphoreType SEMAPHORE_TYPE_BINARY = 0;
const VkSemaphoreType SEMAPHORE_TYPE_TIMELINE = 1;
const VkSemaphoreType SEMAPHORE_TYPE_BINARY_KHR = SEMAPHORE_TYPE_BINARY;
const VkSemaphoreType SEMAPHORE_TYPE_TIMELINE_KHR = SEMAPHORE_TYPE_TIMELINE;
const VkSemaphoreType SEMAPHORE_TYPE_MAX_ENUM = 0x7FFFFFFF;

typedef VkResolveModeFlagBits = inline CUInt;
const VkResolveModeFlagBits RESOLVE_MODE_NONE = 0;
const VkResolveModeFlagBits RESOLVE_MODE_SAMPLE_ZERO_BIT = 0x00000001;
const VkResolveModeFlagBits RESOLVE_MODE_AVERAGE_BIT = 0x00000002;
const VkResolveModeFlagBits RESOLVE_MODE_MIN_BIT = 0x00000004;
const VkResolveModeFlagBits RESOLVE_MODE_MAX_BIT = 0x00000008;
const VkResolveModeFlagBits RESOLVE_MODE_NONE_KHR = RESOLVE_MODE_NONE;
const VkResolveModeFlagBits RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR = RESOLVE_MODE_SAMPLE_ZERO_BIT;
const VkResolveModeFlagBits RESOLVE_MODE_AVERAGE_BIT_KHR = RESOLVE_MODE_AVERAGE_BIT;
const VkResolveModeFlagBits RESOLVE_MODE_MIN_BIT_KHR = RESOLVE_MODE_MIN_BIT;
const VkResolveModeFlagBits RESOLVE_MODE_MAX_BIT_KHR = RESOLVE_MODE_MAX_BIT;
const VkResolveModeFlagBits RESOLVE_MODE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkResolveModeFlags = VkFlags;

typedef VkDescriptorBindingFlagBits = inline CUInt;
const VkDescriptorBindingFlagBits DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT = 0x00000001;
const VkDescriptorBindingFlagBits DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT = 0x00000002;
const VkDescriptorBindingFlagBits DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT = 0x00000004;
const VkDescriptorBindingFlagBits DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT = 0x00000008;
const VkDescriptorBindingFlagBits DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT = DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT;
const VkDescriptorBindingFlagBits DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT = DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT;
const VkDescriptorBindingFlagBits DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT = DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT;
const VkDescriptorBindingFlagBits DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT = DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT;
const VkDescriptorBindingFlagBits DESCRIPTOR_BINDING_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkDescriptorBindingFlags = VkFlags;

typedef VkSemaphoreWaitFlagBits = inline CUInt;
const VkSemaphoreWaitFlagBits SEMAPHORE_WAIT_ANY_BIT = 0x00000001;
const VkSemaphoreWaitFlagBits SEMAPHORE_WAIT_ANY_BIT_KHR = SEMAPHORE_WAIT_ANY_BIT;
const VkSemaphoreWaitFlagBits SEMAPHORE_WAIT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkSemaphoreWaitFlags = VkFlags;

struct VkPhysicalDeviceVulkan11Features {
  VkStructureType sType;
  void * pNext;
  VkBool32 storageBuffer16BitAccess;
  VkBool32 uniformAndStorageBuffer16BitAccess;
  VkBool32 storagePushConstant16;
  VkBool32 storageInputOutput16;
  VkBool32 multiview;
  VkBool32 multiviewGeometryShader;
  VkBool32 multiviewTessellationShader;
  VkBool32 variablePointersStorageBuffer;
  VkBool32 variablePointers;
  VkBool32 protectedMemory;
  VkBool32 samplerYcbcrConversion;
  VkBool32 shaderDrawParameters;
}

struct VkPhysicalDeviceVulkan11Properties {
  VkStructureType sType;
  void * pNext;
  char[16] deviceUUID;
  char[16] driverUUID;
  char[8] deviceLUID;
  uint deviceNodeMask;
  VkBool32 deviceLUIDValid;
  uint subgroupSize;
  VkShaderStageFlags subgroupSupportedStages;
  VkSubgroupFeatureFlags subgroupSupportedOperations;
  VkBool32 subgroupQuadOperationsInAllStages;
  VkPointClippingBehavior pointClippingBehavior;
  uint maxMultiviewViewCount;
  uint maxMultiviewInstanceIndex;
  VkBool32 protectedNoFault;
  uint maxPerSetDescriptors;
  VkDeviceSize maxMemoryAllocationSize;
}

struct VkPhysicalDeviceVulkan12Features {
  VkStructureType sType;
  void * pNext;
  VkBool32 samplerMirrorClampToEdge;
  VkBool32 drawIndirectCount;
  VkBool32 storageBuffer8BitAccess;
  VkBool32 uniformAndStorageBuffer8BitAccess;
  VkBool32 storagePushConstant8;
  VkBool32 shaderBufferInt64Atomics;
  VkBool32 shaderSharedInt64Atomics;
  VkBool32 shaderFloat16;
  VkBool32 shaderInt8;
  VkBool32 descriptorIndexing;
  VkBool32 shaderInputAttachmentArrayDynamicIndexing;
  VkBool32 shaderUniformTexelBufferArrayDynamicIndexing;
  VkBool32 shaderStorageTexelBufferArrayDynamicIndexing;
  VkBool32 shaderUniformBufferArrayNonUniformIndexing;
  VkBool32 shaderSampledImageArrayNonUniformIndexing;
  VkBool32 shaderStorageBufferArrayNonUniformIndexing;
  VkBool32 shaderStorageImageArrayNonUniformIndexing;
  VkBool32 shaderInputAttachmentArrayNonUniformIndexing;
  VkBool32 shaderUniformTexelBufferArrayNonUniformIndexing;
  VkBool32 shaderStorageTexelBufferArrayNonUniformIndexing;
  VkBool32 descriptorBindingUniformBufferUpdateAfterBind;
  VkBool32 descriptorBindingSampledImageUpdateAfterBind;
  VkBool32 descriptorBindingStorageImageUpdateAfterBind;
  VkBool32 descriptorBindingStorageBufferUpdateAfterBind;
  VkBool32 descriptorBindingUniformTexelBufferUpdateAfterBind;
  VkBool32 descriptorBindingStorageTexelBufferUpdateAfterBind;
  VkBool32 descriptorBindingUpdateUnusedWhilePending;
  VkBool32 descriptorBindingPartiallyBound;
  VkBool32 descriptorBindingVariableDescriptorCount;
  VkBool32 runtimeDescriptorArray;
  VkBool32 samplerFilterMinmax;
  VkBool32 scalarBlockLayout;
  VkBool32 imagelessFramebuffer;
  VkBool32 uniformBufferStandardLayout;
  VkBool32 shaderSubgroupExtendedTypes;
  VkBool32 separateDepthStencilLayouts;
  VkBool32 hostQueryReset;
  VkBool32 timelineSemaphore;
  VkBool32 bufferDeviceAddress;
  VkBool32 bufferDeviceAddressCaptureReplay;
  VkBool32 bufferDeviceAddressMultiDevice;
  VkBool32 vulkanMemoryModel;
  VkBool32 vulkanMemoryModelDeviceScope;
  VkBool32 vulkanMemoryModelAvailabilityVisibilityChains;
  VkBool32 shaderOutputViewportIndex;
  VkBool32 shaderOutputLayer;
  VkBool32 subgroupBroadcastDynamicId;
}

struct VkConformanceVersion {
  char major;
  char minor;
  char subminor;
  char patch;
}

struct VkPhysicalDeviceVulkan12Properties {
  VkStructureType sType;
  void * pNext;
  VkDriverId driverID;
  CChar[256] driverName;
  CChar[256] driverInfo;
  VkConformanceVersion conformanceVersion;
  VkShaderFloatControlsIndependence denormBehaviorIndependence;
  VkShaderFloatControlsIndependence roundingModeIndependence;
  VkBool32 shaderSignedZeroInfNanPreserveFloat16;
  VkBool32 shaderSignedZeroInfNanPreserveFloat32;
  VkBool32 shaderSignedZeroInfNanPreserveFloat64;
  VkBool32 shaderDenormPreserveFloat16;
  VkBool32 shaderDenormPreserveFloat32;
  VkBool32 shaderDenormPreserveFloat64;
  VkBool32 shaderDenormFlushToZeroFloat16;
  VkBool32 shaderDenormFlushToZeroFloat32;
  VkBool32 shaderDenormFlushToZeroFloat64;
  VkBool32 shaderRoundingModeRTEFloat16;
  VkBool32 shaderRoundingModeRTEFloat32;
  VkBool32 shaderRoundingModeRTEFloat64;
  VkBool32 shaderRoundingModeRTZFloat16;
  VkBool32 shaderRoundingModeRTZFloat32;
  VkBool32 shaderRoundingModeRTZFloat64;
  uint maxUpdateAfterBindDescriptorsInAllPools;
  VkBool32 shaderUniformBufferArrayNonUniformIndexingNative;
  VkBool32 shaderSampledImageArrayNonUniformIndexingNative;
  VkBool32 shaderStorageBufferArrayNonUniformIndexingNative;
  VkBool32 shaderStorageImageArrayNonUniformIndexingNative;
  VkBool32 shaderInputAttachmentArrayNonUniformIndexingNative;
  VkBool32 robustBufferAccessUpdateAfterBind;
  VkBool32 quadDivergentImplicitLod;
  uint maxPerStageDescriptorUpdateAfterBindSamplers;
  uint maxPerStageDescriptorUpdateAfterBindUniformBuffers;
  uint maxPerStageDescriptorUpdateAfterBindStorageBuffers;
  uint maxPerStageDescriptorUpdateAfterBindSampledImages;
  uint maxPerStageDescriptorUpdateAfterBindStorageImages;
  uint maxPerStageDescriptorUpdateAfterBindInputAttachments;
  uint maxPerStageUpdateAfterBindResources;
  uint maxDescriptorSetUpdateAfterBindSamplers;
  uint maxDescriptorSetUpdateAfterBindUniformBuffers;
  uint maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
  uint maxDescriptorSetUpdateAfterBindStorageBuffers;
  uint maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
  uint maxDescriptorSetUpdateAfterBindSampledImages;
  uint maxDescriptorSetUpdateAfterBindStorageImages;
  uint maxDescriptorSetUpdateAfterBindInputAttachments;
  VkResolveModeFlags supportedDepthResolveModes;
  VkResolveModeFlags supportedStencilResolveModes;
  VkBool32 independentResolveNone;
  VkBool32 independentResolve;
  VkBool32 filterMinmaxSingleComponentFormats;
  VkBool32 filterMinmaxImageComponentMapping;
  ulong maxTimelineSemaphoreValueDifference;
  VkSampleCountFlags framebufferIntegerColorSampleCounts;
}

struct VkImageFormatListCreateInfo {
  VkStructureType sType;
  void * pNext;
  uint viewFormatCount;
  VkFormat * pViewFormats;
}

struct VkAttachmentDescription2 {
  VkStructureType sType;
  void * pNext;
  VkAttachmentDescriptionFlags flags;
  VkFormat format;
  VkSampleCountFlagBits samples;
  VkAttachmentLoadOp loadOp;
  VkAttachmentStoreOp storeOp;
  VkAttachmentLoadOp stencilLoadOp;
  VkAttachmentStoreOp stencilStoreOp;
  VkImageLayout initialLayout;
  VkImageLayout finalLayout;
}

struct VkAttachmentReference2 {
  VkStructureType sType;
  void * pNext;
  uint attachment;
  VkImageLayout layout;
  VkImageAspectFlags aspectMask;
}

struct VkSubpassDescription2 {
  VkStructureType sType;
  void * pNext;
  VkSubpassDescriptionFlags flags;
  VkPipelineBindPoint pipelineBindPoint;
  uint viewMask;
  uint inputAttachmentCount;
  VkAttachmentReference2 * pInputAttachments;
  uint colorAttachmentCount;
  VkAttachmentReference2 * pColorAttachments;
  VkAttachmentReference2 * pResolveAttachments;
  VkAttachmentReference2 * pDepthStencilAttachment;
  uint preserveAttachmentCount;
  uint * pPreserveAttachments;
}

struct VkSubpassDependency2 {
  VkStructureType sType;
  void * pNext;
  uint srcSubpass;
  uint dstSubpass;
  VkPipelineStageFlags srcStageMask;
  VkPipelineStageFlags dstStageMask;
  VkAccessFlags srcAccessMask;
  VkAccessFlags dstAccessMask;
  VkDependencyFlags dependencyFlags;
  int viewOffset;
}

struct VkRenderPassCreateInfo2 {
  VkStructureType sType;
  void * pNext;
  VkRenderPassCreateFlags flags;
  uint attachmentCount;
  VkAttachmentDescription2 * pAttachments;
  uint subpassCount;
  VkSubpassDescription2 * pSubpasses;
  uint dependencyCount;
  VkSubpassDependency2 * pDependencies;
  uint correlatedViewMaskCount;
  uint * pCorrelatedViewMasks;
}

struct VkSubpassBeginInfo {
  VkStructureType sType;
  void * pNext;
  VkSubpassContents contents;
}

struct VkSubpassEndInfo {
  VkStructureType sType;
  void * pNext;
}

struct VkPhysicalDevice8BitStorageFeatures {
  VkStructureType sType;
  void * pNext;
  VkBool32 storageBuffer8BitAccess;
  VkBool32 uniformAndStorageBuffer8BitAccess;
  VkBool32 storagePushConstant8;
}

struct VkPhysicalDeviceDriverProperties {
  VkStructureType sType;
  void * pNext;
  VkDriverId driverID;
  CChar[256] driverName;
  CChar[256] driverInfo;
  VkConformanceVersion conformanceVersion;
}

struct VkPhysicalDeviceShaderAtomicInt64Features {
  VkStructureType sType;
  void * pNext;
  VkBool32 shaderBufferInt64Atomics;
  VkBool32 shaderSharedInt64Atomics;
}

struct VkPhysicalDeviceShaderFloat16Int8Features {
  VkStructureType sType;
  void * pNext;
  VkBool32 shaderFloat16;
  VkBool32 shaderInt8;
}

struct VkPhysicalDeviceFloatControlsProperties {
  VkStructureType sType;
  void * pNext;
  VkShaderFloatControlsIndependence denormBehaviorIndependence;
  VkShaderFloatControlsIndependence roundingModeIndependence;
  VkBool32 shaderSignedZeroInfNanPreserveFloat16;
  VkBool32 shaderSignedZeroInfNanPreserveFloat32;
  VkBool32 shaderSignedZeroInfNanPreserveFloat64;
  VkBool32 shaderDenormPreserveFloat16;
  VkBool32 shaderDenormPreserveFloat32;
  VkBool32 shaderDenormPreserveFloat64;
  VkBool32 shaderDenormFlushToZeroFloat16;
  VkBool32 shaderDenormFlushToZeroFloat32;
  VkBool32 shaderDenormFlushToZeroFloat64;
  VkBool32 shaderRoundingModeRTEFloat16;
  VkBool32 shaderRoundingModeRTEFloat32;
  VkBool32 shaderRoundingModeRTEFloat64;
  VkBool32 shaderRoundingModeRTZFloat16;
  VkBool32 shaderRoundingModeRTZFloat32;
  VkBool32 shaderRoundingModeRTZFloat64;
}

struct VkDescriptorSetLayoutBindingFlagsCreateInfo {
  VkStructureType sType;
  void * pNext;
  uint bindingCount;
  VkDescriptorBindingFlags * pBindingFlags;
}

struct VkPhysicalDeviceDescriptorIndexingFeatures {
  VkStructureType sType;
  void * pNext;
  VkBool32 shaderInputAttachmentArrayDynamicIndexing;
  VkBool32 shaderUniformTexelBufferArrayDynamicIndexing;
  VkBool32 shaderStorageTexelBufferArrayDynamicIndexing;
  VkBool32 shaderUniformBufferArrayNonUniformIndexing;
  VkBool32 shaderSampledImageArrayNonUniformIndexing;
  VkBool32 shaderStorageBufferArrayNonUniformIndexing;
  VkBool32 shaderStorageImageArrayNonUniformIndexing;
  VkBool32 shaderInputAttachmentArrayNonUniformIndexing;
  VkBool32 shaderUniformTexelBufferArrayNonUniformIndexing;
  VkBool32 shaderStorageTexelBufferArrayNonUniformIndexing;
  VkBool32 descriptorBindingUniformBufferUpdateAfterBind;
  VkBool32 descriptorBindingSampledImageUpdateAfterBind;
  VkBool32 descriptorBindingStorageImageUpdateAfterBind;
  VkBool32 descriptorBindingStorageBufferUpdateAfterBind;
  VkBool32 descriptorBindingUniformTexelBufferUpdateAfterBind;
  VkBool32 descriptorBindingStorageTexelBufferUpdateAfterBind;
  VkBool32 descriptorBindingUpdateUnusedWhilePending;
  VkBool32 descriptorBindingPartiallyBound;
  VkBool32 descriptorBindingVariableDescriptorCount;
  VkBool32 runtimeDescriptorArray;
}

struct VkPhysicalDeviceDescriptorIndexingProperties {
  VkStructureType sType;
  void * pNext;
  uint maxUpdateAfterBindDescriptorsInAllPools;
  VkBool32 shaderUniformBufferArrayNonUniformIndexingNative;
  VkBool32 shaderSampledImageArrayNonUniformIndexingNative;
  VkBool32 shaderStorageBufferArrayNonUniformIndexingNative;
  VkBool32 shaderStorageImageArrayNonUniformIndexingNative;
  VkBool32 shaderInputAttachmentArrayNonUniformIndexingNative;
  VkBool32 robustBufferAccessUpdateAfterBind;
  VkBool32 quadDivergentImplicitLod;
  uint maxPerStageDescriptorUpdateAfterBindSamplers;
  uint maxPerStageDescriptorUpdateAfterBindUniformBuffers;
  uint maxPerStageDescriptorUpdateAfterBindStorageBuffers;
  uint maxPerStageDescriptorUpdateAfterBindSampledImages;
  uint maxPerStageDescriptorUpdateAfterBindStorageImages;
  uint maxPerStageDescriptorUpdateAfterBindInputAttachments;
  uint maxPerStageUpdateAfterBindResources;
  uint maxDescriptorSetUpdateAfterBindSamplers;
  uint maxDescriptorSetUpdateAfterBindUniformBuffers;
  uint maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
  uint maxDescriptorSetUpdateAfterBindStorageBuffers;
  uint maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
  uint maxDescriptorSetUpdateAfterBindSampledImages;
  uint maxDescriptorSetUpdateAfterBindStorageImages;
  uint maxDescriptorSetUpdateAfterBindInputAttachments;
}

struct VkDescriptorSetVariableDescriptorCountAllocateInfo {
  VkStructureType sType;
  void * pNext;
  uint descriptorSetCount;
  uint * pDescriptorCounts;
}

struct VkDescriptorSetVariableDescriptorCountLayoutSupport {
  VkStructureType sType;
  void * pNext;
  uint maxVariableDescriptorCount;
}

struct VkSubpassDescriptionDepthStencilResolve {
  VkStructureType sType;
  void * pNext;
  VkResolveModeFlagBits depthResolveMode;
  VkResolveModeFlagBits stencilResolveMode;
  VkAttachmentReference2 * pDepthStencilResolveAttachment;
}

struct VkPhysicalDeviceDepthStencilResolveProperties {
  VkStructureType sType;
  void * pNext;
  VkResolveModeFlags supportedDepthResolveModes;
  VkResolveModeFlags supportedStencilResolveModes;
  VkBool32 independentResolveNone;
  VkBool32 independentResolve;
}

struct VkPhysicalDeviceScalarBlockLayoutFeatures {
  VkStructureType sType;
  void * pNext;
  VkBool32 scalarBlockLayout;
}

struct VkImageStencilUsageCreateInfo {
  VkStructureType sType;
  void * pNext;
  VkImageUsageFlags stencilUsage;
}

struct VkSamplerReductionModeCreateInfo {
  VkStructureType sType;
  void * pNext;
  VkSamplerReductionMode reductionMode;
}

struct VkPhysicalDeviceSamplerFilterMinmaxProperties {
  VkStructureType sType;
  void * pNext;
  VkBool32 filterMinmaxSingleComponentFormats;
  VkBool32 filterMinmaxImageComponentMapping;
}

struct VkPhysicalDeviceVulkanMemoryModelFeatures {
  VkStructureType sType;
  void * pNext;
  VkBool32 vulkanMemoryModel;
  VkBool32 vulkanMemoryModelDeviceScope;
  VkBool32 vulkanMemoryModelAvailabilityVisibilityChains;
}

struct VkPhysicalDeviceImagelessFramebufferFeatures {
  VkStructureType sType;
  void * pNext;
  VkBool32 imagelessFramebuffer;
}

struct VkFramebufferAttachmentImageInfo {
  VkStructureType sType;
  void * pNext;
  VkImageCreateFlags flags;
  VkImageUsageFlags usage;
  uint width;
  uint height;
  uint layerCount;
  uint viewFormatCount;
  VkFormat * pViewFormats;
}

struct VkFramebufferAttachmentsCreateInfo {
  VkStructureType sType;
  void * pNext;
  uint attachmentImageInfoCount;
  VkFramebufferAttachmentImageInfo * pAttachmentImageInfos;
}

struct VkRenderPassAttachmentBeginInfo {
  VkStructureType sType;
  void * pNext;
  uint attachmentCount;
  VkImageView * pAttachments;
}

struct VkPhysicalDeviceUniformBufferStandardLayoutFeatures {
  VkStructureType sType;
  void * pNext;
  VkBool32 uniformBufferStandardLayout;
}

struct VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures {
  VkStructureType sType;
  void * pNext;
  VkBool32 shaderSubgroupExtendedTypes;
}

struct VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures {
  VkStructureType sType;
  void * pNext;
  VkBool32 separateDepthStencilLayouts;
}

struct VkAttachmentReferenceStencilLayout {
  VkStructureType sType;
  void * pNext;
  VkImageLayout stencilLayout;
}

struct VkAttachmentDescriptionStencilLayout {
  VkStructureType sType;
  void * pNext;
  VkImageLayout stencilInitialLayout;
  VkImageLayout stencilFinalLayout;
}

struct VkPhysicalDeviceHostQueryResetFeatures {
  VkStructureType sType;
  void * pNext;
  VkBool32 hostQueryReset;
}

struct VkPhysicalDeviceTimelineSemaphoreFeatures {
  VkStructureType sType;
  void * pNext;
  VkBool32 timelineSemaphore;
}

struct VkPhysicalDeviceTimelineSemaphoreProperties {
  VkStructureType sType;
  void * pNext;
  ulong maxTimelineSemaphoreValueDifference;
}

struct VkSemaphoreTypeCreateInfo {
  VkStructureType sType;
  void * pNext;
  VkSemaphoreType semaphoreType;
  ulong initialValue;
}

struct VkTimelineSemaphoreSubmitInfo {
  VkStructureType sType;
  void * pNext;
  uint waitSemaphoreValueCount;
  ulong * pWaitSemaphoreValues;
  uint signalSemaphoreValueCount;
  ulong * pSignalSemaphoreValues;
}

struct VkSemaphoreWaitInfo {
  VkStructureType sType;
  void * pNext;
  VkSemaphoreWaitFlags flags;
  uint semaphoreCount;
  VkSemaphore * pSemaphores;
  ulong * pValues;
}

struct VkSemaphoreSignalInfo {
  VkStructureType sType;
  void * pNext;
  VkSemaphore semaphore;
  ulong value;
}

struct VkPhysicalDeviceBufferDeviceAddressFeatures {
  VkStructureType sType;
  void * pNext;
  VkBool32 bufferDeviceAddress;
  VkBool32 bufferDeviceAddressCaptureReplay;
  VkBool32 bufferDeviceAddressMultiDevice;
}

struct VkBufferDeviceAddressInfo {
  VkStructureType sType;
  void * pNext;
  VkBuffer buffer;
}

struct VkBufferOpaqueCaptureAddressCreateInfo {
  VkStructureType sType;
  void * pNext;
  ulong opaqueCaptureAddress;
}

struct VkMemoryOpaqueCaptureAddressAllocateInfo {
  VkStructureType sType;
  void * pNext;
  ulong opaqueCaptureAddress;
}

struct VkDeviceMemoryOpaqueCaptureAddressInfo {
  VkStructureType sType;
  void * pNext;
  VkDeviceMemory memory;
}

alias PFN_vkCmdDrawIndirectCount = fn void(
  VkCommandBuffer commandBuffer, 
  VkBuffer buffer, 
  VkDeviceSize offset, 
  VkBuffer countBuffer, 
  VkDeviceSize countBufferOffset, 
  uint maxDrawCount, 
  uint stride);

alias PFN_vkCmdDrawIndexedIndirectCount = fn void(
  VkCommandBuffer commandBuffer, 
  VkBuffer buffer, 
  VkDeviceSize offset, 
  VkBuffer countBuffer, 
  VkDeviceSize countBufferOffset, 
  uint maxDrawCount, 
  uint stride);

alias PFN_vkCreateRenderPass2 = fn VkResult(
  VkDevice device, 
  VkRenderPassCreateInfo2 * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkRenderPass * pRenderPass);

alias PFN_vkCmdBeginRenderPass2 = fn void(
  VkCommandBuffer commandBuffer, 
  VkRenderPassBeginInfo * pRenderPassBegin, 
  VkSubpassBeginInfo * pSubpassBeginInfo);

alias PFN_vkCmdNextSubpass2 = fn void(
  VkCommandBuffer commandBuffer, 
  VkSubpassBeginInfo * pSubpassBeginInfo, 
  VkSubpassEndInfo * pSubpassEndInfo);

alias PFN_vkCmdEndRenderPass2 = fn void(
  VkCommandBuffer commandBuffer, 
  VkSubpassEndInfo * pSubpassEndInfo);

alias PFN_vkResetQueryPool = fn void(
  VkDevice device, 
  VkQueryPool queryPool, 
  uint firstQuery, 
  uint queryCount);

alias PFN_vkGetSemaphoreCounterValue = fn VkResult(
  VkDevice device, 
  VkSemaphore semaphore, 
  ulong * pValue);

alias PFN_vkWaitSemaphores = fn VkResult(
  VkDevice device, 
  VkSemaphoreWaitInfo * pWaitInfo, 
  ulong timeout);

alias PFN_vkSignalSemaphore = fn VkResult(
  VkDevice device, 
  VkSemaphoreSignalInfo * pSignalInfo);

alias PFN_vkGetBufferDeviceAddress = fn VkDeviceAddress(
  VkDevice device, 
  VkBufferDeviceAddressInfo * pInfo);

alias PFN_vkGetBufferOpaqueCaptureAddress = fn ulong(
  VkDevice device, 
  VkBufferDeviceAddressInfo * pInfo);

alias PFN_vkGetDeviceMemoryOpaqueCaptureAddress = fn ulong(
  VkDevice device, 
  VkDeviceMemoryOpaqueCaptureAddressInfo * pInfo);

fn void cmdDrawIndirectCount(
  VkCommandBuffer commandBuffer, 
  VkBuffer buffer, 
  VkDeviceSize offset, 
  VkBuffer countBuffer, 
  VkDeviceSize countBufferOffset, 
  uint maxDrawCount, 
  uint stride)
@extern("vkCmdDrawIndirectCount");

fn void cmdDrawIndexedIndirectCount(
  VkCommandBuffer commandBuffer, 
  VkBuffer buffer, 
  VkDeviceSize offset, 
  VkBuffer countBuffer, 
  VkDeviceSize countBufferOffset, 
  uint maxDrawCount, 
  uint stride)
@extern("vkCmdDrawIndexedIndirectCount");

fn VkResult createRenderPass2(
  VkDevice device, 
  VkRenderPassCreateInfo2 * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkRenderPass * pRenderPass)
@extern("vkCreateRenderPass2");

fn void cmdBeginRenderPass2(
  VkCommandBuffer commandBuffer, 
  VkRenderPassBeginInfo * pRenderPassBegin, 
  VkSubpassBeginInfo * pSubpassBeginInfo)
@extern("vkCmdBeginRenderPass2");

fn void cmdNextSubpass2(
  VkCommandBuffer commandBuffer, 
  VkSubpassBeginInfo * pSubpassBeginInfo, 
  VkSubpassEndInfo * pSubpassEndInfo)
@extern("vkCmdNextSubpass2");

fn void cmdEndRenderPass2(
  VkCommandBuffer commandBuffer, 
  VkSubpassEndInfo * pSubpassEndInfo)
@extern("vkCmdEndRenderPass2");

fn void resetQueryPool(
  VkDevice device, 
  VkQueryPool queryPool, 
  uint firstQuery, 
  uint queryCount)
@extern("vkResetQueryPool");

fn VkResult getSemaphoreCounterValue(
  VkDevice device, 
  VkSemaphore semaphore, 
  ulong * pValue)
@extern("vkGetSemaphoreCounterValue");

fn VkResult waitSemaphores(
  VkDevice device, 
  VkSemaphoreWaitInfo * pWaitInfo, 
  ulong timeout)
@extern("vkWaitSemaphores");

fn VkResult signalSemaphore(
  VkDevice device, 
  VkSemaphoreSignalInfo * pSignalInfo)
@extern("vkSignalSemaphore");

fn VkDeviceAddress getBufferDeviceAddress(
  VkDevice device, 
  VkBufferDeviceAddressInfo * pInfo)
@extern("vkGetBufferDeviceAddress");

fn ulong getBufferOpaqueCaptureAddress(
  VkDevice device, 
  VkBufferDeviceAddressInfo * pInfo)
@extern("vkGetBufferOpaqueCaptureAddress");

fn ulong getDeviceMemoryOpaqueCaptureAddress(
  VkDevice device, 
  VkDeviceMemoryOpaqueCaptureAddressInfo * pInfo)
@extern("vkGetDeviceMemoryOpaqueCaptureAddress");

typedef VkSurfaceKHR_T = void;

alias VkSurfaceKHR = VkSurfaceKHR_T *;

typedef VkPresentModeKHR = inline CUInt;
const VkPresentModeKHR PRESENT_MODE_IMMEDIATE_KHR = 0;
const VkPresentModeKHR PRESENT_MODE_MAILBOX_KHR = 1;
const VkPresentModeKHR PRESENT_MODE_FIFO_KHR = 2;
const VkPresentModeKHR PRESENT_MODE_FIFO_RELAXED_KHR = 3;
const VkPresentModeKHR PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR = 1000111000;
const VkPresentModeKHR PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR = 1000111001;
const VkPresentModeKHR PRESENT_MODE_MAX_ENUM_KHR = 0x7FFFFFFF;

typedef VkColorSpaceKHR = inline CUInt;
const VkColorSpaceKHR COLOR_SPACE_SRGB_NONLINEAR_KHR = 0;
const VkColorSpaceKHR COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT = 1000104001;
const VkColorSpaceKHR COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT = 1000104002;
const VkColorSpaceKHR COLOR_SPACE_DISPLAY_P3_LINEAR_EXT = 1000104003;
const VkColorSpaceKHR COLOR_SPACE_DCI_P3_NONLINEAR_EXT = 1000104004;
const VkColorSpaceKHR COLOR_SPACE_BT709_LINEAR_EXT = 1000104005;
const VkColorSpaceKHR COLOR_SPACE_BT709_NONLINEAR_EXT = 1000104006;
const VkColorSpaceKHR COLOR_SPACE_BT2020_LINEAR_EXT = 1000104007;
const VkColorSpaceKHR COLOR_SPACE_HDR10_ST2084_EXT = 1000104008;
const VkColorSpaceKHR COLOR_SPACE_DOLBYVISION_EXT = 1000104009;
const VkColorSpaceKHR COLOR_SPACE_HDR10_HLG_EXT = 1000104010;
const VkColorSpaceKHR COLOR_SPACE_ADOBERGB_LINEAR_EXT = 1000104011;
const VkColorSpaceKHR COLOR_SPACE_ADOBERGB_NONLINEAR_EXT = 1000104012;
const VkColorSpaceKHR COLOR_SPACE_PASS_THROUGH_EXT = 1000104013;
const VkColorSpaceKHR COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT = 1000104014;
const VkColorSpaceKHR COLOR_SPACE_DISPLAY_NATIVE_AMD = 1000213000;
const VkColorSpaceKHR COLORSPACE_SRGB_NONLINEAR_KHR = COLOR_SPACE_SRGB_NONLINEAR_KHR;
const VkColorSpaceKHR COLOR_SPACE_DCI_P3_LINEAR_EXT = COLOR_SPACE_DISPLAY_P3_LINEAR_EXT;
const VkColorSpaceKHR COLOR_SPACE_MAX_ENUM_KHR = 0x7FFFFFFF;

typedef VkSurfaceTransformFlagBitsKHR = inline CUInt;
const VkSurfaceTransformFlagBitsKHR SURFACE_TRANSFORM_IDENTITY_BIT_KHR = 0x00000001;
const VkSurfaceTransformFlagBitsKHR SURFACE_TRANSFORM_ROTATE_90_BIT_KHR = 0x00000002;
const VkSurfaceTransformFlagBitsKHR SURFACE_TRANSFORM_ROTATE_180_BIT_KHR = 0x00000004;
const VkSurfaceTransformFlagBitsKHR SURFACE_TRANSFORM_ROTATE_270_BIT_KHR = 0x00000008;
const VkSurfaceTransformFlagBitsKHR SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR = 0x00000010;
const VkSurfaceTransformFlagBitsKHR SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = 0x00000020;
const VkSurfaceTransformFlagBitsKHR SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = 0x00000040;
const VkSurfaceTransformFlagBitsKHR SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = 0x00000080;
const VkSurfaceTransformFlagBitsKHR SURFACE_TRANSFORM_INHERIT_BIT_KHR = 0x00000100;
const VkSurfaceTransformFlagBitsKHR SURFACE_TRANSFORM_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF;

typedef VkCompositeAlphaFlagBitsKHR = inline CUInt;
const VkCompositeAlphaFlagBitsKHR COMPOSITE_ALPHA_OPAQUE_BIT_KHR = 0x00000001;
const VkCompositeAlphaFlagBitsKHR COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR = 0x00000002;
const VkCompositeAlphaFlagBitsKHR COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR = 0x00000004;
const VkCompositeAlphaFlagBitsKHR COMPOSITE_ALPHA_INHERIT_BIT_KHR = 0x00000008;
const VkCompositeAlphaFlagBitsKHR COMPOSITE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF;

alias VkCompositeAlphaFlagsKHR = VkFlags;

alias VkSurfaceTransformFlagsKHR = VkFlags;

struct VkSurfaceCapabilitiesKHR {
  uint minImageCount;
  uint maxImageCount;
  VkExtent2D currentExtent;
  VkExtent2D minImageExtent;
  VkExtent2D maxImageExtent;
  uint maxImageArrayLayers;
  VkSurfaceTransformFlagsKHR supportedTransforms;
  VkSurfaceTransformFlagBitsKHR currentTransform;
  VkCompositeAlphaFlagsKHR supportedCompositeAlpha;
  VkImageUsageFlags supportedUsageFlags;
}

struct VkSurfaceFormatKHR {
  VkFormat format;
  VkColorSpaceKHR colorSpace;
}

alias PFN_vkDestroySurfaceKHR = fn void(
  VkInstance instance, 
  VkSurfaceKHR surface, 
  VkAllocationCallbacks * pAllocator);

alias PFN_vkGetPhysicalDeviceSurfaceSupportKHR = fn VkResult(
  VkPhysicalDevice physicalDevice, 
  uint queueFamilyIndex, 
  VkSurfaceKHR surface, 
  VkBool32 * pSupported);

alias PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR = fn VkResult(
  VkPhysicalDevice physicalDevice, 
  VkSurfaceKHR surface, 
  VkSurfaceCapabilitiesKHR * pSurfaceCapabilities);

alias PFN_vkGetPhysicalDeviceSurfaceFormatsKHR = fn VkResult(
  VkPhysicalDevice physicalDevice, 
  VkSurfaceKHR surface, 
  uint * pSurfaceFormatCount, 
  VkSurfaceFormatKHR * pSurfaceFormats);

alias PFN_vkGetPhysicalDeviceSurfacePresentModesKHR = fn VkResult(
  VkPhysicalDevice physicalDevice, 
  VkSurfaceKHR surface, 
  uint * pPresentModeCount, 
  VkPresentModeKHR * pPresentModes);

fn void destroySurfaceKHR(
  VkInstance instance, 
  VkSurfaceKHR surface, 
  VkAllocationCallbacks * pAllocator)
@extern("vkDestroySurfaceKHR");

fn VkResult getPhysicalDeviceSurfaceSupportKHR(
  VkPhysicalDevice physicalDevice, 
  uint queueFamilyIndex, 
  VkSurfaceKHR surface, 
  VkBool32 * pSupported)
@extern("vkGetPhysicalDeviceSurfaceSupportKHR");

fn VkResult getPhysicalDeviceSurfaceCapabilitiesKHR(
  VkPhysicalDevice physicalDevice, 
  VkSurfaceKHR surface, 
  VkSurfaceCapabilitiesKHR * pSurfaceCapabilities)
@extern("vkGetPhysicalDeviceSurfaceCapabilitiesKHR");

fn VkResult getPhysicalDeviceSurfaceFormatsKHR(
  VkPhysicalDevice physicalDevice, 
  VkSurfaceKHR surface, 
  uint * pSurfaceFormatCount, 
  VkSurfaceFormatKHR * pSurfaceFormats)
@extern("vkGetPhysicalDeviceSurfaceFormatsKHR");

fn VkResult getPhysicalDeviceSurfacePresentModesKHR(
  VkPhysicalDevice physicalDevice, 
  VkSurfaceKHR surface, 
  uint * pPresentModeCount, 
  VkPresentModeKHR * pPresentModes)
@extern("vkGetPhysicalDeviceSurfacePresentModesKHR");

typedef VkSwapchainKHR_T = void;

alias VkSwapchainKHR = VkSwapchainKHR_T *;

typedef VkSwapchainCreateFlagBitsKHR = inline CUInt;
const VkSwapchainCreateFlagBitsKHR SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = 0x00000001;
const VkSwapchainCreateFlagBitsKHR SWAPCHAIN_CREATE_PROTECTED_BIT_KHR = 0x00000002;
const VkSwapchainCreateFlagBitsKHR SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR = 0x00000004;
const VkSwapchainCreateFlagBitsKHR SWAPCHAIN_CREATE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF;

alias VkSwapchainCreateFlagsKHR = VkFlags;

typedef VkDeviceGroupPresentModeFlagBitsKHR = inline CUInt;
const VkDeviceGroupPresentModeFlagBitsKHR DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR = 0x00000001;
const VkDeviceGroupPresentModeFlagBitsKHR DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR = 0x00000002;
const VkDeviceGroupPresentModeFlagBitsKHR DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR = 0x00000004;
const VkDeviceGroupPresentModeFlagBitsKHR DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR = 0x00000008;
const VkDeviceGroupPresentModeFlagBitsKHR DEVICE_GROUP_PRESENT_MODE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF;

alias VkDeviceGroupPresentModeFlagsKHR = VkFlags;

struct VkSwapchainCreateInfoKHR {
  VkStructureType sType;
  void * pNext;
  VkSwapchainCreateFlagsKHR flags;
  VkSurfaceKHR surface;
  uint minImageCount;
  VkFormat imageFormat;
  VkColorSpaceKHR imageColorSpace;
  VkExtent2D imageExtent;
  uint imageArrayLayers;
  VkImageUsageFlags imageUsage;
  VkSharingMode imageSharingMode;
  uint queueFamilyIndexCount;
  uint * pQueueFamilyIndices;
  VkSurfaceTransformFlagBitsKHR preTransform;
  VkCompositeAlphaFlagBitsKHR compositeAlpha;
  VkPresentModeKHR presentMode;
  VkBool32 clipped;
  VkSwapchainKHR oldSwapchain;
}

struct VkPresentInfoKHR {
  VkStructureType sType;
  void * pNext;
  uint waitSemaphoreCount;
  VkSemaphore * pWaitSemaphores;
  uint swapchainCount;
  VkSwapchainKHR * pSwapchains;
  uint * pImageIndices;
  VkResult * pResults;
}

struct VkImageSwapchainCreateInfoKHR {
  VkStructureType sType;
  void * pNext;
  VkSwapchainKHR swapchain;
}

struct VkBindImageMemorySwapchainInfoKHR {
  VkStructureType sType;
  void * pNext;
  VkSwapchainKHR swapchain;
  uint imageIndex;
}

struct VkAcquireNextImageInfoKHR {
  VkStructureType sType;
  void * pNext;
  VkSwapchainKHR swapchain;
  ulong timeout;
  VkSemaphore semaphore;
  VkFence fence;
  uint deviceMask;
}

struct VkDeviceGroupPresentCapabilitiesKHR {
  VkStructureType sType;
  void * pNext;
  uint[32] presentMask;
  VkDeviceGroupPresentModeFlagsKHR modes;
}

struct VkDeviceGroupPresentInfoKHR {
  VkStructureType sType;
  void * pNext;
  uint swapchainCount;
  uint * pDeviceMasks;
  VkDeviceGroupPresentModeFlagBitsKHR mode;
}

struct VkDeviceGroupSwapchainCreateInfoKHR {
  VkStructureType sType;
  void * pNext;
  VkDeviceGroupPresentModeFlagsKHR modes;
}

alias PFN_vkCreateSwapchainKHR = fn VkResult(
  VkDevice device, 
  VkSwapchainCreateInfoKHR * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkSwapchainKHR * pSwapchain);

alias PFN_vkDestroySwapchainKHR = fn void(
  VkDevice device, 
  VkSwapchainKHR swapchain, 
  VkAllocationCallbacks * pAllocator);

alias PFN_vkGetSwapchainImagesKHR = fn VkResult(
  VkDevice device, 
  VkSwapchainKHR swapchain, 
  uint * pSwapchainImageCount, 
  VkImage * pSwapchainImages);

alias PFN_vkAcquireNextImageKHR = fn VkResult(
  VkDevice device, 
  VkSwapchainKHR swapchain, 
  ulong timeout, 
  VkSemaphore semaphore, 
  VkFence fence, 
  uint * pImageIndex);

alias PFN_vkQueuePresentKHR = fn VkResult(
  VkQueue queue, 
  VkPresentInfoKHR * pPresentInfo);

alias PFN_vkGetDeviceGroupPresentCapabilitiesKHR = fn VkResult(
  VkDevice device, 
  VkDeviceGroupPresentCapabilitiesKHR * pDeviceGroupPresentCapabilities);

alias PFN_vkGetDeviceGroupSurfacePresentModesKHR = fn VkResult(
  VkDevice device, 
  VkSurfaceKHR surface, 
  VkDeviceGroupPresentModeFlagsKHR * pModes);

alias PFN_vkGetPhysicalDevicePresentRectanglesKHR = fn VkResult(
  VkPhysicalDevice physicalDevice, 
  VkSurfaceKHR surface, 
  uint * pRectCount, 
  VkRect2D * pRects);

alias PFN_vkAcquireNextImage2KHR = fn VkResult(
  VkDevice device, 
  VkAcquireNextImageInfoKHR * pAcquireInfo, 
  uint * pImageIndex);

fn VkResult createSwapchainKHR(
  VkDevice device, 
  VkSwapchainCreateInfoKHR * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkSwapchainKHR * pSwapchain)
@extern("vkCreateSwapchainKHR");

fn void destroySwapchainKHR(
  VkDevice device, 
  VkSwapchainKHR swapchain, 
  VkAllocationCallbacks * pAllocator)
@extern("vkDestroySwapchainKHR");

fn VkResult getSwapchainImagesKHR(
  VkDevice device, 
  VkSwapchainKHR swapchain, 
  uint * pSwapchainImageCount, 
  VkImage * pSwapchainImages)
@extern("vkGetSwapchainImagesKHR");

fn VkResult acquireNextImageKHR(
  VkDevice device, 
  VkSwapchainKHR swapchain, 
  ulong timeout, 
  VkSemaphore semaphore, 
  VkFence fence, 
  uint * pImageIndex)
@extern("vkAcquireNextImageKHR");

fn VkResult queuePresentKHR(
  VkQueue queue, 
  VkPresentInfoKHR * pPresentInfo)
@extern("vkQueuePresentKHR");

fn VkResult getDeviceGroupPresentCapabilitiesKHR(
  VkDevice device, 
  VkDeviceGroupPresentCapabilitiesKHR * pDeviceGroupPresentCapabilities)
@extern("vkGetDeviceGroupPresentCapabilitiesKHR");

fn VkResult getDeviceGroupSurfacePresentModesKHR(
  VkDevice device, 
  VkSurfaceKHR surface, 
  VkDeviceGroupPresentModeFlagsKHR * pModes)
@extern("vkGetDeviceGroupSurfacePresentModesKHR");

fn VkResult getPhysicalDevicePresentRectanglesKHR(
  VkPhysicalDevice physicalDevice, 
  VkSurfaceKHR surface, 
  uint * pRectCount, 
  VkRect2D * pRects)
@extern("vkGetPhysicalDevicePresentRectanglesKHR");

fn VkResult acquireNextImage2KHR(
  VkDevice device, 
  VkAcquireNextImageInfoKHR * pAcquireInfo, 
  uint * pImageIndex)
@extern("vkAcquireNextImage2KHR");

typedef VkDisplayKHR_T = void;

alias VkDisplayKHR = VkDisplayKHR_T *;

typedef VkDisplayModeKHR_T = void;

alias VkDisplayModeKHR = VkDisplayModeKHR_T *;

alias VkDisplayModeCreateFlagsKHR = VkFlags;

typedef VkDisplayPlaneAlphaFlagBitsKHR = inline CUInt;
const VkDisplayPlaneAlphaFlagBitsKHR DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR = 0x00000001;
const VkDisplayPlaneAlphaFlagBitsKHR DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR = 0x00000002;
const VkDisplayPlaneAlphaFlagBitsKHR DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR = 0x00000004;
const VkDisplayPlaneAlphaFlagBitsKHR DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR = 0x00000008;
const VkDisplayPlaneAlphaFlagBitsKHR DISPLAY_PLANE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF;

alias VkDisplayPlaneAlphaFlagsKHR = VkFlags;

alias VkDisplaySurfaceCreateFlagsKHR = VkFlags;

struct VkDisplayModeParametersKHR {
  VkExtent2D visibleRegion;
  uint refreshRate;
}

struct VkDisplayModeCreateInfoKHR {
  VkStructureType sType;
  void * pNext;
  VkDisplayModeCreateFlagsKHR flags;
  VkDisplayModeParametersKHR parameters;
}

struct VkDisplayModePropertiesKHR {
  VkDisplayModeKHR displayMode;
  VkDisplayModeParametersKHR parameters;
}

struct VkDisplayPlaneCapabilitiesKHR {
  VkDisplayPlaneAlphaFlagsKHR supportedAlpha;
  VkOffset2D minSrcPosition;
  VkOffset2D maxSrcPosition;
  VkExtent2D minSrcExtent;
  VkExtent2D maxSrcExtent;
  VkOffset2D minDstPosition;
  VkOffset2D maxDstPosition;
  VkExtent2D minDstExtent;
  VkExtent2D maxDstExtent;
}

struct VkDisplayPlanePropertiesKHR {
  VkDisplayKHR currentDisplay;
  uint currentStackIndex;
}

struct VkDisplayPropertiesKHR {
  VkDisplayKHR display;
  CChar * displayName;
  VkExtent2D physicalDimensions;
  VkExtent2D physicalResolution;
  VkSurfaceTransformFlagsKHR supportedTransforms;
  VkBool32 planeReorderPossible;
  VkBool32 persistentContent;
}

struct VkDisplaySurfaceCreateInfoKHR {
  VkStructureType sType;
  void * pNext;
  VkDisplaySurfaceCreateFlagsKHR flags;
  VkDisplayModeKHR displayMode;
  uint planeIndex;
  uint planeStackIndex;
  VkSurfaceTransformFlagBitsKHR transform;
  float globalAlpha;
  VkDisplayPlaneAlphaFlagBitsKHR alphaMode;
  VkExtent2D imageExtent;
}

alias PFN_vkGetPhysicalDeviceDisplayPropertiesKHR = fn VkResult(
  VkPhysicalDevice physicalDevice, 
  uint * pPropertyCount, 
  VkDisplayPropertiesKHR * pProperties);

alias PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR = fn VkResult(
  VkPhysicalDevice physicalDevice, 
  uint * pPropertyCount, 
  VkDisplayPlanePropertiesKHR * pProperties);

alias PFN_vkGetDisplayPlaneSupportedDisplaysKHR = fn VkResult(
  VkPhysicalDevice physicalDevice, 
  uint planeIndex, 
  uint * pDisplayCount, 
  VkDisplayKHR * pDisplays);

alias PFN_vkGetDisplayModePropertiesKHR = fn VkResult(
  VkPhysicalDevice physicalDevice, 
  VkDisplayKHR display, 
  uint * pPropertyCount, 
  VkDisplayModePropertiesKHR * pProperties);

alias PFN_vkCreateDisplayModeKHR = fn VkResult(
  VkPhysicalDevice physicalDevice, 
  VkDisplayKHR display, 
  VkDisplayModeCreateInfoKHR * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkDisplayModeKHR * pMode);

alias PFN_vkGetDisplayPlaneCapabilitiesKHR = fn VkResult(
  VkPhysicalDevice physicalDevice, 
  VkDisplayModeKHR mode, 
  uint planeIndex, 
  VkDisplayPlaneCapabilitiesKHR * pCapabilities);

alias PFN_vkCreateDisplayPlaneSurfaceKHR = fn VkResult(
  VkInstance instance, 
  VkDisplaySurfaceCreateInfoKHR * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkSurfaceKHR * pSurface);

fn VkResult getPhysicalDeviceDisplayPropertiesKHR(
  VkPhysicalDevice physicalDevice, 
  uint * pPropertyCount, 
  VkDisplayPropertiesKHR * pProperties)
@extern("vkGetPhysicalDeviceDisplayPropertiesKHR");

fn VkResult getPhysicalDeviceDisplayPlanePropertiesKHR(
  VkPhysicalDevice physicalDevice, 
  uint * pPropertyCount, 
  VkDisplayPlanePropertiesKHR * pProperties)
@extern("vkGetPhysicalDeviceDisplayPlanePropertiesKHR");

fn VkResult getDisplayPlaneSupportedDisplaysKHR(
  VkPhysicalDevice physicalDevice, 
  uint planeIndex, 
  uint * pDisplayCount, 
  VkDisplayKHR * pDisplays)
@extern("vkGetDisplayPlaneSupportedDisplaysKHR");

fn VkResult getDisplayModePropertiesKHR(
  VkPhysicalDevice physicalDevice, 
  VkDisplayKHR display, 
  uint * pPropertyCount, 
  VkDisplayModePropertiesKHR * pProperties)
@extern("vkGetDisplayModePropertiesKHR");

fn VkResult createDisplayModeKHR(
  VkPhysicalDevice physicalDevice, 
  VkDisplayKHR display, 
  VkDisplayModeCreateInfoKHR * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkDisplayModeKHR * pMode)
@extern("vkCreateDisplayModeKHR");

fn VkResult getDisplayPlaneCapabilitiesKHR(
  VkPhysicalDevice physicalDevice, 
  VkDisplayModeKHR mode, 
  uint planeIndex, 
  VkDisplayPlaneCapabilitiesKHR * pCapabilities)
@extern("vkGetDisplayPlaneCapabilitiesKHR");

fn VkResult createDisplayPlaneSurfaceKHR(
  VkInstance instance, 
  VkDisplaySurfaceCreateInfoKHR * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkSurfaceKHR * pSurface)
@extern("vkCreateDisplayPlaneSurfaceKHR");

struct VkDisplayPresentInfoKHR {
  VkStructureType sType;
  void * pNext;
  VkRect2D srcRect;
  VkRect2D dstRect;
  VkBool32 persistent;
}

alias PFN_vkCreateSharedSwapchainsKHR = fn VkResult(
  VkDevice device, 
  uint swapchainCount, 
  VkSwapchainCreateInfoKHR * pCreateInfos, 
  VkAllocationCallbacks * pAllocator, 
  VkSwapchainKHR * pSwapchains);

fn VkResult createSharedSwapchainsKHR(
  VkDevice device, 
  uint swapchainCount, 
  VkSwapchainCreateInfoKHR * pCreateInfos, 
  VkAllocationCallbacks * pAllocator, 
  VkSwapchainKHR * pSwapchains)
@extern("vkCreateSharedSwapchainsKHR");

typedef VkRenderingFlagBitsKHR = inline CUInt;
const VkRenderingFlagBitsKHR RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT_KHR = 0x00000001;
const VkRenderingFlagBitsKHR RENDERING_SUSPENDING_BIT_KHR = 0x00000002;
const VkRenderingFlagBitsKHR RENDERING_RESUMING_BIT_KHR = 0x00000004;
const VkRenderingFlagBitsKHR RENDERING_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF;

alias VkRenderingFlagsKHR = VkFlags;

struct VkRenderingAttachmentInfoKHR {
  VkStructureType sType;
  void * pNext;
  VkImageView imageView;
  VkImageLayout imageLayout;
  VkResolveModeFlagBits resolveMode;
  VkImageView resolveImageView;
  VkImageLayout resolveImageLayout;
  VkAttachmentLoadOp loadOp;
  VkAttachmentStoreOp storeOp;
  VkClearValue clearValue;
}

struct VkRenderingInfoKHR {
  VkStructureType sType;
  void * pNext;
  VkRenderingFlagsKHR flags;
  VkRect2D renderArea;
  uint layerCount;
  uint viewMask;
  uint colorAttachmentCount;
  VkRenderingAttachmentInfoKHR * pColorAttachments;
  VkRenderingAttachmentInfoKHR * pDepthAttachment;
  VkRenderingAttachmentInfoKHR * pStencilAttachment;
}

struct VkPipelineRenderingCreateInfoKHR {
  VkStructureType sType;
  void * pNext;
  uint viewMask;
  uint colorAttachmentCount;
  VkFormat * pColorAttachmentFormats;
  VkFormat depthAttachmentFormat;
  VkFormat stencilAttachmentFormat;
}

struct VkPhysicalDeviceDynamicRenderingFeaturesKHR {
  VkStructureType sType;
  void * pNext;
  VkBool32 dynamicRendering;
}

struct VkCommandBufferInheritanceRenderingInfoKHR {
  VkStructureType sType;
  void * pNext;
  VkRenderingFlagsKHR flags;
  uint viewMask;
  uint colorAttachmentCount;
  VkFormat * pColorAttachmentFormats;
  VkFormat depthAttachmentFormat;
  VkFormat stencilAttachmentFormat;
  VkSampleCountFlagBits rasterizationSamples;
}

struct VkRenderingFragmentShadingRateAttachmentInfoKHR {
  VkStructureType sType;
  void * pNext;
  VkImageView imageView;
  VkImageLayout imageLayout;
  VkExtent2D shadingRateAttachmentTexelSize;
}

struct VkRenderingFragmentDensityMapAttachmentInfoEXT {
  VkStructureType sType;
  void * pNext;
  VkImageView imageView;
  VkImageLayout imageLayout;
}

struct VkAttachmentSampleCountInfoAMD {
  VkStructureType sType;
  void * pNext;
  uint colorAttachmentCount;
  VkSampleCountFlagBits * pColorAttachmentSamples;
  VkSampleCountFlagBits depthStencilAttachmentSamples;
}

alias VkAttachmentSampleCountInfoNV = VkAttachmentSampleCountInfoAMD;

struct VkMultiviewPerViewAttributesInfoNVX {
  VkStructureType sType;
  void * pNext;
  VkBool32 perViewAttributes;
  VkBool32 perViewAttributesPositionXOnly;
}

alias PFN_vkCmdBeginRenderingKHR = fn void(
  VkCommandBuffer commandBuffer, 
  VkRenderingInfoKHR * pRenderingInfo);

alias PFN_vkCmdEndRenderingKHR = fn void(  VkCommandBuffer commandBuffer);

fn void cmdBeginRenderingKHR(
  VkCommandBuffer commandBuffer, 
  VkRenderingInfoKHR * pRenderingInfo)
@extern("vkCmdBeginRenderingKHR");

fn void cmdEndRenderingKHR(
  VkCommandBuffer commandBuffer)
@extern("vkCmdEndRenderingKHR");

alias VkRenderPassMultiviewCreateInfoKHR = VkRenderPassMultiviewCreateInfo;

alias VkPhysicalDeviceMultiviewFeaturesKHR = VkPhysicalDeviceMultiviewFeatures;

alias VkPhysicalDeviceMultiviewPropertiesKHR = VkPhysicalDeviceMultiviewProperties;

alias VkPhysicalDeviceFeatures2KHR = VkPhysicalDeviceFeatures2;

alias VkPhysicalDeviceProperties2KHR = VkPhysicalDeviceProperties2;

alias VkFormatProperties2KHR = VkFormatProperties2;

alias VkImageFormatProperties2KHR = VkImageFormatProperties2;

alias VkPhysicalDeviceImageFormatInfo2KHR = VkPhysicalDeviceImageFormatInfo2;

alias VkQueueFamilyProperties2KHR = VkQueueFamilyProperties2;

alias VkPhysicalDeviceMemoryProperties2KHR = VkPhysicalDeviceMemoryProperties2;

alias VkSparseImageFormatProperties2KHR = VkSparseImageFormatProperties2;

alias VkPhysicalDeviceSparseImageFormatInfo2KHR = VkPhysicalDeviceSparseImageFormatInfo2;

alias PFN_vkGetPhysicalDeviceFeatures2KHR = fn void(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceFeatures2 * pFeatures);

alias PFN_vkGetPhysicalDeviceProperties2KHR = fn void(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceProperties2 * pProperties);

alias PFN_vkGetPhysicalDeviceFormatProperties2KHR = fn void(
  VkPhysicalDevice physicalDevice, 
  VkFormat format, 
  VkFormatProperties2 * pFormatProperties);

alias PFN_vkGetPhysicalDeviceImageFormatProperties2KHR = fn VkResult(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceImageFormatInfo2 * pImageFormatInfo, 
  VkImageFormatProperties2 * pImageFormatProperties);

alias PFN_vkGetPhysicalDeviceQueueFamilyProperties2KHR = fn void(
  VkPhysicalDevice physicalDevice, 
  uint * pQueueFamilyPropertyCount, 
  VkQueueFamilyProperties2 * pQueueFamilyProperties);

alias PFN_vkGetPhysicalDeviceMemoryProperties2KHR = fn void(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceMemoryProperties2 * pMemoryProperties);

alias PFN_vkGetPhysicalDeviceSparseImageFormatProperties2KHR = fn void(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceSparseImageFormatInfo2 * pFormatInfo, 
  uint * pPropertyCount, 
  VkSparseImageFormatProperties2 * pProperties);

fn void getPhysicalDeviceFeatures2KHR(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceFeatures2 * pFeatures)
@extern("vkGetPhysicalDeviceFeatures2KHR");

fn void getPhysicalDeviceProperties2KHR(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceProperties2 * pProperties)
@extern("vkGetPhysicalDeviceProperties2KHR");

fn void getPhysicalDeviceFormatProperties2KHR(
  VkPhysicalDevice physicalDevice, 
  VkFormat format, 
  VkFormatProperties2 * pFormatProperties)
@extern("vkGetPhysicalDeviceFormatProperties2KHR");

fn VkResult getPhysicalDeviceImageFormatProperties2KHR(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceImageFormatInfo2 * pImageFormatInfo, 
  VkImageFormatProperties2 * pImageFormatProperties)
@extern("vkGetPhysicalDeviceImageFormatProperties2KHR");

fn void getPhysicalDeviceQueueFamilyProperties2KHR(
  VkPhysicalDevice physicalDevice, 
  uint * pQueueFamilyPropertyCount, 
  VkQueueFamilyProperties2 * pQueueFamilyProperties)
@extern("vkGetPhysicalDeviceQueueFamilyProperties2KHR");

fn void getPhysicalDeviceMemoryProperties2KHR(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceMemoryProperties2 * pMemoryProperties)
@extern("vkGetPhysicalDeviceMemoryProperties2KHR");

fn void getPhysicalDeviceSparseImageFormatProperties2KHR(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceSparseImageFormatInfo2 * pFormatInfo, 
  uint * pPropertyCount, 
  VkSparseImageFormatProperties2 * pProperties)
@extern("vkGetPhysicalDeviceSparseImageFormatProperties2KHR");

alias VkPeerMemoryFeatureFlagsKHR = VkPeerMemoryFeatureFlags;

alias VkPeerMemoryFeatureFlagBitsKHR = VkPeerMemoryFeatureFlagBits;

alias VkMemoryAllocateFlagsKHR = VkMemoryAllocateFlags;

alias VkMemoryAllocateFlagBitsKHR = VkMemoryAllocateFlagBits;

alias VkMemoryAllocateFlagsInfoKHR = VkMemoryAllocateFlagsInfo;

alias VkDeviceGroupRenderPassBeginInfoKHR = VkDeviceGroupRenderPassBeginInfo;

alias VkDeviceGroupCommandBufferBeginInfoKHR = VkDeviceGroupCommandBufferBeginInfo;

alias VkDeviceGroupSubmitInfoKHR = VkDeviceGroupSubmitInfo;

alias VkDeviceGroupBindSparseInfoKHR = VkDeviceGroupBindSparseInfo;

alias VkBindBufferMemoryDeviceGroupInfoKHR = VkBindBufferMemoryDeviceGroupInfo;

alias VkBindImageMemoryDeviceGroupInfoKHR = VkBindImageMemoryDeviceGroupInfo;

alias PFN_vkGetDeviceGroupPeerMemoryFeaturesKHR = fn void(
  VkDevice device, 
  uint heapIndex, 
  uint localDeviceIndex, 
  uint remoteDeviceIndex, 
  VkPeerMemoryFeatureFlags * pPeerMemoryFeatures);

alias PFN_vkCmdSetDeviceMaskKHR = fn void(
  VkCommandBuffer commandBuffer, 
  uint deviceMask);

alias PFN_vkCmdDispatchBaseKHR = fn void(
  VkCommandBuffer commandBuffer, 
  uint baseGroupX, 
  uint baseGroupY, 
  uint baseGroupZ, 
  uint groupCountX, 
  uint groupCountY, 
  uint groupCountZ);

fn void getDeviceGroupPeerMemoryFeaturesKHR(
  VkDevice device, 
  uint heapIndex, 
  uint localDeviceIndex, 
  uint remoteDeviceIndex, 
  VkPeerMemoryFeatureFlags * pPeerMemoryFeatures)
@extern("vkGetDeviceGroupPeerMemoryFeaturesKHR");

fn void cmdSetDeviceMaskKHR(
  VkCommandBuffer commandBuffer, 
  uint deviceMask)
@extern("vkCmdSetDeviceMaskKHR");

fn void cmdDispatchBaseKHR(
  VkCommandBuffer commandBuffer, 
  uint baseGroupX, 
  uint baseGroupY, 
  uint baseGroupZ, 
  uint groupCountX, 
  uint groupCountY, 
  uint groupCountZ)
@extern("vkCmdDispatchBaseKHR");

alias VkCommandPoolTrimFlagsKHR = VkCommandPoolTrimFlags;

alias PFN_vkTrimCommandPoolKHR = fn void(
  VkDevice device, 
  VkCommandPool commandPool, 
  VkCommandPoolTrimFlags flags);

fn void trimCommandPoolKHR(
  VkDevice device, 
  VkCommandPool commandPool, 
  VkCommandPoolTrimFlags flags)
@extern("vkTrimCommandPoolKHR");

alias VkPhysicalDeviceGroupPropertiesKHR = VkPhysicalDeviceGroupProperties;

alias VkDeviceGroupDeviceCreateInfoKHR = VkDeviceGroupDeviceCreateInfo;

alias PFN_vkEnumeratePhysicalDeviceGroupsKHR = fn VkResult(
  VkInstance instance, 
  uint * pPhysicalDeviceGroupCount, 
  VkPhysicalDeviceGroupProperties * pPhysicalDeviceGroupProperties);

fn VkResult enumeratePhysicalDeviceGroupsKHR(
  VkInstance instance, 
  uint * pPhysicalDeviceGroupCount, 
  VkPhysicalDeviceGroupProperties * pPhysicalDeviceGroupProperties)
@extern("vkEnumeratePhysicalDeviceGroupsKHR");

alias VkExternalMemoryHandleTypeFlagsKHR = VkExternalMemoryHandleTypeFlags;

alias VkExternalMemoryHandleTypeFlagBitsKHR = VkExternalMemoryHandleTypeFlagBits;

alias VkExternalMemoryFeatureFlagsKHR = VkExternalMemoryFeatureFlags;

alias VkExternalMemoryFeatureFlagBitsKHR = VkExternalMemoryFeatureFlagBits;

alias VkExternalMemoryPropertiesKHR = VkExternalMemoryProperties;

alias VkPhysicalDeviceExternalImageFormatInfoKHR = VkPhysicalDeviceExternalImageFormatInfo;

alias VkExternalImageFormatPropertiesKHR = VkExternalImageFormatProperties;

alias VkPhysicalDeviceExternalBufferInfoKHR = VkPhysicalDeviceExternalBufferInfo;

alias VkExternalBufferPropertiesKHR = VkExternalBufferProperties;

alias VkPhysicalDeviceIDPropertiesKHR = VkPhysicalDeviceIDProperties;

alias PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR = fn void(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceExternalBufferInfo * pExternalBufferInfo, 
  VkExternalBufferProperties * pExternalBufferProperties);

fn void getPhysicalDeviceExternalBufferPropertiesKHR(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceExternalBufferInfo * pExternalBufferInfo, 
  VkExternalBufferProperties * pExternalBufferProperties)
@extern("vkGetPhysicalDeviceExternalBufferPropertiesKHR");

alias VkExternalMemoryImageCreateInfoKHR = VkExternalMemoryImageCreateInfo;

alias VkExternalMemoryBufferCreateInfoKHR = VkExternalMemoryBufferCreateInfo;

alias VkExportMemoryAllocateInfoKHR = VkExportMemoryAllocateInfo;

struct VkImportMemoryFdInfoKHR {
  VkStructureType sType;
  void * pNext;
  VkExternalMemoryHandleTypeFlagBits handleType;
  CInt fd;
}

struct VkMemoryFdPropertiesKHR {
  VkStructureType sType;
  void * pNext;
  uint memoryTypeBits;
}

struct VkMemoryGetFdInfoKHR {
  VkStructureType sType;
  void * pNext;
  VkDeviceMemory memory;
  VkExternalMemoryHandleTypeFlagBits handleType;
}

alias PFN_vkGetMemoryFdKHR = fn VkResult(
  VkDevice device, 
  VkMemoryGetFdInfoKHR * pGetFdInfo, 
  CInt * pFd);

alias PFN_vkGetMemoryFdPropertiesKHR = fn VkResult(
  VkDevice device, 
  VkExternalMemoryHandleTypeFlagBits handleType, 
  CInt fd, 
  VkMemoryFdPropertiesKHR * pMemoryFdProperties);

fn VkResult getMemoryFdKHR(
  VkDevice device, 
  VkMemoryGetFdInfoKHR * pGetFdInfo, 
  CInt * pFd)
@extern("vkGetMemoryFdKHR");

fn VkResult getMemoryFdPropertiesKHR(
  VkDevice device, 
  VkExternalMemoryHandleTypeFlagBits handleType, 
  CInt fd, 
  VkMemoryFdPropertiesKHR * pMemoryFdProperties)
@extern("vkGetMemoryFdPropertiesKHR");

alias VkExternalSemaphoreHandleTypeFlagsKHR = VkExternalSemaphoreHandleTypeFlags;

alias VkExternalSemaphoreHandleTypeFlagBitsKHR = VkExternalSemaphoreHandleTypeFlagBits;

alias VkExternalSemaphoreFeatureFlagsKHR = VkExternalSemaphoreFeatureFlags;

alias VkExternalSemaphoreFeatureFlagBitsKHR = VkExternalSemaphoreFeatureFlagBits;

alias VkPhysicalDeviceExternalSemaphoreInfoKHR = VkPhysicalDeviceExternalSemaphoreInfo;

alias VkExternalSemaphorePropertiesKHR = VkExternalSemaphoreProperties;

alias PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR = fn void(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceExternalSemaphoreInfo * pExternalSemaphoreInfo, 
  VkExternalSemaphoreProperties * pExternalSemaphoreProperties);

fn void getPhysicalDeviceExternalSemaphorePropertiesKHR(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceExternalSemaphoreInfo * pExternalSemaphoreInfo, 
  VkExternalSemaphoreProperties * pExternalSemaphoreProperties)
@extern("vkGetPhysicalDeviceExternalSemaphorePropertiesKHR");

alias VkSemaphoreImportFlagsKHR = VkSemaphoreImportFlags;

alias VkSemaphoreImportFlagBitsKHR = VkSemaphoreImportFlagBits;

alias VkExportSemaphoreCreateInfoKHR = VkExportSemaphoreCreateInfo;

struct VkImportSemaphoreFdInfoKHR {
  VkStructureType sType;
  void * pNext;
  VkSemaphore semaphore;
  VkSemaphoreImportFlags flags;
  VkExternalSemaphoreHandleTypeFlagBits handleType;
  CInt fd;
}

struct VkSemaphoreGetFdInfoKHR {
  VkStructureType sType;
  void * pNext;
  VkSemaphore semaphore;
  VkExternalSemaphoreHandleTypeFlagBits handleType;
}

alias PFN_vkImportSemaphoreFdKHR = fn VkResult(
  VkDevice device, 
  VkImportSemaphoreFdInfoKHR * pImportSemaphoreFdInfo);

alias PFN_vkGetSemaphoreFdKHR = fn VkResult(
  VkDevice device, 
  VkSemaphoreGetFdInfoKHR * pGetFdInfo, 
  CInt * pFd);

fn VkResult importSemaphoreFdKHR(
  VkDevice device, 
  VkImportSemaphoreFdInfoKHR * pImportSemaphoreFdInfo)
@extern("vkImportSemaphoreFdKHR");

fn VkResult getSemaphoreFdKHR(
  VkDevice device, 
  VkSemaphoreGetFdInfoKHR * pGetFdInfo, 
  CInt * pFd)
@extern("vkGetSemaphoreFdKHR");

struct VkPhysicalDevicePushDescriptorPropertiesKHR {
  VkStructureType sType;
  void * pNext;
  uint maxPushDescriptors;
}

alias PFN_vkCmdPushDescriptorSetKHR = fn void(
  VkCommandBuffer commandBuffer, 
  VkPipelineBindPoint pipelineBindPoint, 
  VkPipelineLayout layout, 
  uint set, 
  uint descriptorWriteCount, 
  VkWriteDescriptorSet * pDescriptorWrites);

alias PFN_vkCmdPushDescriptorSetWithTemplateKHR = fn void(
  VkCommandBuffer commandBuffer, 
  VkDescriptorUpdateTemplate descriptorUpdateTemplate, 
  VkPipelineLayout layout, 
  uint set, 
  void * pData);

fn void cmdPushDescriptorSetKHR(
  VkCommandBuffer commandBuffer, 
  VkPipelineBindPoint pipelineBindPoint, 
  VkPipelineLayout layout, 
  uint set, 
  uint descriptorWriteCount, 
  VkWriteDescriptorSet * pDescriptorWrites)
@extern("vkCmdPushDescriptorSetKHR");

fn void cmdPushDescriptorSetWithTemplateKHR(
  VkCommandBuffer commandBuffer, 
  VkDescriptorUpdateTemplate descriptorUpdateTemplate, 
  VkPipelineLayout layout, 
  uint set, 
  void * pData)
@extern("vkCmdPushDescriptorSetWithTemplateKHR");

alias VkPhysicalDeviceShaderFloat16Int8FeaturesKHR = VkPhysicalDeviceShaderFloat16Int8Features;

alias VkPhysicalDeviceFloat16Int8FeaturesKHR = VkPhysicalDeviceShaderFloat16Int8Features;

alias VkPhysicalDevice16BitStorageFeaturesKHR = VkPhysicalDevice16BitStorageFeatures;

struct VkRectLayerKHR {
  VkOffset2D offset;
  VkExtent2D extent;
  uint layer;
}

struct VkPresentRegionKHR {
  uint rectangleCount;
  VkRectLayerKHR * pRectangles;
}

struct VkPresentRegionsKHR {
  VkStructureType sType;
  void * pNext;
  uint swapchainCount;
  VkPresentRegionKHR * pRegions;
}

alias VkDescriptorUpdateTemplateKHR = VkDescriptorUpdateTemplate;

alias VkDescriptorUpdateTemplateTypeKHR = VkDescriptorUpdateTemplateType;

alias VkDescriptorUpdateTemplateCreateFlagsKHR = VkDescriptorUpdateTemplateCreateFlags;

alias VkDescriptorUpdateTemplateEntryKHR = VkDescriptorUpdateTemplateEntry;

alias VkDescriptorUpdateTemplateCreateInfoKHR = VkDescriptorUpdateTemplateCreateInfo;

alias PFN_vkCreateDescriptorUpdateTemplateKHR = fn VkResult(
  VkDevice device, 
  VkDescriptorUpdateTemplateCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkDescriptorUpdateTemplate * pDescriptorUpdateTemplate);

alias PFN_vkDestroyDescriptorUpdateTemplateKHR = fn void(
  VkDevice device, 
  VkDescriptorUpdateTemplate descriptorUpdateTemplate, 
  VkAllocationCallbacks * pAllocator);

alias PFN_vkUpdateDescriptorSetWithTemplateKHR = fn void(
  VkDevice device, 
  VkDescriptorSet descriptorSet, 
  VkDescriptorUpdateTemplate descriptorUpdateTemplate, 
  void * pData);

fn VkResult createDescriptorUpdateTemplateKHR(
  VkDevice device, 
  VkDescriptorUpdateTemplateCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkDescriptorUpdateTemplate * pDescriptorUpdateTemplate)
@extern("vkCreateDescriptorUpdateTemplateKHR");

fn void destroyDescriptorUpdateTemplateKHR(
  VkDevice device, 
  VkDescriptorUpdateTemplate descriptorUpdateTemplate, 
  VkAllocationCallbacks * pAllocator)
@extern("vkDestroyDescriptorUpdateTemplateKHR");

fn void updateDescriptorSetWithTemplateKHR(
  VkDevice device, 
  VkDescriptorSet descriptorSet, 
  VkDescriptorUpdateTemplate descriptorUpdateTemplate, 
  void * pData)
@extern("vkUpdateDescriptorSetWithTemplateKHR");

alias VkPhysicalDeviceImagelessFramebufferFeaturesKHR = VkPhysicalDeviceImagelessFramebufferFeatures;

alias VkFramebufferAttachmentsCreateInfoKHR = VkFramebufferAttachmentsCreateInfo;

alias VkFramebufferAttachmentImageInfoKHR = VkFramebufferAttachmentImageInfo;

alias VkRenderPassAttachmentBeginInfoKHR = VkRenderPassAttachmentBeginInfo;

alias VkRenderPassCreateInfo2KHR = VkRenderPassCreateInfo2;

alias VkAttachmentDescription2KHR = VkAttachmentDescription2;

alias VkAttachmentReference2KHR = VkAttachmentReference2;

alias VkSubpassDescription2KHR = VkSubpassDescription2;

alias VkSubpassDependency2KHR = VkSubpassDependency2;

alias VkSubpassBeginInfoKHR = VkSubpassBeginInfo;

alias VkSubpassEndInfoKHR = VkSubpassEndInfo;

alias PFN_vkCreateRenderPass2KHR = fn VkResult(
  VkDevice device, 
  VkRenderPassCreateInfo2 * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkRenderPass * pRenderPass);

alias PFN_vkCmdBeginRenderPass2KHR = fn void(
  VkCommandBuffer commandBuffer, 
  VkRenderPassBeginInfo * pRenderPassBegin, 
  VkSubpassBeginInfo * pSubpassBeginInfo);

alias PFN_vkCmdNextSubpass2KHR = fn void(
  VkCommandBuffer commandBuffer, 
  VkSubpassBeginInfo * pSubpassBeginInfo, 
  VkSubpassEndInfo * pSubpassEndInfo);

alias PFN_vkCmdEndRenderPass2KHR = fn void(
  VkCommandBuffer commandBuffer, 
  VkSubpassEndInfo * pSubpassEndInfo);

fn VkResult createRenderPass2KHR(
  VkDevice device, 
  VkRenderPassCreateInfo2 * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkRenderPass * pRenderPass)
@extern("vkCreateRenderPass2KHR");

fn void cmdBeginRenderPass2KHR(
  VkCommandBuffer commandBuffer, 
  VkRenderPassBeginInfo * pRenderPassBegin, 
  VkSubpassBeginInfo * pSubpassBeginInfo)
@extern("vkCmdBeginRenderPass2KHR");

fn void cmdNextSubpass2KHR(
  VkCommandBuffer commandBuffer, 
  VkSubpassBeginInfo * pSubpassBeginInfo, 
  VkSubpassEndInfo * pSubpassEndInfo)
@extern("vkCmdNextSubpass2KHR");

fn void cmdEndRenderPass2KHR(
  VkCommandBuffer commandBuffer, 
  VkSubpassEndInfo * pSubpassEndInfo)
@extern("vkCmdEndRenderPass2KHR");

struct VkSharedPresentSurfaceCapabilitiesKHR {
  VkStructureType sType;
  void * pNext;
  VkImageUsageFlags sharedPresentSupportedUsageFlags;
}

alias PFN_vkGetSwapchainStatusKHR = fn VkResult(
  VkDevice device, 
  VkSwapchainKHR swapchain);

fn VkResult getSwapchainStatusKHR(
  VkDevice device, 
  VkSwapchainKHR swapchain)
@extern("vkGetSwapchainStatusKHR");

alias VkExternalFenceHandleTypeFlagsKHR = VkExternalFenceHandleTypeFlags;

alias VkExternalFenceHandleTypeFlagBitsKHR = VkExternalFenceHandleTypeFlagBits;

alias VkExternalFenceFeatureFlagsKHR = VkExternalFenceFeatureFlags;

alias VkExternalFenceFeatureFlagBitsKHR = VkExternalFenceFeatureFlagBits;

alias VkPhysicalDeviceExternalFenceInfoKHR = VkPhysicalDeviceExternalFenceInfo;

alias VkExternalFencePropertiesKHR = VkExternalFenceProperties;

alias PFN_vkGetPhysicalDeviceExternalFencePropertiesKHR = fn void(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceExternalFenceInfo * pExternalFenceInfo, 
  VkExternalFenceProperties * pExternalFenceProperties);

fn void getPhysicalDeviceExternalFencePropertiesKHR(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceExternalFenceInfo * pExternalFenceInfo, 
  VkExternalFenceProperties * pExternalFenceProperties)
@extern("vkGetPhysicalDeviceExternalFencePropertiesKHR");

alias VkFenceImportFlagsKHR = VkFenceImportFlags;

alias VkFenceImportFlagBitsKHR = VkFenceImportFlagBits;

alias VkExportFenceCreateInfoKHR = VkExportFenceCreateInfo;

struct VkImportFenceFdInfoKHR {
  VkStructureType sType;
  void * pNext;
  VkFence fence;
  VkFenceImportFlags flags;
  VkExternalFenceHandleTypeFlagBits handleType;
  CInt fd;
}

struct VkFenceGetFdInfoKHR {
  VkStructureType sType;
  void * pNext;
  VkFence fence;
  VkExternalFenceHandleTypeFlagBits handleType;
}

alias PFN_vkImportFenceFdKHR = fn VkResult(
  VkDevice device, 
  VkImportFenceFdInfoKHR * pImportFenceFdInfo);

alias PFN_vkGetFenceFdKHR = fn VkResult(
  VkDevice device, 
  VkFenceGetFdInfoKHR * pGetFdInfo, 
  CInt * pFd);

fn VkResult importFenceFdKHR(
  VkDevice device, 
  VkImportFenceFdInfoKHR * pImportFenceFdInfo)
@extern("vkImportFenceFdKHR");

fn VkResult getFenceFdKHR(
  VkDevice device, 
  VkFenceGetFdInfoKHR * pGetFdInfo, 
  CInt * pFd)
@extern("vkGetFenceFdKHR");

typedef VkPerformanceCounterUnitKHR = inline CUInt;
const VkPerformanceCounterUnitKHR PERFORMANCE_COUNTER_UNIT_GENERIC_KHR = 0;
const VkPerformanceCounterUnitKHR PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR = 1;
const VkPerformanceCounterUnitKHR PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR = 2;
const VkPerformanceCounterUnitKHR PERFORMANCE_COUNTER_UNIT_BYTES_KHR = 3;
const VkPerformanceCounterUnitKHR PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR = 4;
const VkPerformanceCounterUnitKHR PERFORMANCE_COUNTER_UNIT_KELVIN_KHR = 5;
const VkPerformanceCounterUnitKHR PERFORMANCE_COUNTER_UNIT_WATTS_KHR = 6;
const VkPerformanceCounterUnitKHR PERFORMANCE_COUNTER_UNIT_VOLTS_KHR = 7;
const VkPerformanceCounterUnitKHR PERFORMANCE_COUNTER_UNIT_AMPS_KHR = 8;
const VkPerformanceCounterUnitKHR PERFORMANCE_COUNTER_UNIT_HERTZ_KHR = 9;
const VkPerformanceCounterUnitKHR PERFORMANCE_COUNTER_UNIT_CYCLES_KHR = 10;
const VkPerformanceCounterUnitKHR PERFORMANCE_COUNTER_UNIT_MAX_ENUM_KHR = 0x7FFFFFFF;

typedef VkPerformanceCounterScopeKHR = inline CUInt;
const VkPerformanceCounterScopeKHR PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR = 0;
const VkPerformanceCounterScopeKHR PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR = 1;
const VkPerformanceCounterScopeKHR PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR = 2;
const VkPerformanceCounterScopeKHR QUERY_SCOPE_COMMAND_BUFFER_KHR = PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR;
const VkPerformanceCounterScopeKHR QUERY_SCOPE_RENDER_PASS_KHR = PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR;
const VkPerformanceCounterScopeKHR QUERY_SCOPE_COMMAND_KHR = PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR;
const VkPerformanceCounterScopeKHR PERFORMANCE_COUNTER_SCOPE_MAX_ENUM_KHR = 0x7FFFFFFF;

typedef VkPerformanceCounterStorageKHR = inline CUInt;
const VkPerformanceCounterStorageKHR PERFORMANCE_COUNTER_STORAGE_INT32_KHR = 0;
const VkPerformanceCounterStorageKHR PERFORMANCE_COUNTER_STORAGE_INT64_KHR = 1;
const VkPerformanceCounterStorageKHR PERFORMANCE_COUNTER_STORAGE_UINT32_KHR = 2;
const VkPerformanceCounterStorageKHR PERFORMANCE_COUNTER_STORAGE_UINT64_KHR = 3;
const VkPerformanceCounterStorageKHR PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR = 4;
const VkPerformanceCounterStorageKHR PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR = 5;
const VkPerformanceCounterStorageKHR PERFORMANCE_COUNTER_STORAGE_MAX_ENUM_KHR = 0x7FFFFFFF;

typedef VkPerformanceCounterDescriptionFlagBitsKHR = inline CUInt;
const VkPerformanceCounterDescriptionFlagBitsKHR PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR = 0x00000001;
const VkPerformanceCounterDescriptionFlagBitsKHR PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR = 0x00000002;
const VkPerformanceCounterDescriptionFlagBitsKHR PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_KHR = PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR;
const VkPerformanceCounterDescriptionFlagBitsKHR PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_KHR = PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR;
const VkPerformanceCounterDescriptionFlagBitsKHR PERFORMANCE_COUNTER_DESCRIPTION_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF;

alias VkPerformanceCounterDescriptionFlagsKHR = VkFlags;

typedef VkAcquireProfilingLockFlagBitsKHR = inline CUInt;
const VkAcquireProfilingLockFlagBitsKHR ACQUIRE_PROFILING_LOCK_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF;

alias VkAcquireProfilingLockFlagsKHR = VkFlags;

struct VkPhysicalDevicePerformanceQueryFeaturesKHR {
  VkStructureType sType;
  void * pNext;
  VkBool32 performanceCounterQueryPools;
  VkBool32 performanceCounterMultipleQueryPools;
}

struct VkPhysicalDevicePerformanceQueryPropertiesKHR {
  VkStructureType sType;
  void * pNext;
  VkBool32 allowCommandBufferQueryCopies;
}

struct VkPerformanceCounterKHR {
  VkStructureType sType;
  void * pNext;
  VkPerformanceCounterUnitKHR unit;
  VkPerformanceCounterScopeKHR scope;
  VkPerformanceCounterStorageKHR storage;
  char[16] uuid;
}

struct VkPerformanceCounterDescriptionKHR {
  VkStructureType sType;
  void * pNext;
  VkPerformanceCounterDescriptionFlagsKHR flags;
  CChar[256] name;
  CChar[256] category;
  CChar[256] description;
}

struct VkQueryPoolPerformanceCreateInfoKHR {
  VkStructureType sType;
  void * pNext;
  uint queueFamilyIndex;
  uint counterIndexCount;
  uint * pCounterIndices;
}

union VkPerformanceCounterResultKHR {
  int int32;
  long int64;
  uint uint32;
  ulong uint64;
  float float32;
  double float64;
}

struct VkAcquireProfilingLockInfoKHR {
  VkStructureType sType;
  void * pNext;
  VkAcquireProfilingLockFlagsKHR flags;
  ulong timeout;
}

struct VkPerformanceQuerySubmitInfoKHR {
  VkStructureType sType;
  void * pNext;
  uint counterPassIndex;
}

alias PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR = fn VkResult(
  VkPhysicalDevice physicalDevice, 
  uint queueFamilyIndex, 
  uint * pCounterCount, 
  VkPerformanceCounterKHR * pCounters, 
  VkPerformanceCounterDescriptionKHR * pCounterDescriptions);

alias PFN_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR = fn void(
  VkPhysicalDevice physicalDevice, 
  VkQueryPoolPerformanceCreateInfoKHR * pPerformanceQueryCreateInfo, 
  uint * pNumPasses);

alias PFN_vkAcquireProfilingLockKHR = fn VkResult(
  VkDevice device, 
  VkAcquireProfilingLockInfoKHR * pInfo);

alias PFN_vkReleaseProfilingLockKHR = fn void(  VkDevice device);

fn VkResult enumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(
  VkPhysicalDevice physicalDevice, 
  uint queueFamilyIndex, 
  uint * pCounterCount, 
  VkPerformanceCounterKHR * pCounters, 
  VkPerformanceCounterDescriptionKHR * pCounterDescriptions)
@extern("vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR");

fn void getPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(
  VkPhysicalDevice physicalDevice, 
  VkQueryPoolPerformanceCreateInfoKHR * pPerformanceQueryCreateInfo, 
  uint * pNumPasses)
@extern("vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR");

fn VkResult acquireProfilingLockKHR(
  VkDevice device, 
  VkAcquireProfilingLockInfoKHR * pInfo)
@extern("vkAcquireProfilingLockKHR");

fn void releaseProfilingLockKHR(
  VkDevice device)
@extern("vkReleaseProfilingLockKHR");

alias VkPointClippingBehaviorKHR = VkPointClippingBehavior;

alias VkTessellationDomainOriginKHR = VkTessellationDomainOrigin;

alias VkPhysicalDevicePointClippingPropertiesKHR = VkPhysicalDevicePointClippingProperties;

alias VkRenderPassInputAttachmentAspectCreateInfoKHR = VkRenderPassInputAttachmentAspectCreateInfo;

alias VkInputAttachmentAspectReferenceKHR = VkInputAttachmentAspectReference;

alias VkImageViewUsageCreateInfoKHR = VkImageViewUsageCreateInfo;

alias VkPipelineTessellationDomainOriginStateCreateInfoKHR = VkPipelineTessellationDomainOriginStateCreateInfo;

struct VkPhysicalDeviceSurfaceInfo2KHR {
  VkStructureType sType;
  void * pNext;
  VkSurfaceKHR surface;
}

struct VkSurfaceCapabilities2KHR {
  VkStructureType sType;
  void * pNext;
  VkSurfaceCapabilitiesKHR surfaceCapabilities;
}

struct VkSurfaceFormat2KHR {
  VkStructureType sType;
  void * pNext;
  VkSurfaceFormatKHR surfaceFormat;
}

alias PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR = fn VkResult(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceSurfaceInfo2KHR * pSurfaceInfo, 
  VkSurfaceCapabilities2KHR * pSurfaceCapabilities);

alias PFN_vkGetPhysicalDeviceSurfaceFormats2KHR = fn VkResult(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceSurfaceInfo2KHR * pSurfaceInfo, 
  uint * pSurfaceFormatCount, 
  VkSurfaceFormat2KHR * pSurfaceFormats);

fn VkResult getPhysicalDeviceSurfaceCapabilities2KHR(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceSurfaceInfo2KHR * pSurfaceInfo, 
  VkSurfaceCapabilities2KHR * pSurfaceCapabilities)
@extern("vkGetPhysicalDeviceSurfaceCapabilities2KHR");

fn VkResult getPhysicalDeviceSurfaceFormats2KHR(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceSurfaceInfo2KHR * pSurfaceInfo, 
  uint * pSurfaceFormatCount, 
  VkSurfaceFormat2KHR * pSurfaceFormats)
@extern("vkGetPhysicalDeviceSurfaceFormats2KHR");

alias VkPhysicalDeviceVariablePointerFeaturesKHR = VkPhysicalDeviceVariablePointersFeatures;

alias VkPhysicalDeviceVariablePointersFeaturesKHR = VkPhysicalDeviceVariablePointersFeatures;

struct VkDisplayProperties2KHR {
  VkStructureType sType;
  void * pNext;
  VkDisplayPropertiesKHR displayProperties;
}

struct VkDisplayPlaneProperties2KHR {
  VkStructureType sType;
  void * pNext;
  VkDisplayPlanePropertiesKHR displayPlaneProperties;
}

struct VkDisplayModeProperties2KHR {
  VkStructureType sType;
  void * pNext;
  VkDisplayModePropertiesKHR displayModeProperties;
}

struct VkDisplayPlaneInfo2KHR {
  VkStructureType sType;
  void * pNext;
  VkDisplayModeKHR mode;
  uint planeIndex;
}

struct VkDisplayPlaneCapabilities2KHR {
  VkStructureType sType;
  void * pNext;
  VkDisplayPlaneCapabilitiesKHR capabilities;
}

alias PFN_vkGetPhysicalDeviceDisplayProperties2KHR = fn VkResult(
  VkPhysicalDevice physicalDevice, 
  uint * pPropertyCount, 
  VkDisplayProperties2KHR * pProperties);

alias PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR = fn VkResult(
  VkPhysicalDevice physicalDevice, 
  uint * pPropertyCount, 
  VkDisplayPlaneProperties2KHR * pProperties);

alias PFN_vkGetDisplayModeProperties2KHR = fn VkResult(
  VkPhysicalDevice physicalDevice, 
  VkDisplayKHR display, 
  uint * pPropertyCount, 
  VkDisplayModeProperties2KHR * pProperties);

alias PFN_vkGetDisplayPlaneCapabilities2KHR = fn VkResult(
  VkPhysicalDevice physicalDevice, 
  VkDisplayPlaneInfo2KHR * pDisplayPlaneInfo, 
  VkDisplayPlaneCapabilities2KHR * pCapabilities);

fn VkResult getPhysicalDeviceDisplayProperties2KHR(
  VkPhysicalDevice physicalDevice, 
  uint * pPropertyCount, 
  VkDisplayProperties2KHR * pProperties)
@extern("vkGetPhysicalDeviceDisplayProperties2KHR");

fn VkResult getPhysicalDeviceDisplayPlaneProperties2KHR(
  VkPhysicalDevice physicalDevice, 
  uint * pPropertyCount, 
  VkDisplayPlaneProperties2KHR * pProperties)
@extern("vkGetPhysicalDeviceDisplayPlaneProperties2KHR");

fn VkResult getDisplayModeProperties2KHR(
  VkPhysicalDevice physicalDevice, 
  VkDisplayKHR display, 
  uint * pPropertyCount, 
  VkDisplayModeProperties2KHR * pProperties)
@extern("vkGetDisplayModeProperties2KHR");

fn VkResult getDisplayPlaneCapabilities2KHR(
  VkPhysicalDevice physicalDevice, 
  VkDisplayPlaneInfo2KHR * pDisplayPlaneInfo, 
  VkDisplayPlaneCapabilities2KHR * pCapabilities)
@extern("vkGetDisplayPlaneCapabilities2KHR");

alias VkMemoryDedicatedRequirementsKHR = VkMemoryDedicatedRequirements;

alias VkMemoryDedicatedAllocateInfoKHR = VkMemoryDedicatedAllocateInfo;

alias VkBufferMemoryRequirementsInfo2KHR = VkBufferMemoryRequirementsInfo2;

alias VkImageMemoryRequirementsInfo2KHR = VkImageMemoryRequirementsInfo2;

alias VkImageSparseMemoryRequirementsInfo2KHR = VkImageSparseMemoryRequirementsInfo2;

alias VkMemoryRequirements2KHR = VkMemoryRequirements2;

alias VkSparseImageMemoryRequirements2KHR = VkSparseImageMemoryRequirements2;

alias PFN_vkGetImageMemoryRequirements2KHR = fn void(
  VkDevice device, 
  VkImageMemoryRequirementsInfo2 * pInfo, 
  VkMemoryRequirements2 * pMemoryRequirements);

alias PFN_vkGetBufferMemoryRequirements2KHR = fn void(
  VkDevice device, 
  VkBufferMemoryRequirementsInfo2 * pInfo, 
  VkMemoryRequirements2 * pMemoryRequirements);

alias PFN_vkGetImageSparseMemoryRequirements2KHR = fn void(
  VkDevice device, 
  VkImageSparseMemoryRequirementsInfo2 * pInfo, 
  uint * pSparseMemoryRequirementCount, 
  VkSparseImageMemoryRequirements2 * pSparseMemoryRequirements);

fn void getImageMemoryRequirements2KHR(
  VkDevice device, 
  VkImageMemoryRequirementsInfo2 * pInfo, 
  VkMemoryRequirements2 * pMemoryRequirements)
@extern("vkGetImageMemoryRequirements2KHR");

fn void getBufferMemoryRequirements2KHR(
  VkDevice device, 
  VkBufferMemoryRequirementsInfo2 * pInfo, 
  VkMemoryRequirements2 * pMemoryRequirements)
@extern("vkGetBufferMemoryRequirements2KHR");

fn void getImageSparseMemoryRequirements2KHR(
  VkDevice device, 
  VkImageSparseMemoryRequirementsInfo2 * pInfo, 
  uint * pSparseMemoryRequirementCount, 
  VkSparseImageMemoryRequirements2 * pSparseMemoryRequirements)
@extern("vkGetImageSparseMemoryRequirements2KHR");

alias VkImageFormatListCreateInfoKHR = VkImageFormatListCreateInfo;

alias VkSamplerYcbcrConversionKHR = VkSamplerYcbcrConversion;

alias VkSamplerYcbcrModelConversionKHR = VkSamplerYcbcrModelConversion;

alias VkSamplerYcbcrRangeKHR = VkSamplerYcbcrRange;

alias VkChromaLocationKHR = VkChromaLocation;

alias VkSamplerYcbcrConversionCreateInfoKHR = VkSamplerYcbcrConversionCreateInfo;

alias VkSamplerYcbcrConversionInfoKHR = VkSamplerYcbcrConversionInfo;

alias VkBindImagePlaneMemoryInfoKHR = VkBindImagePlaneMemoryInfo;

alias VkImagePlaneMemoryRequirementsInfoKHR = VkImagePlaneMemoryRequirementsInfo;

alias VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR = VkPhysicalDeviceSamplerYcbcrConversionFeatures;

alias VkSamplerYcbcrConversionImageFormatPropertiesKHR = VkSamplerYcbcrConversionImageFormatProperties;

alias PFN_vkCreateSamplerYcbcrConversionKHR = fn VkResult(
  VkDevice device, 
  VkSamplerYcbcrConversionCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkSamplerYcbcrConversion * pYcbcrConversion);

alias PFN_vkDestroySamplerYcbcrConversionKHR = fn void(
  VkDevice device, 
  VkSamplerYcbcrConversion ycbcrConversion, 
  VkAllocationCallbacks * pAllocator);

fn VkResult createSamplerYcbcrConversionKHR(
  VkDevice device, 
  VkSamplerYcbcrConversionCreateInfo * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkSamplerYcbcrConversion * pYcbcrConversion)
@extern("vkCreateSamplerYcbcrConversionKHR");

fn void destroySamplerYcbcrConversionKHR(
  VkDevice device, 
  VkSamplerYcbcrConversion ycbcrConversion, 
  VkAllocationCallbacks * pAllocator)
@extern("vkDestroySamplerYcbcrConversionKHR");

alias VkBindBufferMemoryInfoKHR = VkBindBufferMemoryInfo;

alias VkBindImageMemoryInfoKHR = VkBindImageMemoryInfo;

alias PFN_vkBindBufferMemory2KHR = fn VkResult(
  VkDevice device, 
  uint bindInfoCount, 
  VkBindBufferMemoryInfo * pBindInfos);

alias PFN_vkBindImageMemory2KHR = fn VkResult(
  VkDevice device, 
  uint bindInfoCount, 
  VkBindImageMemoryInfo * pBindInfos);

fn VkResult bindBufferMemory2KHR(
  VkDevice device, 
  uint bindInfoCount, 
  VkBindBufferMemoryInfo * pBindInfos)
@extern("vkBindBufferMemory2KHR");

fn VkResult bindImageMemory2KHR(
  VkDevice device, 
  uint bindInfoCount, 
  VkBindImageMemoryInfo * pBindInfos)
@extern("vkBindImageMemory2KHR");

alias VkPhysicalDeviceMaintenance3PropertiesKHR = VkPhysicalDeviceMaintenance3Properties;

alias VkDescriptorSetLayoutSupportKHR = VkDescriptorSetLayoutSupport;

alias PFN_vkGetDescriptorSetLayoutSupportKHR = fn void(
  VkDevice device, 
  VkDescriptorSetLayoutCreateInfo * pCreateInfo, 
  VkDescriptorSetLayoutSupport * pSupport);

fn void getDescriptorSetLayoutSupportKHR(
  VkDevice device, 
  VkDescriptorSetLayoutCreateInfo * pCreateInfo, 
  VkDescriptorSetLayoutSupport * pSupport)
@extern("vkGetDescriptorSetLayoutSupportKHR");

alias PFN_vkCmdDrawIndirectCountKHR = fn void(
  VkCommandBuffer commandBuffer, 
  VkBuffer buffer, 
  VkDeviceSize offset, 
  VkBuffer countBuffer, 
  VkDeviceSize countBufferOffset, 
  uint maxDrawCount, 
  uint stride);

alias PFN_vkCmdDrawIndexedIndirectCountKHR = fn void(
  VkCommandBuffer commandBuffer, 
  VkBuffer buffer, 
  VkDeviceSize offset, 
  VkBuffer countBuffer, 
  VkDeviceSize countBufferOffset, 
  uint maxDrawCount, 
  uint stride);

fn void cmdDrawIndirectCountKHR(
  VkCommandBuffer commandBuffer, 
  VkBuffer buffer, 
  VkDeviceSize offset, 
  VkBuffer countBuffer, 
  VkDeviceSize countBufferOffset, 
  uint maxDrawCount, 
  uint stride)
@extern("vkCmdDrawIndirectCountKHR");

fn void cmdDrawIndexedIndirectCountKHR(
  VkCommandBuffer commandBuffer, 
  VkBuffer buffer, 
  VkDeviceSize offset, 
  VkBuffer countBuffer, 
  VkDeviceSize countBufferOffset, 
  uint maxDrawCount, 
  uint stride)
@extern("vkCmdDrawIndexedIndirectCountKHR");

alias VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR = VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures;

alias VkPhysicalDevice8BitStorageFeaturesKHR = VkPhysicalDevice8BitStorageFeatures;

alias VkPhysicalDeviceShaderAtomicInt64FeaturesKHR = VkPhysicalDeviceShaderAtomicInt64Features;

struct VkPhysicalDeviceShaderClockFeaturesKHR {
  VkStructureType sType;
  void * pNext;
  VkBool32 shaderSubgroupClock;
  VkBool32 shaderDeviceClock;
}

alias VkDriverIdKHR = VkDriverId;

alias VkConformanceVersionKHR = VkConformanceVersion;

alias VkPhysicalDeviceDriverPropertiesKHR = VkPhysicalDeviceDriverProperties;

alias VkShaderFloatControlsIndependenceKHR = VkShaderFloatControlsIndependence;

alias VkPhysicalDeviceFloatControlsPropertiesKHR = VkPhysicalDeviceFloatControlsProperties;

alias VkResolveModeFlagBitsKHR = VkResolveModeFlagBits;

alias VkResolveModeFlagsKHR = VkResolveModeFlags;

alias VkSubpassDescriptionDepthStencilResolveKHR = VkSubpassDescriptionDepthStencilResolve;

alias VkPhysicalDeviceDepthStencilResolvePropertiesKHR = VkPhysicalDeviceDepthStencilResolveProperties;

alias VkSemaphoreTypeKHR = VkSemaphoreType;

alias VkSemaphoreWaitFlagBitsKHR = VkSemaphoreWaitFlagBits;

alias VkSemaphoreWaitFlagsKHR = VkSemaphoreWaitFlags;

alias VkPhysicalDeviceTimelineSemaphoreFeaturesKHR = VkPhysicalDeviceTimelineSemaphoreFeatures;

alias VkPhysicalDeviceTimelineSemaphorePropertiesKHR = VkPhysicalDeviceTimelineSemaphoreProperties;

alias VkSemaphoreTypeCreateInfoKHR = VkSemaphoreTypeCreateInfo;

alias VkTimelineSemaphoreSubmitInfoKHR = VkTimelineSemaphoreSubmitInfo;

alias VkSemaphoreWaitInfoKHR = VkSemaphoreWaitInfo;

alias VkSemaphoreSignalInfoKHR = VkSemaphoreSignalInfo;

alias PFN_vkGetSemaphoreCounterValueKHR = fn VkResult(
  VkDevice device, 
  VkSemaphore semaphore, 
  ulong * pValue);

alias PFN_vkWaitSemaphoresKHR = fn VkResult(
  VkDevice device, 
  VkSemaphoreWaitInfo * pWaitInfo, 
  ulong timeout);

alias PFN_vkSignalSemaphoreKHR = fn VkResult(
  VkDevice device, 
  VkSemaphoreSignalInfo * pSignalInfo);

fn VkResult getSemaphoreCounterValueKHR(
  VkDevice device, 
  VkSemaphore semaphore, 
  ulong * pValue)
@extern("vkGetSemaphoreCounterValueKHR");

fn VkResult waitSemaphoresKHR(
  VkDevice device, 
  VkSemaphoreWaitInfo * pWaitInfo, 
  ulong timeout)
@extern("vkWaitSemaphoresKHR");

fn VkResult signalSemaphoreKHR(
  VkDevice device, 
  VkSemaphoreSignalInfo * pSignalInfo)
@extern("vkSignalSemaphoreKHR");

alias VkPhysicalDeviceVulkanMemoryModelFeaturesKHR = VkPhysicalDeviceVulkanMemoryModelFeatures;

struct VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR {
  VkStructureType sType;
  void * pNext;
  VkBool32 shaderTerminateInvocation;
}

typedef VkFragmentShadingRateCombinerOpKHR = inline CUInt;
const VkFragmentShadingRateCombinerOpKHR FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR = 0;
const VkFragmentShadingRateCombinerOpKHR FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR = 1;
const VkFragmentShadingRateCombinerOpKHR FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR = 2;
const VkFragmentShadingRateCombinerOpKHR FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR = 3;
const VkFragmentShadingRateCombinerOpKHR FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR = 4;
const VkFragmentShadingRateCombinerOpKHR FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_ENUM_KHR = 0x7FFFFFFF;

struct VkFragmentShadingRateAttachmentInfoKHR {
  VkStructureType sType;
  void * pNext;
  VkAttachmentReference2 * pFragmentShadingRateAttachment;
  VkExtent2D shadingRateAttachmentTexelSize;
}

struct VkPipelineFragmentShadingRateStateCreateInfoKHR {
  VkStructureType sType;
  void * pNext;
  VkExtent2D fragmentSize;
  VkFragmentShadingRateCombinerOpKHR[2] combinerOps;
}

struct VkPhysicalDeviceFragmentShadingRateFeaturesKHR {
  VkStructureType sType;
  void * pNext;
  VkBool32 pipelineFragmentShadingRate;
  VkBool32 primitiveFragmentShadingRate;
  VkBool32 attachmentFragmentShadingRate;
}

struct VkPhysicalDeviceFragmentShadingRatePropertiesKHR {
  VkStructureType sType;
  void * pNext;
  VkExtent2D minFragmentShadingRateAttachmentTexelSize;
  VkExtent2D maxFragmentShadingRateAttachmentTexelSize;
  uint maxFragmentShadingRateAttachmentTexelSizeAspectRatio;
  VkBool32 primitiveFragmentShadingRateWithMultipleViewports;
  VkBool32 layeredShadingRateAttachments;
  VkBool32 fragmentShadingRateNonTrivialCombinerOps;
  VkExtent2D maxFragmentSize;
  uint maxFragmentSizeAspectRatio;
  uint maxFragmentShadingRateCoverageSamples;
  VkSampleCountFlagBits maxFragmentShadingRateRasterizationSamples;
  VkBool32 fragmentShadingRateWithShaderDepthStencilWrites;
  VkBool32 fragmentShadingRateWithSampleMask;
  VkBool32 fragmentShadingRateWithShaderSampleMask;
  VkBool32 fragmentShadingRateWithConservativeRasterization;
  VkBool32 fragmentShadingRateWithFragmentShaderInterlock;
  VkBool32 fragmentShadingRateWithCustomSampleLocations;
  VkBool32 fragmentShadingRateStrictMultiplyCombiner;
}

struct VkPhysicalDeviceFragmentShadingRateKHR {
  VkStructureType sType;
  void * pNext;
  VkSampleCountFlags sampleCounts;
  VkExtent2D fragmentSize;
}

alias PFN_vkGetPhysicalDeviceFragmentShadingRatesKHR = fn VkResult(
  VkPhysicalDevice physicalDevice, 
  uint * pFragmentShadingRateCount, 
  VkPhysicalDeviceFragmentShadingRateKHR * pFragmentShadingRates);

alias PFN_vkCmdSetFragmentShadingRateKHR = fn void(
  VkCommandBuffer commandBuffer, 
  VkExtent2D * pFragmentSize, 
  VkFragmentShadingRateCombinerOpKHR[2] combinerOps);

fn VkResult getPhysicalDeviceFragmentShadingRatesKHR(
  VkPhysicalDevice physicalDevice, 
  uint * pFragmentShadingRateCount, 
  VkPhysicalDeviceFragmentShadingRateKHR * pFragmentShadingRates)
@extern("vkGetPhysicalDeviceFragmentShadingRatesKHR");

fn void cmdSetFragmentShadingRateKHR(
  VkCommandBuffer commandBuffer, 
  VkExtent2D * pFragmentSize, 
  VkFragmentShadingRateCombinerOpKHR[2] combinerOps)
@extern("vkCmdSetFragmentShadingRateKHR");

struct VkSurfaceProtectedCapabilitiesKHR {
  VkStructureType sType;
  void * pNext;
  VkBool32 supportsProtected;
}

alias VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR = VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures;

alias VkAttachmentReferenceStencilLayoutKHR = VkAttachmentReferenceStencilLayout;

alias VkAttachmentDescriptionStencilLayoutKHR = VkAttachmentDescriptionStencilLayout;

struct VkPhysicalDevicePresentWaitFeaturesKHR {
  VkStructureType sType;
  void * pNext;
  VkBool32 presentWait;
}

alias PFN_vkWaitForPresentKHR = fn VkResult(
  VkDevice device, 
  VkSwapchainKHR swapchain, 
  ulong presentId, 
  ulong timeout);

fn VkResult waitForPresentKHR(
  VkDevice device, 
  VkSwapchainKHR swapchain, 
  ulong presentId, 
  ulong timeout)
@extern("vkWaitForPresentKHR");

alias VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR = VkPhysicalDeviceUniformBufferStandardLayoutFeatures;

alias VkPhysicalDeviceBufferDeviceAddressFeaturesKHR = VkPhysicalDeviceBufferDeviceAddressFeatures;

alias VkBufferDeviceAddressInfoKHR = VkBufferDeviceAddressInfo;

alias VkBufferOpaqueCaptureAddressCreateInfoKHR = VkBufferOpaqueCaptureAddressCreateInfo;

alias VkMemoryOpaqueCaptureAddressAllocateInfoKHR = VkMemoryOpaqueCaptureAddressAllocateInfo;

alias VkDeviceMemoryOpaqueCaptureAddressInfoKHR = VkDeviceMemoryOpaqueCaptureAddressInfo;

alias PFN_vkGetBufferDeviceAddressKHR = fn VkDeviceAddress(
  VkDevice device, 
  VkBufferDeviceAddressInfo * pInfo);

alias PFN_vkGetBufferOpaqueCaptureAddressKHR = fn ulong(
  VkDevice device, 
  VkBufferDeviceAddressInfo * pInfo);

alias PFN_vkGetDeviceMemoryOpaqueCaptureAddressKHR = fn ulong(
  VkDevice device, 
  VkDeviceMemoryOpaqueCaptureAddressInfo * pInfo);

fn VkDeviceAddress getBufferDeviceAddressKHR(
  VkDevice device, 
  VkBufferDeviceAddressInfo * pInfo)
@extern("vkGetBufferDeviceAddressKHR");

fn ulong getBufferOpaqueCaptureAddressKHR(
  VkDevice device, 
  VkBufferDeviceAddressInfo * pInfo)
@extern("vkGetBufferOpaqueCaptureAddressKHR");

fn ulong getDeviceMemoryOpaqueCaptureAddressKHR(
  VkDevice device, 
  VkDeviceMemoryOpaqueCaptureAddressInfo * pInfo)
@extern("vkGetDeviceMemoryOpaqueCaptureAddressKHR");

typedef VkDeferredOperationKHR_T = void;

alias VkDeferredOperationKHR = VkDeferredOperationKHR_T *;

alias PFN_vkCreateDeferredOperationKHR = fn VkResult(
  VkDevice device, 
  VkAllocationCallbacks * pAllocator, 
  VkDeferredOperationKHR * pDeferredOperation);

alias PFN_vkDestroyDeferredOperationKHR = fn void(
  VkDevice device, 
  VkDeferredOperationKHR operation, 
  VkAllocationCallbacks * pAllocator);

alias PFN_vkGetDeferredOperationMaxConcurrencyKHR = fn uint(
  VkDevice device, 
  VkDeferredOperationKHR operation);

alias PFN_vkGetDeferredOperationResultKHR = fn VkResult(
  VkDevice device, 
  VkDeferredOperationKHR operation);

alias PFN_vkDeferredOperationJoinKHR = fn VkResult(
  VkDevice device, 
  VkDeferredOperationKHR operation);

fn VkResult createDeferredOperationKHR(
  VkDevice device, 
  VkAllocationCallbacks * pAllocator, 
  VkDeferredOperationKHR * pDeferredOperation)
@extern("vkCreateDeferredOperationKHR");

fn void destroyDeferredOperationKHR(
  VkDevice device, 
  VkDeferredOperationKHR operation, 
  VkAllocationCallbacks * pAllocator)
@extern("vkDestroyDeferredOperationKHR");

fn uint getDeferredOperationMaxConcurrencyKHR(
  VkDevice device, 
  VkDeferredOperationKHR operation)
@extern("vkGetDeferredOperationMaxConcurrencyKHR");

fn VkResult getDeferredOperationResultKHR(
  VkDevice device, 
  VkDeferredOperationKHR operation)
@extern("vkGetDeferredOperationResultKHR");

fn VkResult deferredOperationJoinKHR(
  VkDevice device, 
  VkDeferredOperationKHR operation)
@extern("vkDeferredOperationJoinKHR");

typedef VkPipelineExecutableStatisticFormatKHR = inline CUInt;
const VkPipelineExecutableStatisticFormatKHR PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR = 0;
const VkPipelineExecutableStatisticFormatKHR PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR = 1;
const VkPipelineExecutableStatisticFormatKHR PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR = 2;
const VkPipelineExecutableStatisticFormatKHR PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR = 3;
const VkPipelineExecutableStatisticFormatKHR PIPELINE_EXECUTABLE_STATISTIC_FORMAT_MAX_ENUM_KHR = 0x7FFFFFFF;

struct VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR {
  VkStructureType sType;
  void * pNext;
  VkBool32 pipelineExecutableInfo;
}

struct VkPipelineInfoKHR {
  VkStructureType sType;
  void * pNext;
  VkPipeline pipeline;
}

struct VkPipelineExecutablePropertiesKHR {
  VkStructureType sType;
  void * pNext;
  VkShaderStageFlags stages;
  CChar[256] name;
  CChar[256] description;
  uint subgroupSize;
}

struct VkPipelineExecutableInfoKHR {
  VkStructureType sType;
  void * pNext;
  VkPipeline pipeline;
  uint executableIndex;
}

union VkPipelineExecutableStatisticValueKHR {
  VkBool32 b32;
  long i64;
  ulong u64;
  double f64;
}

struct VkPipelineExecutableStatisticKHR {
  VkStructureType sType;
  void * pNext;
  CChar[256] name;
  CChar[256] description;
  VkPipelineExecutableStatisticFormatKHR format;
  VkPipelineExecutableStatisticValueKHR value;
}

struct VkPipelineExecutableInternalRepresentationKHR {
  VkStructureType sType;
  void * pNext;
  CChar[256] name;
  CChar[256] description;
  VkBool32 isText;
  usz dataSize;
  void * pData;
}

alias PFN_vkGetPipelineExecutablePropertiesKHR = fn VkResult(
  VkDevice device, 
  VkPipelineInfoKHR * pPipelineInfo, 
  uint * pExecutableCount, 
  VkPipelineExecutablePropertiesKHR * pProperties);

alias PFN_vkGetPipelineExecutableStatisticsKHR = fn VkResult(
  VkDevice device, 
  VkPipelineExecutableInfoKHR * pExecutableInfo, 
  uint * pStatisticCount, 
  VkPipelineExecutableStatisticKHR * pStatistics);

alias PFN_vkGetPipelineExecutableInternalRepresentationsKHR = fn VkResult(
  VkDevice device, 
  VkPipelineExecutableInfoKHR * pExecutableInfo, 
  uint * pInternalRepresentationCount, 
  VkPipelineExecutableInternalRepresentationKHR * pInternalRepresentations);

fn VkResult getPipelineExecutablePropertiesKHR(
  VkDevice device, 
  VkPipelineInfoKHR * pPipelineInfo, 
  uint * pExecutableCount, 
  VkPipelineExecutablePropertiesKHR * pProperties)
@extern("vkGetPipelineExecutablePropertiesKHR");

fn VkResult getPipelineExecutableStatisticsKHR(
  VkDevice device, 
  VkPipelineExecutableInfoKHR * pExecutableInfo, 
  uint * pStatisticCount, 
  VkPipelineExecutableStatisticKHR * pStatistics)
@extern("vkGetPipelineExecutableStatisticsKHR");

fn VkResult getPipelineExecutableInternalRepresentationsKHR(
  VkDevice device, 
  VkPipelineExecutableInfoKHR * pExecutableInfo, 
  uint * pInternalRepresentationCount, 
  VkPipelineExecutableInternalRepresentationKHR * pInternalRepresentations)
@extern("vkGetPipelineExecutableInternalRepresentationsKHR");

struct VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR {
  VkStructureType sType;
  void * pNext;
  VkBool32 shaderIntegerDotProduct;
}

struct VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR {
  VkStructureType sType;
  void * pNext;
  VkBool32 integerDotProduct8BitUnsignedAccelerated;
  VkBool32 integerDotProduct8BitSignedAccelerated;
  VkBool32 integerDotProduct8BitMixedSignednessAccelerated;
  VkBool32 integerDotProduct4x8BitPackedUnsignedAccelerated;
  VkBool32 integerDotProduct4x8BitPackedSignedAccelerated;
  VkBool32 integerDotProduct4x8BitPackedMixedSignednessAccelerated;
  VkBool32 integerDotProduct16BitUnsignedAccelerated;
  VkBool32 integerDotProduct16BitSignedAccelerated;
  VkBool32 integerDotProduct16BitMixedSignednessAccelerated;
  VkBool32 integerDotProduct32BitUnsignedAccelerated;
  VkBool32 integerDotProduct32BitSignedAccelerated;
  VkBool32 integerDotProduct32BitMixedSignednessAccelerated;
  VkBool32 integerDotProduct64BitUnsignedAccelerated;
  VkBool32 integerDotProduct64BitSignedAccelerated;
  VkBool32 integerDotProduct64BitMixedSignednessAccelerated;
  VkBool32 integerDotProductAccumulatingSaturating8BitUnsignedAccelerated;
  VkBool32 integerDotProductAccumulatingSaturating8BitSignedAccelerated;
  VkBool32 integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated;
  VkBool32 integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated;
  VkBool32 integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated;
  VkBool32 integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated;
  VkBool32 integerDotProductAccumulatingSaturating16BitUnsignedAccelerated;
  VkBool32 integerDotProductAccumulatingSaturating16BitSignedAccelerated;
  VkBool32 integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated;
  VkBool32 integerDotProductAccumulatingSaturating32BitUnsignedAccelerated;
  VkBool32 integerDotProductAccumulatingSaturating32BitSignedAccelerated;
  VkBool32 integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated;
  VkBool32 integerDotProductAccumulatingSaturating64BitUnsignedAccelerated;
  VkBool32 integerDotProductAccumulatingSaturating64BitSignedAccelerated;
  VkBool32 integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated;
}

struct VkPipelineLibraryCreateInfoKHR {
  VkStructureType sType;
  void * pNext;
  uint libraryCount;
  VkPipeline * pLibraries;
}

struct VkPresentIdKHR {
  VkStructureType sType;
  void * pNext;
  uint swapchainCount;
  ulong * pPresentIds;
}

struct VkPhysicalDevicePresentIdFeaturesKHR {
  VkStructureType sType;
  void * pNext;
  VkBool32 presentId;
}

alias VkFlags64 = ulong;

alias VkPipelineStageFlags2KHR = VkFlags64;

alias VkPipelineStageFlagBits2KHR = VkFlags64;

const VkPipelineStageFlagBits2KHR PIPELINE_STAGE_2_NONE_KHR = 0UL;

const VkPipelineStageFlagBits2KHR PIPELINE_STAGE_2_TOP_OF_PIPE_BIT_KHR = 0x00000001UL;

const VkPipelineStageFlagBits2KHR PIPELINE_STAGE_2_DRAW_INDIRECT_BIT_KHR = 0x00000002UL;

const VkPipelineStageFlagBits2KHR PIPELINE_STAGE_2_VERTEX_INPUT_BIT_KHR = 0x00000004UL;

const VkPipelineStageFlagBits2KHR PIPELINE_STAGE_2_VERTEX_SHADER_BIT_KHR = 0x00000008UL;

const VkPipelineStageFlagBits2KHR PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT_KHR = 0x00000010UL;

const VkPipelineStageFlagBits2KHR PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT_KHR = 0x00000020UL;

const VkPipelineStageFlagBits2KHR PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT_KHR = 0x00000040UL;

const VkPipelineStageFlagBits2KHR PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR = 0x00000080UL;

const VkPipelineStageFlagBits2KHR PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT_KHR = 0x00000100UL;

const VkPipelineStageFlagBits2KHR PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT_KHR = 0x00000200UL;

const VkPipelineStageFlagBits2KHR PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR = 0x00000400UL;

const VkPipelineStageFlagBits2KHR PIPELINE_STAGE_2_COMPUTE_SHADER_BIT_KHR = 0x00000800UL;

const VkPipelineStageFlagBits2KHR PIPELINE_STAGE_2_ALL_TRANSFER_BIT_KHR = 0x00001000UL;

const VkPipelineStageFlagBits2KHR PIPELINE_STAGE_2_TRANSFER_BIT_KHR = 0x00001000UL;

const VkPipelineStageFlagBits2KHR PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT_KHR = 0x00002000UL;

const VkPipelineStageFlagBits2KHR PIPELINE_STAGE_2_HOST_BIT_KHR = 0x00004000UL;

const VkPipelineStageFlagBits2KHR PIPELINE_STAGE_2_ALL_GRAPHICS_BIT_KHR = 0x00008000UL;

const VkPipelineStageFlagBits2KHR PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR = 0x00010000UL;

const VkPipelineStageFlagBits2KHR PIPELINE_STAGE_2_COPY_BIT_KHR = 0x100000000UL;

const VkPipelineStageFlagBits2KHR PIPELINE_STAGE_2_RESOLVE_BIT_KHR = 0x200000000UL;

const VkPipelineStageFlagBits2KHR PIPELINE_STAGE_2_BLIT_BIT_KHR = 0x400000000UL;

const VkPipelineStageFlagBits2KHR PIPELINE_STAGE_2_CLEAR_BIT_KHR = 0x800000000UL;

const VkPipelineStageFlagBits2KHR PIPELINE_STAGE_2_INDEX_INPUT_BIT_KHR = 0x1000000000UL;

const VkPipelineStageFlagBits2KHR PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT_KHR = 0x2000000000UL;

const VkPipelineStageFlagBits2KHR PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT_KHR = 0x4000000000UL;

const VkPipelineStageFlagBits2KHR PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR = 0x04000000UL;

const VkPipelineStageFlagBits2KHR PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR = 0x08000000UL;

const VkPipelineStageFlagBits2KHR PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT = 0x01000000UL;

const VkPipelineStageFlagBits2KHR PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT = 0x00040000UL;

const VkPipelineStageFlagBits2KHR PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV = 0x00020000UL;

const VkPipelineStageFlagBits2KHR PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00400000UL;

const VkPipelineStageFlagBits2KHR PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV = 0x00400000UL;

const VkPipelineStageFlagBits2KHR PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR = 0x02000000UL;

const VkPipelineStageFlagBits2KHR PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR = 0x00200000UL;

const VkPipelineStageFlagBits2KHR PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_NV = 0x00200000UL;

const VkPipelineStageFlagBits2KHR PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_NV = 0x02000000UL;

const VkPipelineStageFlagBits2KHR PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT = 0x00800000UL;

const VkPipelineStageFlagBits2KHR PIPELINE_STAGE_2_TASK_SHADER_BIT_NV = 0x00080000UL;

const VkPipelineStageFlagBits2KHR PIPELINE_STAGE_2_MESH_SHADER_BIT_NV = 0x00100000UL;

const VkPipelineStageFlagBits2KHR PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI = 0x8000000000UL;

const VkPipelineStageFlagBits2KHR PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI = 0x10000000000UL;

alias VkAccessFlags2KHR = VkFlags64;

alias VkAccessFlagBits2KHR = VkFlags64;

const VkAccessFlagBits2KHR ACCESS_2_NONE_KHR = 0UL;

const VkAccessFlagBits2KHR ACCESS_2_INDIRECT_COMMAND_READ_BIT_KHR = 0x00000001UL;

const VkAccessFlagBits2KHR ACCESS_2_INDEX_READ_BIT_KHR = 0x00000002UL;

const VkAccessFlagBits2KHR ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT_KHR = 0x00000004UL;

const VkAccessFlagBits2KHR ACCESS_2_UNIFORM_READ_BIT_KHR = 0x00000008UL;

const VkAccessFlagBits2KHR ACCESS_2_INPUT_ATTACHMENT_READ_BIT_KHR = 0x00000010UL;

const VkAccessFlagBits2KHR ACCESS_2_SHADER_READ_BIT_KHR = 0x00000020UL;

const VkAccessFlagBits2KHR ACCESS_2_SHADER_WRITE_BIT_KHR = 0x00000040UL;

const VkAccessFlagBits2KHR ACCESS_2_COLOR_ATTACHMENT_READ_BIT_KHR = 0x00000080UL;

const VkAccessFlagBits2KHR ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT_KHR = 0x00000100UL;

const VkAccessFlagBits2KHR ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT_KHR = 0x00000200UL;

const VkAccessFlagBits2KHR ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT_KHR = 0x00000400UL;

const VkAccessFlagBits2KHR ACCESS_2_TRANSFER_READ_BIT_KHR = 0x00000800UL;

const VkAccessFlagBits2KHR ACCESS_2_TRANSFER_WRITE_BIT_KHR = 0x00001000UL;

const VkAccessFlagBits2KHR ACCESS_2_HOST_READ_BIT_KHR = 0x00002000UL;

const VkAccessFlagBits2KHR ACCESS_2_HOST_WRITE_BIT_KHR = 0x00004000UL;

const VkAccessFlagBits2KHR ACCESS_2_MEMORY_READ_BIT_KHR = 0x00008000UL;

const VkAccessFlagBits2KHR ACCESS_2_MEMORY_WRITE_BIT_KHR = 0x00010000UL;

const VkAccessFlagBits2KHR ACCESS_2_SHADER_SAMPLED_READ_BIT_KHR = 0x100000000UL;

const VkAccessFlagBits2KHR ACCESS_2_SHADER_STORAGE_READ_BIT_KHR = 0x200000000UL;

const VkAccessFlagBits2KHR ACCESS_2_SHADER_STORAGE_WRITE_BIT_KHR = 0x400000000UL;

const VkAccessFlagBits2KHR ACCESS_2_VIDEO_DECODE_READ_BIT_KHR = 0x800000000UL;

const VkAccessFlagBits2KHR ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR = 0x1000000000UL;

const VkAccessFlagBits2KHR ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR = 0x2000000000UL;

const VkAccessFlagBits2KHR ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR = 0x4000000000UL;

const VkAccessFlagBits2KHR ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT = 0x02000000UL;

const VkAccessFlagBits2KHR ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT = 0x04000000UL;

const VkAccessFlagBits2KHR ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT = 0x08000000UL;

const VkAccessFlagBits2KHR ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT = 0x00100000UL;

const VkAccessFlagBits2KHR ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV = 0x00020000UL;

const VkAccessFlagBits2KHR ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV = 0x00040000UL;

const VkAccessFlagBits2KHR ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR = 0x00800000UL;

const VkAccessFlagBits2KHR ACCESS_2_SHADING_RATE_IMAGE_READ_BIT_NV = 0x00800000UL;

const VkAccessFlagBits2KHR ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR = 0x00200000UL;

const VkAccessFlagBits2KHR ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR = 0x00400000UL;

const VkAccessFlagBits2KHR ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_NV = 0x00200000UL;

const VkAccessFlagBits2KHR ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_NV = 0x00400000UL;

const VkAccessFlagBits2KHR ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT = 0x01000000UL;

const VkAccessFlagBits2KHR ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = 0x00080000UL;

const VkAccessFlagBits2KHR ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI = 0x8000000000UL;

typedef VkSubmitFlagBitsKHR = inline CUInt;
const VkSubmitFlagBitsKHR SUBMIT_PROTECTED_BIT_KHR = 0x00000001;
const VkSubmitFlagBitsKHR SUBMIT_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF;

alias VkSubmitFlagsKHR = VkFlags;

struct VkMemoryBarrier2KHR {
  VkStructureType sType;
  void * pNext;
  VkPipelineStageFlags2KHR srcStageMask;
  VkAccessFlags2KHR srcAccessMask;
  VkPipelineStageFlags2KHR dstStageMask;
  VkAccessFlags2KHR dstAccessMask;
}

struct VkBufferMemoryBarrier2KHR {
  VkStructureType sType;
  void * pNext;
  VkPipelineStageFlags2KHR srcStageMask;
  VkAccessFlags2KHR srcAccessMask;
  VkPipelineStageFlags2KHR dstStageMask;
  VkAccessFlags2KHR dstAccessMask;
  uint srcQueueFamilyIndex;
  uint dstQueueFamilyIndex;
  VkBuffer buffer;
  VkDeviceSize offset;
  VkDeviceSize size;
}

struct VkImageMemoryBarrier2KHR {
  VkStructureType sType;
  void * pNext;
  VkPipelineStageFlags2KHR srcStageMask;
  VkAccessFlags2KHR srcAccessMask;
  VkPipelineStageFlags2KHR dstStageMask;
  VkAccessFlags2KHR dstAccessMask;
  VkImageLayout oldLayout;
  VkImageLayout newLayout;
  uint srcQueueFamilyIndex;
  uint dstQueueFamilyIndex;
  VkImage image;
  VkImageSubresourceRange subresourceRange;
}

struct VkDependencyInfoKHR {
  VkStructureType sType;
  void * pNext;
  VkDependencyFlags dependencyFlags;
  uint memoryBarrierCount;
  VkMemoryBarrier2KHR * pMemoryBarriers;
  uint bufferMemoryBarrierCount;
  VkBufferMemoryBarrier2KHR * pBufferMemoryBarriers;
  uint imageMemoryBarrierCount;
  VkImageMemoryBarrier2KHR * pImageMemoryBarriers;
}

struct VkSemaphoreSubmitInfoKHR {
  VkStructureType sType;
  void * pNext;
  VkSemaphore semaphore;
  ulong value;
  VkPipelineStageFlags2KHR stageMask;
  uint deviceIndex;
}

struct VkCommandBufferSubmitInfoKHR {
  VkStructureType sType;
  void * pNext;
  VkCommandBuffer commandBuffer;
  uint deviceMask;
}

struct VkSubmitInfo2KHR {
  VkStructureType sType;
  void * pNext;
  VkSubmitFlagsKHR flags;
  uint waitSemaphoreInfoCount;
  VkSemaphoreSubmitInfoKHR * pWaitSemaphoreInfos;
  uint commandBufferInfoCount;
  VkCommandBufferSubmitInfoKHR * pCommandBufferInfos;
  uint signalSemaphoreInfoCount;
  VkSemaphoreSubmitInfoKHR * pSignalSemaphoreInfos;
}

struct VkPhysicalDeviceSynchronization2FeaturesKHR {
  VkStructureType sType;
  void * pNext;
  VkBool32 synchronization2;
}

struct VkQueueFamilyCheckpointProperties2NV {
  VkStructureType sType;
  void * pNext;
  VkPipelineStageFlags2KHR checkpointExecutionStageMask;
}

struct VkCheckpointData2NV {
  VkStructureType sType;
  void * pNext;
  VkPipelineStageFlags2KHR stage;
  void * pCheckpointMarker;
}

alias PFN_vkCmdSetEvent2KHR = fn void(
  VkCommandBuffer commandBuffer, 
  VkEvent event, 
  VkDependencyInfoKHR * pDependencyInfo);

alias PFN_vkCmdResetEvent2KHR = fn void(
  VkCommandBuffer commandBuffer, 
  VkEvent event, 
  VkPipelineStageFlags2KHR stageMask);

alias PFN_vkCmdWaitEvents2KHR = fn void(
  VkCommandBuffer commandBuffer, 
  uint eventCount, 
  VkEvent * pEvents, 
  VkDependencyInfoKHR * pDependencyInfos);

alias PFN_vkCmdPipelineBarrier2KHR = fn void(
  VkCommandBuffer commandBuffer, 
  VkDependencyInfoKHR * pDependencyInfo);

alias PFN_vkCmdWriteTimestamp2KHR = fn void(
  VkCommandBuffer commandBuffer, 
  VkPipelineStageFlags2KHR stage, 
  VkQueryPool queryPool, 
  uint query);

alias PFN_vkQueueSubmit2KHR = fn VkResult(
  VkQueue queue, 
  uint submitCount, 
  VkSubmitInfo2KHR * pSubmits, 
  VkFence fence);

alias PFN_vkCmdWriteBufferMarker2AMD = fn void(
  VkCommandBuffer commandBuffer, 
  VkPipelineStageFlags2KHR stage, 
  VkBuffer dstBuffer, 
  VkDeviceSize dstOffset, 
  uint marker);

alias PFN_vkGetQueueCheckpointData2NV = fn void(
  VkQueue queue, 
  uint * pCheckpointDataCount, 
  VkCheckpointData2NV * pCheckpointData);

fn void cmdSetEvent2KHR(
  VkCommandBuffer commandBuffer, 
  VkEvent event, 
  VkDependencyInfoKHR * pDependencyInfo)
@extern("vkCmdSetEvent2KHR");

fn void cmdResetEvent2KHR(
  VkCommandBuffer commandBuffer, 
  VkEvent event, 
  VkPipelineStageFlags2KHR stageMask)
@extern("vkCmdResetEvent2KHR");

fn void cmdWaitEvents2KHR(
  VkCommandBuffer commandBuffer, 
  uint eventCount, 
  VkEvent * pEvents, 
  VkDependencyInfoKHR * pDependencyInfos)
@extern("vkCmdWaitEvents2KHR");

fn void cmdPipelineBarrier2KHR(
  VkCommandBuffer commandBuffer, 
  VkDependencyInfoKHR * pDependencyInfo)
@extern("vkCmdPipelineBarrier2KHR");

fn void cmdWriteTimestamp2KHR(
  VkCommandBuffer commandBuffer, 
  VkPipelineStageFlags2KHR stage, 
  VkQueryPool queryPool, 
  uint query)
@extern("vkCmdWriteTimestamp2KHR");

fn VkResult queueSubmit2KHR(
  VkQueue queue, 
  uint submitCount, 
  VkSubmitInfo2KHR * pSubmits, 
  VkFence fence)
@extern("vkQueueSubmit2KHR");

fn void cmdWriteBufferMarker2AMD(
  VkCommandBuffer commandBuffer, 
  VkPipelineStageFlags2KHR stage, 
  VkBuffer dstBuffer, 
  VkDeviceSize dstOffset, 
  uint marker)
@extern("vkCmdWriteBufferMarker2AMD");

fn void getQueueCheckpointData2NV(
  VkQueue queue, 
  uint * pCheckpointDataCount, 
  VkCheckpointData2NV * pCheckpointData)
@extern("vkGetQueueCheckpointData2NV");

struct VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR {
  VkStructureType sType;
  void * pNext;
  VkBool32 shaderSubgroupUniformControlFlow;
}

struct VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR {
  VkStructureType sType;
  void * pNext;
  VkBool32 shaderZeroInitializeWorkgroupMemory;
}

struct VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR {
  VkStructureType sType;
  void * pNext;
  VkBool32 workgroupMemoryExplicitLayout;
  VkBool32 workgroupMemoryExplicitLayoutScalarBlockLayout;
  VkBool32 workgroupMemoryExplicitLayout8BitAccess;
  VkBool32 workgroupMemoryExplicitLayout16BitAccess;
}

struct VkBufferCopy2KHR {
  VkStructureType sType;
  void * pNext;
  VkDeviceSize srcOffset;
  VkDeviceSize dstOffset;
  VkDeviceSize size;
}

struct VkCopyBufferInfo2KHR {
  VkStructureType sType;
  void * pNext;
  VkBuffer srcBuffer;
  VkBuffer dstBuffer;
  uint regionCount;
  VkBufferCopy2KHR * pRegions;
}

struct VkImageCopy2KHR {
  VkStructureType sType;
  void * pNext;
  VkImageSubresourceLayers srcSubresource;
  VkOffset3D srcOffset;
  VkImageSubresourceLayers dstSubresource;
  VkOffset3D dstOffset;
  VkExtent3D extent;
}

struct VkCopyImageInfo2KHR {
  VkStructureType sType;
  void * pNext;
  VkImage srcImage;
  VkImageLayout srcImageLayout;
  VkImage dstImage;
  VkImageLayout dstImageLayout;
  uint regionCount;
  VkImageCopy2KHR * pRegions;
}

struct VkBufferImageCopy2KHR {
  VkStructureType sType;
  void * pNext;
  VkDeviceSize bufferOffset;
  uint bufferRowLength;
  uint bufferImageHeight;
  VkImageSubresourceLayers imageSubresource;
  VkOffset3D imageOffset;
  VkExtent3D imageExtent;
}

struct VkCopyBufferToImageInfo2KHR {
  VkStructureType sType;
  void * pNext;
  VkBuffer srcBuffer;
  VkImage dstImage;
  VkImageLayout dstImageLayout;
  uint regionCount;
  VkBufferImageCopy2KHR * pRegions;
}

struct VkCopyImageToBufferInfo2KHR {
  VkStructureType sType;
  void * pNext;
  VkImage srcImage;
  VkImageLayout srcImageLayout;
  VkBuffer dstBuffer;
  uint regionCount;
  VkBufferImageCopy2KHR * pRegions;
}

struct VkImageBlit2KHR {
  VkStructureType sType;
  void * pNext;
  VkImageSubresourceLayers srcSubresource;
  VkOffset3D[2] srcOffsets;
  VkImageSubresourceLayers dstSubresource;
  VkOffset3D[2] dstOffsets;
}

struct VkBlitImageInfo2KHR {
  VkStructureType sType;
  void * pNext;
  VkImage srcImage;
  VkImageLayout srcImageLayout;
  VkImage dstImage;
  VkImageLayout dstImageLayout;
  uint regionCount;
  VkImageBlit2KHR * pRegions;
  VkFilter filter;
}

struct VkImageResolve2KHR {
  VkStructureType sType;
  void * pNext;
  VkImageSubresourceLayers srcSubresource;
  VkOffset3D srcOffset;
  VkImageSubresourceLayers dstSubresource;
  VkOffset3D dstOffset;
  VkExtent3D extent;
}

struct VkResolveImageInfo2KHR {
  VkStructureType sType;
  void * pNext;
  VkImage srcImage;
  VkImageLayout srcImageLayout;
  VkImage dstImage;
  VkImageLayout dstImageLayout;
  uint regionCount;
  VkImageResolve2KHR * pRegions;
}

alias PFN_vkCmdCopyBuffer2KHR = fn void(
  VkCommandBuffer commandBuffer, 
  VkCopyBufferInfo2KHR * pCopyBufferInfo);

alias PFN_vkCmdCopyImage2KHR = fn void(
  VkCommandBuffer commandBuffer, 
  VkCopyImageInfo2KHR * pCopyImageInfo);

alias PFN_vkCmdCopyBufferToImage2KHR = fn void(
  VkCommandBuffer commandBuffer, 
  VkCopyBufferToImageInfo2KHR * pCopyBufferToImageInfo);

alias PFN_vkCmdCopyImageToBuffer2KHR = fn void(
  VkCommandBuffer commandBuffer, 
  VkCopyImageToBufferInfo2KHR * pCopyImageToBufferInfo);

alias PFN_vkCmdBlitImage2KHR = fn void(
  VkCommandBuffer commandBuffer, 
  VkBlitImageInfo2KHR * pBlitImageInfo);

alias PFN_vkCmdResolveImage2KHR = fn void(
  VkCommandBuffer commandBuffer, 
  VkResolveImageInfo2KHR * pResolveImageInfo);

fn void cmdCopyBuffer2KHR(
  VkCommandBuffer commandBuffer, 
  VkCopyBufferInfo2KHR * pCopyBufferInfo)
@extern("vkCmdCopyBuffer2KHR");

fn void cmdCopyImage2KHR(
  VkCommandBuffer commandBuffer, 
  VkCopyImageInfo2KHR * pCopyImageInfo)
@extern("vkCmdCopyImage2KHR");

fn void cmdCopyBufferToImage2KHR(
  VkCommandBuffer commandBuffer, 
  VkCopyBufferToImageInfo2KHR * pCopyBufferToImageInfo)
@extern("vkCmdCopyBufferToImage2KHR");

fn void cmdCopyImageToBuffer2KHR(
  VkCommandBuffer commandBuffer, 
  VkCopyImageToBufferInfo2KHR * pCopyImageToBufferInfo)
@extern("vkCmdCopyImageToBuffer2KHR");

fn void cmdBlitImage2KHR(
  VkCommandBuffer commandBuffer, 
  VkBlitImageInfo2KHR * pBlitImageInfo)
@extern("vkCmdBlitImage2KHR");

fn void cmdResolveImage2KHR(
  VkCommandBuffer commandBuffer, 
  VkResolveImageInfo2KHR * pResolveImageInfo)
@extern("vkCmdResolveImage2KHR");

alias VkFormatFeatureFlags2KHR = VkFlags64;

alias VkFormatFeatureFlagBits2KHR = VkFlags64;

const VkFormatFeatureFlagBits2KHR FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT_KHR = 0x00000001UL;

const VkFormatFeatureFlagBits2KHR FORMAT_FEATURE_2_STORAGE_IMAGE_BIT_KHR = 0x00000002UL;

const VkFormatFeatureFlagBits2KHR FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT_KHR = 0x00000004UL;

const VkFormatFeatureFlagBits2KHR FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR = 0x00000008UL;

const VkFormatFeatureFlagBits2KHR FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT_KHR = 0x00000010UL;

const VkFormatFeatureFlagBits2KHR FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT_KHR = 0x00000020UL;

const VkFormatFeatureFlagBits2KHR FORMAT_FEATURE_2_VERTEX_BUFFER_BIT_KHR = 0x00000040UL;

const VkFormatFeatureFlagBits2KHR FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT_KHR = 0x00000080UL;

const VkFormatFeatureFlagBits2KHR FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT_KHR = 0x00000100UL;

const VkFormatFeatureFlagBits2KHR FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT_KHR = 0x00000200UL;

const VkFormatFeatureFlagBits2KHR FORMAT_FEATURE_2_BLIT_SRC_BIT_KHR = 0x00000400UL;

const VkFormatFeatureFlagBits2KHR FORMAT_FEATURE_2_BLIT_DST_BIT_KHR = 0x00000800UL;

const VkFormatFeatureFlagBits2KHR FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT_KHR = 0x00001000UL;

const VkFormatFeatureFlagBits2KHR FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT = 0x00002000UL;

const VkFormatFeatureFlagBits2KHR FORMAT_FEATURE_2_TRANSFER_SRC_BIT_KHR = 0x00004000UL;

const VkFormatFeatureFlagBits2KHR FORMAT_FEATURE_2_TRANSFER_DST_BIT_KHR = 0x00008000UL;

const VkFormatFeatureFlagBits2KHR FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT_KHR = 0x00010000UL;

const VkFormatFeatureFlagBits2KHR FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT_KHR = 0x00020000UL;

const VkFormatFeatureFlagBits2KHR FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR = 0x00040000UL;

const VkFormatFeatureFlagBits2KHR FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR = 0x00080000UL;

const VkFormatFeatureFlagBits2KHR FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR = 0x00100000UL;

const VkFormatFeatureFlagBits2KHR FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR = 0x00200000UL;

const VkFormatFeatureFlagBits2KHR FORMAT_FEATURE_2_DISJOINT_BIT_KHR = 0x00400000UL;

const VkFormatFeatureFlagBits2KHR FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT_KHR = 0x00800000UL;

const VkFormatFeatureFlagBits2KHR FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT_KHR = 0x80000000UL;

const VkFormatFeatureFlagBits2KHR FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT_KHR = 0x100000000UL;

const VkFormatFeatureFlagBits2KHR FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT_KHR = 0x200000000UL;

const VkFormatFeatureFlagBits2KHR FORMAT_FEATURE_2_VIDEO_DECODE_OUTPUT_BIT_KHR = 0x02000000UL;

const VkFormatFeatureFlagBits2KHR FORMAT_FEATURE_2_VIDEO_DECODE_DPB_BIT_KHR = 0x04000000UL;

const VkFormatFeatureFlagBits2KHR FORMAT_FEATURE_2_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR = 0x20000000UL;

const VkFormatFeatureFlagBits2KHR FORMAT_FEATURE_2_FRAGMENT_DENSITY_MAP_BIT_EXT = 0x01000000UL;

const VkFormatFeatureFlagBits2KHR FORMAT_FEATURE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x40000000UL;

const VkFormatFeatureFlagBits2KHR FORMAT_FEATURE_2_VIDEO_ENCODE_INPUT_BIT_KHR = 0x08000000UL;

const VkFormatFeatureFlagBits2KHR FORMAT_FEATURE_2_VIDEO_ENCODE_DPB_BIT_KHR = 0x10000000UL;

const VkFormatFeatureFlagBits2KHR FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV = 0x4000000000UL;

struct VkFormatProperties3KHR {
  VkStructureType sType;
  void * pNext;
  VkFormatFeatureFlags2KHR linearTilingFeatures;
  VkFormatFeatureFlags2KHR optimalTilingFeatures;
  VkFormatFeatureFlags2KHR bufferFeatures;
}

struct VkPhysicalDeviceMaintenance4FeaturesKHR {
  VkStructureType sType;
  void * pNext;
  VkBool32 maintenance4;
}

struct VkPhysicalDeviceMaintenance4PropertiesKHR {
  VkStructureType sType;
  void * pNext;
  VkDeviceSize maxBufferSize;
}

struct VkDeviceBufferMemoryRequirementsKHR {
  VkStructureType sType;
  void * pNext;
  VkBufferCreateInfo * pCreateInfo;
}

struct VkDeviceImageMemoryRequirementsKHR {
  VkStructureType sType;
  void * pNext;
  VkImageCreateInfo * pCreateInfo;
  VkImageAspectFlagBits planeAspect;
}

alias PFN_vkGetDeviceBufferMemoryRequirementsKHR = fn void(
  VkDevice device, 
  VkDeviceBufferMemoryRequirementsKHR * pInfo, 
  VkMemoryRequirements2 * pMemoryRequirements);

alias PFN_vkGetDeviceImageMemoryRequirementsKHR = fn void(
  VkDevice device, 
  VkDeviceImageMemoryRequirementsKHR * pInfo, 
  VkMemoryRequirements2 * pMemoryRequirements);

alias PFN_vkGetDeviceImageSparseMemoryRequirementsKHR = fn void(
  VkDevice device, 
  VkDeviceImageMemoryRequirementsKHR * pInfo, 
  uint * pSparseMemoryRequirementCount, 
  VkSparseImageMemoryRequirements2 * pSparseMemoryRequirements);

fn void getDeviceBufferMemoryRequirementsKHR(
  VkDevice device, 
  VkDeviceBufferMemoryRequirementsKHR * pInfo, 
  VkMemoryRequirements2 * pMemoryRequirements)
@extern("vkGetDeviceBufferMemoryRequirementsKHR");

fn void getDeviceImageMemoryRequirementsKHR(
  VkDevice device, 
  VkDeviceImageMemoryRequirementsKHR * pInfo, 
  VkMemoryRequirements2 * pMemoryRequirements)
@extern("vkGetDeviceImageMemoryRequirementsKHR");

fn void getDeviceImageSparseMemoryRequirementsKHR(
  VkDevice device, 
  VkDeviceImageMemoryRequirementsKHR * pInfo, 
  uint * pSparseMemoryRequirementCount, 
  VkSparseImageMemoryRequirements2 * pSparseMemoryRequirements)
@extern("vkGetDeviceImageSparseMemoryRequirementsKHR");

typedef VkDebugReportCallbackEXT_T = void;

alias VkDebugReportCallbackEXT = VkDebugReportCallbackEXT_T *;

typedef VkDebugReportObjectTypeEXT = inline CUInt;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT = 0;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT = 1;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT = 2;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT = 3;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT = 4;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT = 5;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT = 6;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT = 7;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT = 8;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT = 9;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT = 10;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT = 11;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT = 12;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT = 13;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT = 14;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT = 15;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT = 16;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT = 17;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT = 18;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT = 19;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT = 20;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT = 21;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT = 22;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT = 23;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT = 24;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT = 25;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT = 26;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT = 27;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT = 28;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT = 29;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT = 30;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT = 33;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT = 1000156000;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT = 1000085000;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_CU_MODULE_NVX_EXT = 1000029000;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_CU_FUNCTION_NVX_EXT = 1000029001;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR_EXT = 1000150000;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT = 1000165000;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA_EXT = 1000366000;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT = DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT = DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT = DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT = DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF;

typedef VkDebugReportFlagBitsEXT = inline CUInt;
const VkDebugReportFlagBitsEXT DEBUG_REPORT_INFORMATION_BIT_EXT = 0x00000001;
const VkDebugReportFlagBitsEXT DEBUG_REPORT_WARNING_BIT_EXT = 0x00000002;
const VkDebugReportFlagBitsEXT DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT = 0x00000004;
const VkDebugReportFlagBitsEXT DEBUG_REPORT_ERROR_BIT_EXT = 0x00000008;
const VkDebugReportFlagBitsEXT DEBUG_REPORT_DEBUG_BIT_EXT = 0x00000010;
const VkDebugReportFlagBitsEXT DEBUG_REPORT_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF;

alias VkDebugReportFlagsEXT = VkFlags;

alias PFN_vkDebugReportCallbackEXT = fn VkBool32(
  VkDebugReportFlagsEXT flags, 
  VkDebugReportObjectTypeEXT objectType, 
  ulong object, 
  usz location, 
  int messageCode, 
  CChar * pLayerPrefix, 
  CChar * pMessage, 
  void * pUserData);

struct VkDebugReportCallbackCreateInfoEXT {
  VkStructureType sType;
  void * pNext;
  VkDebugReportFlagsEXT flags;
  PFN_vkDebugReportCallbackEXT pfnCallback;
  void * pUserData;
}

alias PFN_vkCreateDebugReportCallbackEXT = fn VkResult(
  VkInstance instance, 
  VkDebugReportCallbackCreateInfoEXT * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkDebugReportCallbackEXT * pCallback);

alias PFN_vkDestroyDebugReportCallbackEXT = fn void(
  VkInstance instance, 
  VkDebugReportCallbackEXT callback, 
  VkAllocationCallbacks * pAllocator);

alias PFN_vkDebugReportMessageEXT = fn void(
  VkInstance instance, 
  VkDebugReportFlagsEXT flags, 
  VkDebugReportObjectTypeEXT objectType, 
  ulong object, 
  usz location, 
  int messageCode, 
  CChar * pLayerPrefix, 
  CChar * pMessage);

fn VkResult createDebugReportCallbackEXT(
  VkInstance instance, 
  VkDebugReportCallbackCreateInfoEXT * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkDebugReportCallbackEXT * pCallback)
@extern("vkCreateDebugReportCallbackEXT");

fn void destroyDebugReportCallbackEXT(
  VkInstance instance, 
  VkDebugReportCallbackEXT callback, 
  VkAllocationCallbacks * pAllocator)
@extern("vkDestroyDebugReportCallbackEXT");

fn void debugReportMessageEXT(
  VkInstance instance, 
  VkDebugReportFlagsEXT flags, 
  VkDebugReportObjectTypeEXT objectType, 
  ulong object, 
  usz location, 
  int messageCode, 
  CChar * pLayerPrefix, 
  CChar * pMessage)
@extern("vkDebugReportMessageEXT");

typedef VkRasterizationOrderAMD = inline CUInt;
const VkRasterizationOrderAMD RASTERIZATION_ORDER_STRICT_AMD = 0;
const VkRasterizationOrderAMD RASTERIZATION_ORDER_RELAXED_AMD = 1;
const VkRasterizationOrderAMD RASTERIZATION_ORDER_MAX_ENUM_AMD = 0x7FFFFFFF;

struct VkPipelineRasterizationStateRasterizationOrderAMD {
  VkStructureType sType;
  void * pNext;
  VkRasterizationOrderAMD rasterizationOrder;
}

struct VkDebugMarkerObjectNameInfoEXT {
  VkStructureType sType;
  void * pNext;
  VkDebugReportObjectTypeEXT objectType;
  ulong object;
  CChar * pObjectName;
}

struct VkDebugMarkerObjectTagInfoEXT {
  VkStructureType sType;
  void * pNext;
  VkDebugReportObjectTypeEXT objectType;
  ulong object;
  ulong tagName;
  usz tagSize;
  void * pTag;
}

struct VkDebugMarkerMarkerInfoEXT {
  VkStructureType sType;
  void * pNext;
  CChar * pMarkerName;
  float[4] color;
}

alias PFN_vkDebugMarkerSetObjectTagEXT = fn VkResult(
  VkDevice device, 
  VkDebugMarkerObjectTagInfoEXT * pTagInfo);

alias PFN_vkDebugMarkerSetObjectNameEXT = fn VkResult(
  VkDevice device, 
  VkDebugMarkerObjectNameInfoEXT * pNameInfo);

alias PFN_vkCmdDebugMarkerBeginEXT = fn void(
  VkCommandBuffer commandBuffer, 
  VkDebugMarkerMarkerInfoEXT * pMarkerInfo);

alias PFN_vkCmdDebugMarkerEndEXT = fn void(  VkCommandBuffer commandBuffer);

alias PFN_vkCmdDebugMarkerInsertEXT = fn void(
  VkCommandBuffer commandBuffer, 
  VkDebugMarkerMarkerInfoEXT * pMarkerInfo);

fn VkResult debugMarkerSetObjectTagEXT(
  VkDevice device, 
  VkDebugMarkerObjectTagInfoEXT * pTagInfo)
@extern("vkDebugMarkerSetObjectTagEXT");

fn VkResult debugMarkerSetObjectNameEXT(
  VkDevice device, 
  VkDebugMarkerObjectNameInfoEXT * pNameInfo)
@extern("vkDebugMarkerSetObjectNameEXT");

fn void cmdDebugMarkerBeginEXT(
  VkCommandBuffer commandBuffer, 
  VkDebugMarkerMarkerInfoEXT * pMarkerInfo)
@extern("vkCmdDebugMarkerBeginEXT");

fn void cmdDebugMarkerEndEXT(
  VkCommandBuffer commandBuffer)
@extern("vkCmdDebugMarkerEndEXT");

fn void cmdDebugMarkerInsertEXT(
  VkCommandBuffer commandBuffer, 
  VkDebugMarkerMarkerInfoEXT * pMarkerInfo)
@extern("vkCmdDebugMarkerInsertEXT");

struct VkDedicatedAllocationImageCreateInfoNV {
  VkStructureType sType;
  void * pNext;
  VkBool32 dedicatedAllocation;
}

struct VkDedicatedAllocationBufferCreateInfoNV {
  VkStructureType sType;
  void * pNext;
  VkBool32 dedicatedAllocation;
}

struct VkDedicatedAllocationMemoryAllocateInfoNV {
  VkStructureType sType;
  void * pNext;
  VkImage image;
  VkBuffer buffer;
}

alias VkPipelineRasterizationStateStreamCreateFlagsEXT = VkFlags;

struct VkPhysicalDeviceTransformFeedbackFeaturesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 transformFeedback;
  VkBool32 geometryStreams;
}

struct VkPhysicalDeviceTransformFeedbackPropertiesEXT {
  VkStructureType sType;
  void * pNext;
  uint maxTransformFeedbackStreams;
  uint maxTransformFeedbackBuffers;
  VkDeviceSize maxTransformFeedbackBufferSize;
  uint maxTransformFeedbackStreamDataSize;
  uint maxTransformFeedbackBufferDataSize;
  uint maxTransformFeedbackBufferDataStride;
  VkBool32 transformFeedbackQueries;
  VkBool32 transformFeedbackStreamsLinesTriangles;
  VkBool32 transformFeedbackRasterizationStreamSelect;
  VkBool32 transformFeedbackDraw;
}

struct VkPipelineRasterizationStateStreamCreateInfoEXT {
  VkStructureType sType;
  void * pNext;
  VkPipelineRasterizationStateStreamCreateFlagsEXT flags;
  uint rasterizationStream;
}

alias PFN_vkCmdBindTransformFeedbackBuffersEXT = fn void(
  VkCommandBuffer commandBuffer, 
  uint firstBinding, 
  uint bindingCount, 
  VkBuffer * pBuffers, 
  VkDeviceSize * pOffsets, 
  VkDeviceSize * pSizes);

alias PFN_vkCmdBeginTransformFeedbackEXT = fn void(
  VkCommandBuffer commandBuffer, 
  uint firstCounterBuffer, 
  uint counterBufferCount, 
  VkBuffer * pCounterBuffers, 
  VkDeviceSize * pCounterBufferOffsets);

alias PFN_vkCmdEndTransformFeedbackEXT = fn void(
  VkCommandBuffer commandBuffer, 
  uint firstCounterBuffer, 
  uint counterBufferCount, 
  VkBuffer * pCounterBuffers, 
  VkDeviceSize * pCounterBufferOffsets);

alias PFN_vkCmdBeginQueryIndexedEXT = fn void(
  VkCommandBuffer commandBuffer, 
  VkQueryPool queryPool, 
  uint query, 
  VkQueryControlFlags flags, 
  uint index);

alias PFN_vkCmdEndQueryIndexedEXT = fn void(
  VkCommandBuffer commandBuffer, 
  VkQueryPool queryPool, 
  uint query, 
  uint index);

alias PFN_vkCmdDrawIndirectByteCountEXT = fn void(
  VkCommandBuffer commandBuffer, 
  uint instanceCount, 
  uint firstInstance, 
  VkBuffer counterBuffer, 
  VkDeviceSize counterBufferOffset, 
  uint counterOffset, 
  uint vertexStride);

fn void cmdBindTransformFeedbackBuffersEXT(
  VkCommandBuffer commandBuffer, 
  uint firstBinding, 
  uint bindingCount, 
  VkBuffer * pBuffers, 
  VkDeviceSize * pOffsets, 
  VkDeviceSize * pSizes)
@extern("vkCmdBindTransformFeedbackBuffersEXT");

fn void cmdBeginTransformFeedbackEXT(
  VkCommandBuffer commandBuffer, 
  uint firstCounterBuffer, 
  uint counterBufferCount, 
  VkBuffer * pCounterBuffers, 
  VkDeviceSize * pCounterBufferOffsets)
@extern("vkCmdBeginTransformFeedbackEXT");

fn void cmdEndTransformFeedbackEXT(
  VkCommandBuffer commandBuffer, 
  uint firstCounterBuffer, 
  uint counterBufferCount, 
  VkBuffer * pCounterBuffers, 
  VkDeviceSize * pCounterBufferOffsets)
@extern("vkCmdEndTransformFeedbackEXT");

fn void cmdBeginQueryIndexedEXT(
  VkCommandBuffer commandBuffer, 
  VkQueryPool queryPool, 
  uint query, 
  VkQueryControlFlags flags, 
  uint index)
@extern("vkCmdBeginQueryIndexedEXT");

fn void cmdEndQueryIndexedEXT(
  VkCommandBuffer commandBuffer, 
  VkQueryPool queryPool, 
  uint query, 
  uint index)
@extern("vkCmdEndQueryIndexedEXT");

fn void cmdDrawIndirectByteCountEXT(
  VkCommandBuffer commandBuffer, 
  uint instanceCount, 
  uint firstInstance, 
  VkBuffer counterBuffer, 
  VkDeviceSize counterBufferOffset, 
  uint counterOffset, 
  uint vertexStride)
@extern("vkCmdDrawIndirectByteCountEXT");

typedef VkCuModuleNVX_T = void;

alias VkCuModuleNVX = VkCuModuleNVX_T *;

typedef VkCuFunctionNVX_T = void;

alias VkCuFunctionNVX = VkCuFunctionNVX_T *;

struct VkCuModuleCreateInfoNVX {
  VkStructureType sType;
  void * pNext;
  usz dataSize;
  void * pData;
}

struct VkCuFunctionCreateInfoNVX {
  VkStructureType sType;
  void * pNext;
  VkCuModuleNVX mod;
  CChar * pName;
}

struct VkCuLaunchInfoNVX {
  VkStructureType sType;
  void * pNext;
  VkCuFunctionNVX function;
  uint gridDimX;
  uint gridDimY;
  uint gridDimZ;
  uint blockDimX;
  uint blockDimY;
  uint blockDimZ;
  uint sharedMemBytes;
  usz paramCount;
  void ** pParams;
  usz extraCount;
  void ** pExtras;
}

alias PFN_vkCreateCuModuleNVX = fn VkResult(
  VkDevice device, 
  VkCuModuleCreateInfoNVX * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkCuModuleNVX * pModule);

alias PFN_vkCreateCuFunctionNVX = fn VkResult(
  VkDevice device, 
  VkCuFunctionCreateInfoNVX * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkCuFunctionNVX * pFunction);

alias PFN_vkDestroyCuModuleNVX = fn void(
  VkDevice device, 
  VkCuModuleNVX mod, 
  VkAllocationCallbacks * pAllocator);

alias PFN_vkDestroyCuFunctionNVX = fn void(
  VkDevice device, 
  VkCuFunctionNVX function, 
  VkAllocationCallbacks * pAllocator);

alias PFN_vkCmdCuLaunchKernelNVX = fn void(
  VkCommandBuffer commandBuffer, 
  VkCuLaunchInfoNVX * pLaunchInfo);

fn VkResult createCuModuleNVX(
  VkDevice device, 
  VkCuModuleCreateInfoNVX * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkCuModuleNVX * pModule)
@extern("vkCreateCuModuleNVX");

fn VkResult createCuFunctionNVX(
  VkDevice device, 
  VkCuFunctionCreateInfoNVX * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkCuFunctionNVX * pFunction)
@extern("vkCreateCuFunctionNVX");

fn void destroyCuModuleNVX(
  VkDevice device, 
  VkCuModuleNVX mod, 
  VkAllocationCallbacks * pAllocator)
@extern("vkDestroyCuModuleNVX");

fn void destroyCuFunctionNVX(
  VkDevice device, 
  VkCuFunctionNVX function, 
  VkAllocationCallbacks * pAllocator)
@extern("vkDestroyCuFunctionNVX");

fn void cmdCuLaunchKernelNVX(
  VkCommandBuffer commandBuffer, 
  VkCuLaunchInfoNVX * pLaunchInfo)
@extern("vkCmdCuLaunchKernelNVX");

struct VkImageViewHandleInfoNVX {
  VkStructureType sType;
  void * pNext;
  VkImageView imageView;
  VkDescriptorType descriptorType;
  VkSampler sampler;
}

struct VkImageViewAddressPropertiesNVX {
  VkStructureType sType;
  void * pNext;
  VkDeviceAddress deviceAddress;
  VkDeviceSize size;
}

alias PFN_vkGetImageViewHandleNVX = fn uint(
  VkDevice device, 
  VkImageViewHandleInfoNVX * pInfo);

alias PFN_vkGetImageViewAddressNVX = fn VkResult(
  VkDevice device, 
  VkImageView imageView, 
  VkImageViewAddressPropertiesNVX * pProperties);

fn uint getImageViewHandleNVX(
  VkDevice device, 
  VkImageViewHandleInfoNVX * pInfo)
@extern("vkGetImageViewHandleNVX");

fn VkResult getImageViewAddressNVX(
  VkDevice device, 
  VkImageView imageView, 
  VkImageViewAddressPropertiesNVX * pProperties)
@extern("vkGetImageViewAddressNVX");

alias PFN_vkCmdDrawIndirectCountAMD = fn void(
  VkCommandBuffer commandBuffer, 
  VkBuffer buffer, 
  VkDeviceSize offset, 
  VkBuffer countBuffer, 
  VkDeviceSize countBufferOffset, 
  uint maxDrawCount, 
  uint stride);

alias PFN_vkCmdDrawIndexedIndirectCountAMD = fn void(
  VkCommandBuffer commandBuffer, 
  VkBuffer buffer, 
  VkDeviceSize offset, 
  VkBuffer countBuffer, 
  VkDeviceSize countBufferOffset, 
  uint maxDrawCount, 
  uint stride);

fn void cmdDrawIndirectCountAMD(
  VkCommandBuffer commandBuffer, 
  VkBuffer buffer, 
  VkDeviceSize offset, 
  VkBuffer countBuffer, 
  VkDeviceSize countBufferOffset, 
  uint maxDrawCount, 
  uint stride)
@extern("vkCmdDrawIndirectCountAMD");

fn void cmdDrawIndexedIndirectCountAMD(
  VkCommandBuffer commandBuffer, 
  VkBuffer buffer, 
  VkDeviceSize offset, 
  VkBuffer countBuffer, 
  VkDeviceSize countBufferOffset, 
  uint maxDrawCount, 
  uint stride)
@extern("vkCmdDrawIndexedIndirectCountAMD");

struct VkTextureLODGatherFormatPropertiesAMD {
  VkStructureType sType;
  void * pNext;
  VkBool32 supportsTextureGatherLODBiasAMD;
}

typedef VkShaderInfoTypeAMD = inline CUInt;
const VkShaderInfoTypeAMD SHADER_INFO_TYPE_STATISTICS_AMD = 0;
const VkShaderInfoTypeAMD SHADER_INFO_TYPE_BINARY_AMD = 1;
const VkShaderInfoTypeAMD SHADER_INFO_TYPE_DISASSEMBLY_AMD = 2;
const VkShaderInfoTypeAMD SHADER_INFO_TYPE_MAX_ENUM_AMD = 0x7FFFFFFF;

struct VkShaderResourceUsageAMD {
  uint numUsedVgprs;
  uint numUsedSgprs;
  uint ldsSizePerLocalWorkGroup;
  usz ldsUsageSizeInBytes;
  usz scratchMemUsageInBytes;
}

struct VkShaderStatisticsInfoAMD {
  VkShaderStageFlags shaderStageMask;
  VkShaderResourceUsageAMD resourceUsage;
  uint numPhysicalVgprs;
  uint numPhysicalSgprs;
  uint numAvailableVgprs;
  uint numAvailableSgprs;
  uint[3] computeWorkGroupSize;
}

alias PFN_vkGetShaderInfoAMD = fn VkResult(
  VkDevice device, 
  VkPipeline pipeline, 
  VkShaderStageFlagBits shaderStage, 
  VkShaderInfoTypeAMD infoType, 
  usz * pInfoSize, 
  void * pInfo);

fn VkResult getShaderInfoAMD(
  VkDevice device, 
  VkPipeline pipeline, 
  VkShaderStageFlagBits shaderStage, 
  VkShaderInfoTypeAMD infoType, 
  usz * pInfoSize, 
  void * pInfo)
@extern("vkGetShaderInfoAMD");

struct VkPhysicalDeviceCornerSampledImageFeaturesNV {
  VkStructureType sType;
  void * pNext;
  VkBool32 cornerSampledImage;
}

typedef VkExternalMemoryHandleTypeFlagBitsNV = inline CUInt;
const VkExternalMemoryHandleTypeFlagBitsNV EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV = 0x00000001;
const VkExternalMemoryHandleTypeFlagBitsNV EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV = 0x00000002;
const VkExternalMemoryHandleTypeFlagBitsNV EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV = 0x00000004;
const VkExternalMemoryHandleTypeFlagBitsNV EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV = 0x00000008;
const VkExternalMemoryHandleTypeFlagBitsNV EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF;

alias VkExternalMemoryHandleTypeFlagsNV = VkFlags;

typedef VkExternalMemoryFeatureFlagBitsNV = inline CUInt;
const VkExternalMemoryFeatureFlagBitsNV EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV = 0x00000001;
const VkExternalMemoryFeatureFlagBitsNV EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV = 0x00000002;
const VkExternalMemoryFeatureFlagBitsNV EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV = 0x00000004;
const VkExternalMemoryFeatureFlagBitsNV EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF;

alias VkExternalMemoryFeatureFlagsNV = VkFlags;

struct VkExternalImageFormatPropertiesNV {
  VkImageFormatProperties imageFormatProperties;
  VkExternalMemoryFeatureFlagsNV externalMemoryFeatures;
  VkExternalMemoryHandleTypeFlagsNV exportFromImportedHandleTypes;
  VkExternalMemoryHandleTypeFlagsNV compatibleHandleTypes;
}

alias PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV = fn VkResult(
  VkPhysicalDevice physicalDevice, 
  VkFormat format, 
  VkImageType type, 
  VkImageTiling tiling, 
  VkImageUsageFlags usage, 
  VkImageCreateFlags flags, 
  VkExternalMemoryHandleTypeFlagsNV externalHandleType, 
  VkExternalImageFormatPropertiesNV * pExternalImageFormatProperties);

fn VkResult getPhysicalDeviceExternalImageFormatPropertiesNV(
  VkPhysicalDevice physicalDevice, 
  VkFormat format, 
  VkImageType type, 
  VkImageTiling tiling, 
  VkImageUsageFlags usage, 
  VkImageCreateFlags flags, 
  VkExternalMemoryHandleTypeFlagsNV externalHandleType, 
  VkExternalImageFormatPropertiesNV * pExternalImageFormatProperties)
@extern("vkGetPhysicalDeviceExternalImageFormatPropertiesNV");

struct VkExternalMemoryImageCreateInfoNV {
  VkStructureType sType;
  void * pNext;
  VkExternalMemoryHandleTypeFlagsNV handleTypes;
}

struct VkExportMemoryAllocateInfoNV {
  VkStructureType sType;
  void * pNext;
  VkExternalMemoryHandleTypeFlagsNV handleTypes;
}

typedef VkValidationCheckEXT = inline CUInt;
const VkValidationCheckEXT VALIDATION_CHECK_ALL_EXT = 0;
const VkValidationCheckEXT VALIDATION_CHECK_SHADERS_EXT = 1;
const VkValidationCheckEXT VALIDATION_CHECK_MAX_ENUM_EXT = 0x7FFFFFFF;

struct VkValidationFlagsEXT {
  VkStructureType sType;
  void * pNext;
  uint disabledValidationCheckCount;
  VkValidationCheckEXT * pDisabledValidationChecks;
}

struct VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 textureCompressionASTC_HDR;
}

struct VkImageViewASTCDecodeModeEXT {
  VkStructureType sType;
  void * pNext;
  VkFormat decodeMode;
}

struct VkPhysicalDeviceASTCDecodeFeaturesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 decodeModeSharedExponent;
}

typedef VkConditionalRenderingFlagBitsEXT = inline CUInt;
const VkConditionalRenderingFlagBitsEXT CONDITIONAL_RENDERING_INVERTED_BIT_EXT = 0x00000001;
const VkConditionalRenderingFlagBitsEXT CONDITIONAL_RENDERING_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF;

alias VkConditionalRenderingFlagsEXT = VkFlags;

struct VkConditionalRenderingBeginInfoEXT {
  VkStructureType sType;
  void * pNext;
  VkBuffer buffer;
  VkDeviceSize offset;
  VkConditionalRenderingFlagsEXT flags;
}

struct VkPhysicalDeviceConditionalRenderingFeaturesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 conditionalRendering;
  VkBool32 inheritedConditionalRendering;
}

struct VkCommandBufferInheritanceConditionalRenderingInfoEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 conditionalRenderingEnable;
}

alias PFN_vkCmdBeginConditionalRenderingEXT = fn void(
  VkCommandBuffer commandBuffer, 
  VkConditionalRenderingBeginInfoEXT * pConditionalRenderingBegin);

alias PFN_vkCmdEndConditionalRenderingEXT = fn void(  VkCommandBuffer commandBuffer);

fn void cmdBeginConditionalRenderingEXT(
  VkCommandBuffer commandBuffer, 
  VkConditionalRenderingBeginInfoEXT * pConditionalRenderingBegin)
@extern("vkCmdBeginConditionalRenderingEXT");

fn void cmdEndConditionalRenderingEXT(
  VkCommandBuffer commandBuffer)
@extern("vkCmdEndConditionalRenderingEXT");

struct VkViewportWScalingNV {
  float xcoeff;
  float ycoeff;
}

struct VkPipelineViewportWScalingStateCreateInfoNV {
  VkStructureType sType;
  void * pNext;
  VkBool32 viewportWScalingEnable;
  uint viewportCount;
  VkViewportWScalingNV * pViewportWScalings;
}

alias PFN_vkCmdSetViewportWScalingNV = fn void(
  VkCommandBuffer commandBuffer, 
  uint firstViewport, 
  uint viewportCount, 
  VkViewportWScalingNV * pViewportWScalings);

fn void cmdSetViewportWScalingNV(
  VkCommandBuffer commandBuffer, 
  uint firstViewport, 
  uint viewportCount, 
  VkViewportWScalingNV * pViewportWScalings)
@extern("vkCmdSetViewportWScalingNV");

alias PFN_vkReleaseDisplayEXT = fn VkResult(
  VkPhysicalDevice physicalDevice, 
  VkDisplayKHR display);

fn VkResult releaseDisplayEXT(
  VkPhysicalDevice physicalDevice, 
  VkDisplayKHR display)
@extern("vkReleaseDisplayEXT");

typedef VkSurfaceCounterFlagBitsEXT = inline CUInt;
const VkSurfaceCounterFlagBitsEXT SURFACE_COUNTER_VBLANK_BIT_EXT = 0x00000001;
const VkSurfaceCounterFlagBitsEXT SURFACE_COUNTER_VBLANK_EXT = SURFACE_COUNTER_VBLANK_BIT_EXT;
const VkSurfaceCounterFlagBitsEXT SURFACE_COUNTER_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF;

alias VkSurfaceCounterFlagsEXT = VkFlags;

struct VkSurfaceCapabilities2EXT {
  VkStructureType sType;
  void * pNext;
  uint minImageCount;
  uint maxImageCount;
  VkExtent2D currentExtent;
  VkExtent2D minImageExtent;
  VkExtent2D maxImageExtent;
  uint maxImageArrayLayers;
  VkSurfaceTransformFlagsKHR supportedTransforms;
  VkSurfaceTransformFlagBitsKHR currentTransform;
  VkCompositeAlphaFlagsKHR supportedCompositeAlpha;
  VkImageUsageFlags supportedUsageFlags;
  VkSurfaceCounterFlagsEXT supportedSurfaceCounters;
}

alias PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT = fn VkResult(
  VkPhysicalDevice physicalDevice, 
  VkSurfaceKHR surface, 
  VkSurfaceCapabilities2EXT * pSurfaceCapabilities);

fn VkResult getPhysicalDeviceSurfaceCapabilities2EXT(
  VkPhysicalDevice physicalDevice, 
  VkSurfaceKHR surface, 
  VkSurfaceCapabilities2EXT * pSurfaceCapabilities)
@extern("vkGetPhysicalDeviceSurfaceCapabilities2EXT");

typedef VkDisplayPowerStateEXT = inline CUInt;
const VkDisplayPowerStateEXT DISPLAY_POWER_STATE_OFF_EXT = 0;
const VkDisplayPowerStateEXT DISPLAY_POWER_STATE_SUSPEND_EXT = 1;
const VkDisplayPowerStateEXT DISPLAY_POWER_STATE_ON_EXT = 2;
const VkDisplayPowerStateEXT DISPLAY_POWER_STATE_MAX_ENUM_EXT = 0x7FFFFFFF;

typedef VkDeviceEventTypeEXT = inline CUInt;
const VkDeviceEventTypeEXT DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT = 0;
const VkDeviceEventTypeEXT DEVICE_EVENT_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF;

typedef VkDisplayEventTypeEXT = inline CUInt;
const VkDisplayEventTypeEXT DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT = 0;
const VkDisplayEventTypeEXT DISPLAY_EVENT_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF;

struct VkDisplayPowerInfoEXT {
  VkStructureType sType;
  void * pNext;
  VkDisplayPowerStateEXT powerState;
}

struct VkDeviceEventInfoEXT {
  VkStructureType sType;
  void * pNext;
  VkDeviceEventTypeEXT deviceEvent;
}

struct VkDisplayEventInfoEXT {
  VkStructureType sType;
  void * pNext;
  VkDisplayEventTypeEXT displayEvent;
}

struct VkSwapchainCounterCreateInfoEXT {
  VkStructureType sType;
  void * pNext;
  VkSurfaceCounterFlagsEXT surfaceCounters;
}

alias PFN_vkDisplayPowerControlEXT = fn VkResult(
  VkDevice device, 
  VkDisplayKHR display, 
  VkDisplayPowerInfoEXT * pDisplayPowerInfo);

alias PFN_vkRegisterDeviceEventEXT = fn VkResult(
  VkDevice device, 
  VkDeviceEventInfoEXT * pDeviceEventInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkFence * pFence);

alias PFN_vkRegisterDisplayEventEXT = fn VkResult(
  VkDevice device, 
  VkDisplayKHR display, 
  VkDisplayEventInfoEXT * pDisplayEventInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkFence * pFence);

alias PFN_vkGetSwapchainCounterEXT = fn VkResult(
  VkDevice device, 
  VkSwapchainKHR swapchain, 
  VkSurfaceCounterFlagBitsEXT counter, 
  ulong * pCounterValue);

fn VkResult displayPowerControlEXT(
  VkDevice device, 
  VkDisplayKHR display, 
  VkDisplayPowerInfoEXT * pDisplayPowerInfo)
@extern("vkDisplayPowerControlEXT");

fn VkResult registerDeviceEventEXT(
  VkDevice device, 
  VkDeviceEventInfoEXT * pDeviceEventInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkFence * pFence)
@extern("vkRegisterDeviceEventEXT");

fn VkResult registerDisplayEventEXT(
  VkDevice device, 
  VkDisplayKHR display, 
  VkDisplayEventInfoEXT * pDisplayEventInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkFence * pFence)
@extern("vkRegisterDisplayEventEXT");

fn VkResult getSwapchainCounterEXT(
  VkDevice device, 
  VkSwapchainKHR swapchain, 
  VkSurfaceCounterFlagBitsEXT counter, 
  ulong * pCounterValue)
@extern("vkGetSwapchainCounterEXT");

struct VkRefreshCycleDurationGOOGLE {
  ulong refreshDuration;
}

struct VkPastPresentationTimingGOOGLE {
  uint presentID;
  ulong desiredPresentTime;
  ulong actualPresentTime;
  ulong earliestPresentTime;
  ulong presentMargin;
}

struct VkPresentTimeGOOGLE {
  uint presentID;
  ulong desiredPresentTime;
}

struct VkPresentTimesInfoGOOGLE {
  VkStructureType sType;
  void * pNext;
  uint swapchainCount;
  VkPresentTimeGOOGLE * pTimes;
}

alias PFN_vkGetRefreshCycleDurationGOOGLE = fn VkResult(
  VkDevice device, 
  VkSwapchainKHR swapchain, 
  VkRefreshCycleDurationGOOGLE * pDisplayTimingProperties);

alias PFN_vkGetPastPresentationTimingGOOGLE = fn VkResult(
  VkDevice device, 
  VkSwapchainKHR swapchain, 
  uint * pPresentationTimingCount, 
  VkPastPresentationTimingGOOGLE * pPresentationTimings);

fn VkResult getRefreshCycleDurationGOOGLE(
  VkDevice device, 
  VkSwapchainKHR swapchain, 
  VkRefreshCycleDurationGOOGLE * pDisplayTimingProperties)
@extern("vkGetRefreshCycleDurationGOOGLE");

fn VkResult getPastPresentationTimingGOOGLE(
  VkDevice device, 
  VkSwapchainKHR swapchain, 
  uint * pPresentationTimingCount, 
  VkPastPresentationTimingGOOGLE * pPresentationTimings)
@extern("vkGetPastPresentationTimingGOOGLE");

struct VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
  VkStructureType sType;
  void * pNext;
  VkBool32 perViewPositionAllComponents;
}

typedef VkViewportCoordinateSwizzleNV = inline CUInt;
const VkViewportCoordinateSwizzleNV VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV = 0;
const VkViewportCoordinateSwizzleNV VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV = 1;
const VkViewportCoordinateSwizzleNV VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV = 2;
const VkViewportCoordinateSwizzleNV VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV = 3;
const VkViewportCoordinateSwizzleNV VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV = 4;
const VkViewportCoordinateSwizzleNV VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV = 5;
const VkViewportCoordinateSwizzleNV VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV = 6;
const VkViewportCoordinateSwizzleNV VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV = 7;
const VkViewportCoordinateSwizzleNV VIEWPORT_COORDINATE_SWIZZLE_MAX_ENUM_NV = 0x7FFFFFFF;

alias VkPipelineViewportSwizzleStateCreateFlagsNV = VkFlags;

struct VkViewportSwizzleNV {
  VkViewportCoordinateSwizzleNV x;
  VkViewportCoordinateSwizzleNV y;
  VkViewportCoordinateSwizzleNV z;
  VkViewportCoordinateSwizzleNV w;
}

struct VkPipelineViewportSwizzleStateCreateInfoNV {
  VkStructureType sType;
  void * pNext;
  VkPipelineViewportSwizzleStateCreateFlagsNV flags;
  uint viewportCount;
  VkViewportSwizzleNV * pViewportSwizzles;
}

typedef VkDiscardRectangleModeEXT = inline CUInt;
const VkDiscardRectangleModeEXT DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT = 0;
const VkDiscardRectangleModeEXT DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT = 1;
const VkDiscardRectangleModeEXT DISCARD_RECTANGLE_MODE_MAX_ENUM_EXT = 0x7FFFFFFF;

alias VkPipelineDiscardRectangleStateCreateFlagsEXT = VkFlags;

struct VkPhysicalDeviceDiscardRectanglePropertiesEXT {
  VkStructureType sType;
  void * pNext;
  uint maxDiscardRectangles;
}

struct VkPipelineDiscardRectangleStateCreateInfoEXT {
  VkStructureType sType;
  void * pNext;
  VkPipelineDiscardRectangleStateCreateFlagsEXT flags;
  VkDiscardRectangleModeEXT discardRectangleMode;
  uint discardRectangleCount;
  VkRect2D * pDiscardRectangles;
}

alias PFN_vkCmdSetDiscardRectangleEXT = fn void(
  VkCommandBuffer commandBuffer, 
  uint firstDiscardRectangle, 
  uint discardRectangleCount, 
  VkRect2D * pDiscardRectangles);

fn void cmdSetDiscardRectangleEXT(
  VkCommandBuffer commandBuffer, 
  uint firstDiscardRectangle, 
  uint discardRectangleCount, 
  VkRect2D * pDiscardRectangles)
@extern("vkCmdSetDiscardRectangleEXT");

typedef VkConservativeRasterizationModeEXT = inline CUInt;
const VkConservativeRasterizationModeEXT CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT = 0;
const VkConservativeRasterizationModeEXT CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT = 1;
const VkConservativeRasterizationModeEXT CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT = 2;
const VkConservativeRasterizationModeEXT CONSERVATIVE_RASTERIZATION_MODE_MAX_ENUM_EXT = 0x7FFFFFFF;

alias VkPipelineRasterizationConservativeStateCreateFlagsEXT = VkFlags;

struct VkPhysicalDeviceConservativeRasterizationPropertiesEXT {
  VkStructureType sType;
  void * pNext;
  float primitiveOverestimationSize;
  float maxExtraPrimitiveOverestimationSize;
  float extraPrimitiveOverestimationSizeGranularity;
  VkBool32 primitiveUnderestimation;
  VkBool32 conservativePointAndLineRasterization;
  VkBool32 degenerateTrianglesRasterized;
  VkBool32 degenerateLinesRasterized;
  VkBool32 fullyCoveredFragmentShaderInputVariable;
  VkBool32 conservativeRasterizationPostDepthCoverage;
}

struct VkPipelineRasterizationConservativeStateCreateInfoEXT {
  VkStructureType sType;
  void * pNext;
  VkPipelineRasterizationConservativeStateCreateFlagsEXT flags;
  VkConservativeRasterizationModeEXT conservativeRasterizationMode;
  float extraPrimitiveOverestimationSize;
}

alias VkPipelineRasterizationDepthClipStateCreateFlagsEXT = VkFlags;

struct VkPhysicalDeviceDepthClipEnableFeaturesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 depthClipEnable;
}

struct VkPipelineRasterizationDepthClipStateCreateInfoEXT {
  VkStructureType sType;
  void * pNext;
  VkPipelineRasterizationDepthClipStateCreateFlagsEXT flags;
  VkBool32 depthClipEnable;
}

struct VkXYColorEXT {
  float x;
  float y;
}

struct VkHdrMetadataEXT {
  VkStructureType sType;
  void * pNext;
  VkXYColorEXT displayPrimaryRed;
  VkXYColorEXT displayPrimaryGreen;
  VkXYColorEXT displayPrimaryBlue;
  VkXYColorEXT whitePoint;
  float maxLuminance;
  float minLuminance;
  float maxContentLightLevel;
  float maxFrameAverageLightLevel;
}

alias PFN_vkSetHdrMetadataEXT = fn void(
  VkDevice device, 
  uint swapchainCount, 
  VkSwapchainKHR * pSwapchains, 
  VkHdrMetadataEXT * pMetadata);

fn void setHdrMetadataEXT(
  VkDevice device, 
  uint swapchainCount, 
  VkSwapchainKHR * pSwapchains, 
  VkHdrMetadataEXT * pMetadata)
@extern("vkSetHdrMetadataEXT");

typedef VkDebugUtilsMessengerEXT_T = void;

alias VkDebugUtilsMessengerEXT = VkDebugUtilsMessengerEXT_T *;

alias VkDebugUtilsMessengerCallbackDataFlagsEXT = VkFlags;

typedef VkDebugUtilsMessageSeverityFlagBitsEXT = inline CUInt;
const VkDebugUtilsMessageSeverityFlagBitsEXT DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT = 0x00000001;
const VkDebugUtilsMessageSeverityFlagBitsEXT DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT = 0x00000010;
const VkDebugUtilsMessageSeverityFlagBitsEXT DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT = 0x00000100;
const VkDebugUtilsMessageSeverityFlagBitsEXT DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT = 0x00001000;
const VkDebugUtilsMessageSeverityFlagBitsEXT DEBUG_UTILS_MESSAGE_SEVERITY_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF;

typedef VkDebugUtilsMessageTypeFlagBitsEXT = inline CUInt;
const VkDebugUtilsMessageTypeFlagBitsEXT DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT = 0x00000001;
const VkDebugUtilsMessageTypeFlagBitsEXT DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT = 0x00000002;
const VkDebugUtilsMessageTypeFlagBitsEXT DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT = 0x00000004;
const VkDebugUtilsMessageTypeFlagBitsEXT DEBUG_UTILS_MESSAGE_TYPE_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF;

alias VkDebugUtilsMessageTypeFlagsEXT = VkFlags;

alias VkDebugUtilsMessageSeverityFlagsEXT = VkFlags;

alias VkDebugUtilsMessengerCreateFlagsEXT = VkFlags;

struct VkDebugUtilsLabelEXT {
  VkStructureType sType;
  void * pNext;
  CChar * pLabelName;
  float[4] color;
}

struct VkDebugUtilsObjectNameInfoEXT {
  VkStructureType sType;
  void * pNext;
  VkObjectType objectType;
  ulong objectHandle;
  CChar * pObjectName;
}

struct VkDebugUtilsMessengerCallbackDataEXT {
  VkStructureType sType;
  void * pNext;
  VkDebugUtilsMessengerCallbackDataFlagsEXT flags;
  CChar * pMessageIdName;
  int messageIdNumber;
  CChar * pMessage;
  uint queueLabelCount;
  VkDebugUtilsLabelEXT * pQueueLabels;
  uint cmdBufLabelCount;
  VkDebugUtilsLabelEXT * pCmdBufLabels;
  uint objectCount;
  VkDebugUtilsObjectNameInfoEXT * pObjects;
}

alias PFN_vkDebugUtilsMessengerCallbackEXT = fn VkBool32(
  VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, 
  VkDebugUtilsMessageTypeFlagsEXT messageTypes, 
  VkDebugUtilsMessengerCallbackDataEXT * pCallbackData, 
  void * pUserData);

struct VkDebugUtilsMessengerCreateInfoEXT {
  VkStructureType sType;
  void * pNext;
  VkDebugUtilsMessengerCreateFlagsEXT flags;
  VkDebugUtilsMessageSeverityFlagsEXT messageSeverity;
  VkDebugUtilsMessageTypeFlagsEXT messageType;
  PFN_vkDebugUtilsMessengerCallbackEXT pfnUserCallback;
  void * pUserData;
}

struct VkDebugUtilsObjectTagInfoEXT {
  VkStructureType sType;
  void * pNext;
  VkObjectType objectType;
  ulong objectHandle;
  ulong tagName;
  usz tagSize;
  void * pTag;
}

alias PFN_vkSetDebugUtilsObjectNameEXT = fn VkResult(
  VkDevice device, 
  VkDebugUtilsObjectNameInfoEXT * pNameInfo);

alias PFN_vkSetDebugUtilsObjectTagEXT = fn VkResult(
  VkDevice device, 
  VkDebugUtilsObjectTagInfoEXT * pTagInfo);

alias PFN_vkQueueBeginDebugUtilsLabelEXT = fn void(
  VkQueue queue, 
  VkDebugUtilsLabelEXT * pLabelInfo);

alias PFN_vkQueueEndDebugUtilsLabelEXT = fn void(  VkQueue queue);

alias PFN_vkQueueInsertDebugUtilsLabelEXT = fn void(
  VkQueue queue, 
  VkDebugUtilsLabelEXT * pLabelInfo);

alias PFN_vkCmdBeginDebugUtilsLabelEXT = fn void(
  VkCommandBuffer commandBuffer, 
  VkDebugUtilsLabelEXT * pLabelInfo);

alias PFN_vkCmdEndDebugUtilsLabelEXT = fn void(  VkCommandBuffer commandBuffer);

alias PFN_vkCmdInsertDebugUtilsLabelEXT = fn void(
  VkCommandBuffer commandBuffer, 
  VkDebugUtilsLabelEXT * pLabelInfo);

alias PFN_vkCreateDebugUtilsMessengerEXT = fn VkResult(
  VkInstance instance, 
  VkDebugUtilsMessengerCreateInfoEXT * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkDebugUtilsMessengerEXT * pMessenger);

alias PFN_vkDestroyDebugUtilsMessengerEXT = fn void(
  VkInstance instance, 
  VkDebugUtilsMessengerEXT messenger, 
  VkAllocationCallbacks * pAllocator);

alias PFN_vkSubmitDebugUtilsMessageEXT = fn void(
  VkInstance instance, 
  VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, 
  VkDebugUtilsMessageTypeFlagsEXT messageTypes, 
  VkDebugUtilsMessengerCallbackDataEXT * pCallbackData);

fn VkResult setDebugUtilsObjectNameEXT(
  VkDevice device, 
  VkDebugUtilsObjectNameInfoEXT * pNameInfo)
@extern("vkSetDebugUtilsObjectNameEXT");

fn VkResult setDebugUtilsObjectTagEXT(
  VkDevice device, 
  VkDebugUtilsObjectTagInfoEXT * pTagInfo)
@extern("vkSetDebugUtilsObjectTagEXT");

fn void queueBeginDebugUtilsLabelEXT(
  VkQueue queue, 
  VkDebugUtilsLabelEXT * pLabelInfo)
@extern("vkQueueBeginDebugUtilsLabelEXT");

fn void queueEndDebugUtilsLabelEXT(
  VkQueue queue)
@extern("vkQueueEndDebugUtilsLabelEXT");

fn void queueInsertDebugUtilsLabelEXT(
  VkQueue queue, 
  VkDebugUtilsLabelEXT * pLabelInfo)
@extern("vkQueueInsertDebugUtilsLabelEXT");

fn void cmdBeginDebugUtilsLabelEXT(
  VkCommandBuffer commandBuffer, 
  VkDebugUtilsLabelEXT * pLabelInfo)
@extern("vkCmdBeginDebugUtilsLabelEXT");

fn void cmdEndDebugUtilsLabelEXT(
  VkCommandBuffer commandBuffer)
@extern("vkCmdEndDebugUtilsLabelEXT");

fn void cmdInsertDebugUtilsLabelEXT(
  VkCommandBuffer commandBuffer, 
  VkDebugUtilsLabelEXT * pLabelInfo)
@extern("vkCmdInsertDebugUtilsLabelEXT");

fn VkResult createDebugUtilsMessengerEXT(
  VkInstance instance, 
  VkDebugUtilsMessengerCreateInfoEXT * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkDebugUtilsMessengerEXT * pMessenger)
@extern("vkCreateDebugUtilsMessengerEXT");

fn void destroyDebugUtilsMessengerEXT(
  VkInstance instance, 
  VkDebugUtilsMessengerEXT messenger, 
  VkAllocationCallbacks * pAllocator)
@extern("vkDestroyDebugUtilsMessengerEXT");

fn void submitDebugUtilsMessageEXT(
  VkInstance instance, 
  VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, 
  VkDebugUtilsMessageTypeFlagsEXT messageTypes, 
  VkDebugUtilsMessengerCallbackDataEXT * pCallbackData)
@extern("vkSubmitDebugUtilsMessageEXT");

alias VkSamplerReductionModeEXT = VkSamplerReductionMode;

alias VkSamplerReductionModeCreateInfoEXT = VkSamplerReductionModeCreateInfo;

alias VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT = VkPhysicalDeviceSamplerFilterMinmaxProperties;

struct VkPhysicalDeviceInlineUniformBlockFeaturesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 inlineUniformBlock;
  VkBool32 descriptorBindingInlineUniformBlockUpdateAfterBind;
}

struct VkPhysicalDeviceInlineUniformBlockPropertiesEXT {
  VkStructureType sType;
  void * pNext;
  uint maxInlineUniformBlockSize;
  uint maxPerStageDescriptorInlineUniformBlocks;
  uint maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks;
  uint maxDescriptorSetInlineUniformBlocks;
  uint maxDescriptorSetUpdateAfterBindInlineUniformBlocks;
}

struct VkWriteDescriptorSetInlineUniformBlockEXT {
  VkStructureType sType;
  void * pNext;
  uint dataSize;
  void * pData;
}

struct VkDescriptorPoolInlineUniformBlockCreateInfoEXT {
  VkStructureType sType;
  void * pNext;
  uint maxInlineUniformBlockBindings;
}

struct VkSampleLocationEXT {
  float x;
  float y;
}

struct VkSampleLocationsInfoEXT {
  VkStructureType sType;
  void * pNext;
  VkSampleCountFlagBits sampleLocationsPerPixel;
  VkExtent2D sampleLocationGridSize;
  uint sampleLocationsCount;
  VkSampleLocationEXT * pSampleLocations;
}

struct VkAttachmentSampleLocationsEXT {
  uint attachmentIndex;
  VkSampleLocationsInfoEXT sampleLocationsInfo;
}

struct VkSubpassSampleLocationsEXT {
  uint subpassIndex;
  VkSampleLocationsInfoEXT sampleLocationsInfo;
}

struct VkRenderPassSampleLocationsBeginInfoEXT {
  VkStructureType sType;
  void * pNext;
  uint attachmentInitialSampleLocationsCount;
  VkAttachmentSampleLocationsEXT * pAttachmentInitialSampleLocations;
  uint postSubpassSampleLocationsCount;
  VkSubpassSampleLocationsEXT * pPostSubpassSampleLocations;
}

struct VkPipelineSampleLocationsStateCreateInfoEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 sampleLocationsEnable;
  VkSampleLocationsInfoEXT sampleLocationsInfo;
}

struct VkPhysicalDeviceSampleLocationsPropertiesEXT {
  VkStructureType sType;
  void * pNext;
  VkSampleCountFlags sampleLocationSampleCounts;
  VkExtent2D maxSampleLocationGridSize;
  float[2] sampleLocationCoordinateRange;
  uint sampleLocationSubPixelBits;
  VkBool32 variableSampleLocations;
}

struct VkMultisamplePropertiesEXT {
  VkStructureType sType;
  void * pNext;
  VkExtent2D maxSampleLocationGridSize;
}

alias PFN_vkCmdSetSampleLocationsEXT = fn void(
  VkCommandBuffer commandBuffer, 
  VkSampleLocationsInfoEXT * pSampleLocationsInfo);

alias PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT = fn void(
  VkPhysicalDevice physicalDevice, 
  VkSampleCountFlagBits samples, 
  VkMultisamplePropertiesEXT * pMultisampleProperties);

fn void cmdSetSampleLocationsEXT(
  VkCommandBuffer commandBuffer, 
  VkSampleLocationsInfoEXT * pSampleLocationsInfo)
@extern("vkCmdSetSampleLocationsEXT");

fn void getPhysicalDeviceMultisamplePropertiesEXT(
  VkPhysicalDevice physicalDevice, 
  VkSampleCountFlagBits samples, 
  VkMultisamplePropertiesEXT * pMultisampleProperties)
@extern("vkGetPhysicalDeviceMultisamplePropertiesEXT");

typedef VkBlendOverlapEXT = inline CUInt;
const VkBlendOverlapEXT BLEND_OVERLAP_UNCORRELATED_EXT = 0;
const VkBlendOverlapEXT BLEND_OVERLAP_DISJOINT_EXT = 1;
const VkBlendOverlapEXT BLEND_OVERLAP_CONJOINT_EXT = 2;
const VkBlendOverlapEXT BLEND_OVERLAP_MAX_ENUM_EXT = 0x7FFFFFFF;

struct VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 advancedBlendCoherentOperations;
}

struct VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT {
  VkStructureType sType;
  void * pNext;
  uint advancedBlendMaxColorAttachments;
  VkBool32 advancedBlendIndependentBlend;
  VkBool32 advancedBlendNonPremultipliedSrcColor;
  VkBool32 advancedBlendNonPremultipliedDstColor;
  VkBool32 advancedBlendCorrelatedOverlap;
  VkBool32 advancedBlendAllOperations;
}

struct VkPipelineColorBlendAdvancedStateCreateInfoEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 srcPremultiplied;
  VkBool32 dstPremultiplied;
  VkBlendOverlapEXT blendOverlap;
}

alias VkPipelineCoverageToColorStateCreateFlagsNV = VkFlags;

struct VkPipelineCoverageToColorStateCreateInfoNV {
  VkStructureType sType;
  void * pNext;
  VkPipelineCoverageToColorStateCreateFlagsNV flags;
  VkBool32 coverageToColorEnable;
  uint coverageToColorLocation;
}

typedef VkCoverageModulationModeNV = inline CUInt;
const VkCoverageModulationModeNV COVERAGE_MODULATION_MODE_NONE_NV = 0;
const VkCoverageModulationModeNV COVERAGE_MODULATION_MODE_RGB_NV = 1;
const VkCoverageModulationModeNV COVERAGE_MODULATION_MODE_ALPHA_NV = 2;
const VkCoverageModulationModeNV COVERAGE_MODULATION_MODE_RGBA_NV = 3;
const VkCoverageModulationModeNV COVERAGE_MODULATION_MODE_MAX_ENUM_NV = 0x7FFFFFFF;

alias VkPipelineCoverageModulationStateCreateFlagsNV = VkFlags;

struct VkPipelineCoverageModulationStateCreateInfoNV {
  VkStructureType sType;
  void * pNext;
  VkPipelineCoverageModulationStateCreateFlagsNV flags;
  VkCoverageModulationModeNV coverageModulationMode;
  VkBool32 coverageModulationTableEnable;
  uint coverageModulationTableCount;
  float * pCoverageModulationTable;
}

struct VkPhysicalDeviceShaderSMBuiltinsPropertiesNV {
  VkStructureType sType;
  void * pNext;
  uint shaderSMCount;
  uint shaderWarpsPerSM;
}

struct VkPhysicalDeviceShaderSMBuiltinsFeaturesNV {
  VkStructureType sType;
  void * pNext;
  VkBool32 shaderSMBuiltins;
}

struct VkDrmFormatModifierPropertiesEXT {
  ulong drmFormatModifier;
  uint drmFormatModifierPlaneCount;
  VkFormatFeatureFlags drmFormatModifierTilingFeatures;
}

struct VkDrmFormatModifierPropertiesListEXT {
  VkStructureType sType;
  void * pNext;
  uint drmFormatModifierCount;
  VkDrmFormatModifierPropertiesEXT * pDrmFormatModifierProperties;
}

struct VkPhysicalDeviceImageDrmFormatModifierInfoEXT {
  VkStructureType sType;
  void * pNext;
  ulong drmFormatModifier;
  VkSharingMode sharingMode;
  uint queueFamilyIndexCount;
  uint * pQueueFamilyIndices;
}

struct VkImageDrmFormatModifierListCreateInfoEXT {
  VkStructureType sType;
  void * pNext;
  uint drmFormatModifierCount;
  ulong * pDrmFormatModifiers;
}

struct VkImageDrmFormatModifierExplicitCreateInfoEXT {
  VkStructureType sType;
  void * pNext;
  ulong drmFormatModifier;
  uint drmFormatModifierPlaneCount;
  VkSubresourceLayout * pPlaneLayouts;
}

struct VkImageDrmFormatModifierPropertiesEXT {
  VkStructureType sType;
  void * pNext;
  ulong drmFormatModifier;
}

struct VkDrmFormatModifierProperties2EXT {
  ulong drmFormatModifier;
  uint drmFormatModifierPlaneCount;
  VkFormatFeatureFlags2KHR drmFormatModifierTilingFeatures;
}

struct VkDrmFormatModifierPropertiesList2EXT {
  VkStructureType sType;
  void * pNext;
  uint drmFormatModifierCount;
  VkDrmFormatModifierProperties2EXT * pDrmFormatModifierProperties;
}

alias PFN_vkGetImageDrmFormatModifierPropertiesEXT = fn VkResult(
  VkDevice device, 
  VkImage image, 
  VkImageDrmFormatModifierPropertiesEXT * pProperties);

fn VkResult getImageDrmFormatModifierPropertiesEXT(
  VkDevice device, 
  VkImage image, 
  VkImageDrmFormatModifierPropertiesEXT * pProperties)
@extern("vkGetImageDrmFormatModifierPropertiesEXT");

typedef VkValidationCacheEXT_T = void;

alias VkValidationCacheEXT = VkValidationCacheEXT_T *;

typedef VkValidationCacheHeaderVersionEXT = inline CUInt;
const VkValidationCacheHeaderVersionEXT VALIDATION_CACHE_HEADER_VERSION_ONE_EXT = 1;
const VkValidationCacheHeaderVersionEXT VALIDATION_CACHE_HEADER_VERSION_MAX_ENUM_EXT = 0x7FFFFFFF;

alias VkValidationCacheCreateFlagsEXT = VkFlags;

struct VkValidationCacheCreateInfoEXT {
  VkStructureType sType;
  void * pNext;
  VkValidationCacheCreateFlagsEXT flags;
  usz initialDataSize;
  void * pInitialData;
}

struct VkShaderModuleValidationCacheCreateInfoEXT {
  VkStructureType sType;
  void * pNext;
  VkValidationCacheEXT validationCache;
}

alias PFN_vkCreateValidationCacheEXT = fn VkResult(
  VkDevice device, 
  VkValidationCacheCreateInfoEXT * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkValidationCacheEXT * pValidationCache);

alias PFN_vkDestroyValidationCacheEXT = fn void(
  VkDevice device, 
  VkValidationCacheEXT validationCache, 
  VkAllocationCallbacks * pAllocator);

alias PFN_vkMergeValidationCachesEXT = fn VkResult(
  VkDevice device, 
  VkValidationCacheEXT dstCache, 
  uint srcCacheCount, 
  VkValidationCacheEXT * pSrcCaches);

alias PFN_vkGetValidationCacheDataEXT = fn VkResult(
  VkDevice device, 
  VkValidationCacheEXT validationCache, 
  usz * pDataSize, 
  void * pData);

fn VkResult createValidationCacheEXT(
  VkDevice device, 
  VkValidationCacheCreateInfoEXT * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkValidationCacheEXT * pValidationCache)
@extern("vkCreateValidationCacheEXT");

fn void destroyValidationCacheEXT(
  VkDevice device, 
  VkValidationCacheEXT validationCache, 
  VkAllocationCallbacks * pAllocator)
@extern("vkDestroyValidationCacheEXT");

fn VkResult mergeValidationCachesEXT(
  VkDevice device, 
  VkValidationCacheEXT dstCache, 
  uint srcCacheCount, 
  VkValidationCacheEXT * pSrcCaches)
@extern("vkMergeValidationCachesEXT");

fn VkResult getValidationCacheDataEXT(
  VkDevice device, 
  VkValidationCacheEXT validationCache, 
  usz * pDataSize, 
  void * pData)
@extern("vkGetValidationCacheDataEXT");

alias VkDescriptorBindingFlagBitsEXT = VkDescriptorBindingFlagBits;

alias VkDescriptorBindingFlagsEXT = VkDescriptorBindingFlags;

alias VkDescriptorSetLayoutBindingFlagsCreateInfoEXT = VkDescriptorSetLayoutBindingFlagsCreateInfo;

alias VkPhysicalDeviceDescriptorIndexingFeaturesEXT = VkPhysicalDeviceDescriptorIndexingFeatures;

alias VkPhysicalDeviceDescriptorIndexingPropertiesEXT = VkPhysicalDeviceDescriptorIndexingProperties;

alias VkDescriptorSetVariableDescriptorCountAllocateInfoEXT = VkDescriptorSetVariableDescriptorCountAllocateInfo;

alias VkDescriptorSetVariableDescriptorCountLayoutSupportEXT = VkDescriptorSetVariableDescriptorCountLayoutSupport;

typedef VkShadingRatePaletteEntryNV = inline CUInt;
const VkShadingRatePaletteEntryNV SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV = 0;
const VkShadingRatePaletteEntryNV SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV = 1;
const VkShadingRatePaletteEntryNV SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV = 2;
const VkShadingRatePaletteEntryNV SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV = 3;
const VkShadingRatePaletteEntryNV SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV = 4;
const VkShadingRatePaletteEntryNV SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV = 5;
const VkShadingRatePaletteEntryNV SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV = 6;
const VkShadingRatePaletteEntryNV SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV = 7;
const VkShadingRatePaletteEntryNV SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV = 8;
const VkShadingRatePaletteEntryNV SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV = 9;
const VkShadingRatePaletteEntryNV SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV = 10;
const VkShadingRatePaletteEntryNV SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV = 11;
const VkShadingRatePaletteEntryNV SHADING_RATE_PALETTE_ENTRY_MAX_ENUM_NV = 0x7FFFFFFF;

typedef VkCoarseSampleOrderTypeNV = inline CUInt;
const VkCoarseSampleOrderTypeNV COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV = 0;
const VkCoarseSampleOrderTypeNV COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV = 1;
const VkCoarseSampleOrderTypeNV COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV = 2;
const VkCoarseSampleOrderTypeNV COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV = 3;
const VkCoarseSampleOrderTypeNV COARSE_SAMPLE_ORDER_TYPE_MAX_ENUM_NV = 0x7FFFFFFF;

struct VkShadingRatePaletteNV {
  uint shadingRatePaletteEntryCount;
  VkShadingRatePaletteEntryNV * pShadingRatePaletteEntries;
}

struct VkPipelineViewportShadingRateImageStateCreateInfoNV {
  VkStructureType sType;
  void * pNext;
  VkBool32 shadingRateImageEnable;
  uint viewportCount;
  VkShadingRatePaletteNV * pShadingRatePalettes;
}

struct VkPhysicalDeviceShadingRateImageFeaturesNV {
  VkStructureType sType;
  void * pNext;
  VkBool32 shadingRateImage;
  VkBool32 shadingRateCoarseSampleOrder;
}

struct VkPhysicalDeviceShadingRateImagePropertiesNV {
  VkStructureType sType;
  void * pNext;
  VkExtent2D shadingRateTexelSize;
  uint shadingRatePaletteSize;
  uint shadingRateMaxCoarseSamples;
}

struct VkCoarseSampleLocationNV {
  uint pixelX;
  uint pixelY;
  uint sample;
}

struct VkCoarseSampleOrderCustomNV {
  VkShadingRatePaletteEntryNV shadingRate;
  uint sampleCount;
  uint sampleLocationCount;
  VkCoarseSampleLocationNV * pSampleLocations;
}

struct VkPipelineViewportCoarseSampleOrderStateCreateInfoNV {
  VkStructureType sType;
  void * pNext;
  VkCoarseSampleOrderTypeNV sampleOrderType;
  uint customSampleOrderCount;
  VkCoarseSampleOrderCustomNV * pCustomSampleOrders;
}

alias PFN_vkCmdBindShadingRateImageNV = fn void(
  VkCommandBuffer commandBuffer, 
  VkImageView imageView, 
  VkImageLayout imageLayout);

alias PFN_vkCmdSetViewportShadingRatePaletteNV = fn void(
  VkCommandBuffer commandBuffer, 
  uint firstViewport, 
  uint viewportCount, 
  VkShadingRatePaletteNV * pShadingRatePalettes);

alias PFN_vkCmdSetCoarseSampleOrderNV = fn void(
  VkCommandBuffer commandBuffer, 
  VkCoarseSampleOrderTypeNV sampleOrderType, 
  uint customSampleOrderCount, 
  VkCoarseSampleOrderCustomNV * pCustomSampleOrders);

fn void cmdBindShadingRateImageNV(
  VkCommandBuffer commandBuffer, 
  VkImageView imageView, 
  VkImageLayout imageLayout)
@extern("vkCmdBindShadingRateImageNV");

fn void cmdSetViewportShadingRatePaletteNV(
  VkCommandBuffer commandBuffer, 
  uint firstViewport, 
  uint viewportCount, 
  VkShadingRatePaletteNV * pShadingRatePalettes)
@extern("vkCmdSetViewportShadingRatePaletteNV");

fn void cmdSetCoarseSampleOrderNV(
  VkCommandBuffer commandBuffer, 
  VkCoarseSampleOrderTypeNV sampleOrderType, 
  uint customSampleOrderCount, 
  VkCoarseSampleOrderCustomNV * pCustomSampleOrders)
@extern("vkCmdSetCoarseSampleOrderNV");

typedef VkAccelerationStructureNV_T = void;

alias VkAccelerationStructureNV = VkAccelerationStructureNV_T *;

typedef VkRayTracingShaderGroupTypeKHR = inline CUInt;
const VkRayTracingShaderGroupTypeKHR RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR = 0;
const VkRayTracingShaderGroupTypeKHR RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR = 1;
const VkRayTracingShaderGroupTypeKHR RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR = 2;
const VkRayTracingShaderGroupTypeKHR RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV = RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR;
const VkRayTracingShaderGroupTypeKHR RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV = RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR;
const VkRayTracingShaderGroupTypeKHR RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV = RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR;
const VkRayTracingShaderGroupTypeKHR RAY_TRACING_SHADER_GROUP_TYPE_MAX_ENUM_KHR = 0x7FFFFFFF;

alias VkRayTracingShaderGroupTypeNV = VkRayTracingShaderGroupTypeKHR;

typedef VkGeometryTypeKHR = inline CUInt;
const VkGeometryTypeKHR GEOMETRY_TYPE_TRIANGLES_KHR = 0;
const VkGeometryTypeKHR GEOMETRY_TYPE_AABBS_KHR = 1;
const VkGeometryTypeKHR GEOMETRY_TYPE_INSTANCES_KHR = 2;
const VkGeometryTypeKHR GEOMETRY_TYPE_TRIANGLES_NV = GEOMETRY_TYPE_TRIANGLES_KHR;
const VkGeometryTypeKHR GEOMETRY_TYPE_AABBS_NV = GEOMETRY_TYPE_AABBS_KHR;
const VkGeometryTypeKHR GEOMETRY_TYPE_MAX_ENUM_KHR = 0x7FFFFFFF;

alias VkGeometryTypeNV = VkGeometryTypeKHR;

typedef VkAccelerationStructureTypeKHR = inline CUInt;
const VkAccelerationStructureTypeKHR ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR = 0;
const VkAccelerationStructureTypeKHR ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR = 1;
const VkAccelerationStructureTypeKHR ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR = 2;
const VkAccelerationStructureTypeKHR ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV = ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR;
const VkAccelerationStructureTypeKHR ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV = ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR;
const VkAccelerationStructureTypeKHR ACCELERATION_STRUCTURE_TYPE_MAX_ENUM_KHR = 0x7FFFFFFF;

alias VkAccelerationStructureTypeNV = VkAccelerationStructureTypeKHR;

typedef VkCopyAccelerationStructureModeKHR = inline CUInt;
const VkCopyAccelerationStructureModeKHR COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR = 0;
const VkCopyAccelerationStructureModeKHR COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR = 1;
const VkCopyAccelerationStructureModeKHR COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR = 2;
const VkCopyAccelerationStructureModeKHR COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR = 3;
const VkCopyAccelerationStructureModeKHR COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV = COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR;
const VkCopyAccelerationStructureModeKHR COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV = COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR;
const VkCopyAccelerationStructureModeKHR COPY_ACCELERATION_STRUCTURE_MODE_MAX_ENUM_KHR = 0x7FFFFFFF;

alias VkCopyAccelerationStructureModeNV = VkCopyAccelerationStructureModeKHR;

typedef VkAccelerationStructureMemoryRequirementsTypeNV = inline CUInt;
const VkAccelerationStructureMemoryRequirementsTypeNV ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV = 0;
const VkAccelerationStructureMemoryRequirementsTypeNV ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV = 1;
const VkAccelerationStructureMemoryRequirementsTypeNV ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV = 2;
const VkAccelerationStructureMemoryRequirementsTypeNV ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_MAX_ENUM_NV = 0x7FFFFFFF;

typedef VkGeometryFlagBitsKHR = inline CUInt;
const VkGeometryFlagBitsKHR GEOMETRY_OPAQUE_BIT_KHR = 0x00000001;
const VkGeometryFlagBitsKHR GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR = 0x00000002;
const VkGeometryFlagBitsKHR GEOMETRY_OPAQUE_BIT_NV = GEOMETRY_OPAQUE_BIT_KHR;
const VkGeometryFlagBitsKHR GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV = GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR;
const VkGeometryFlagBitsKHR GEOMETRY_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF;

alias VkGeometryFlagsKHR = VkFlags;

alias VkGeometryFlagsNV = VkGeometryFlagsKHR;

alias VkGeometryFlagBitsNV = VkGeometryFlagBitsKHR;

typedef VkGeometryInstanceFlagBitsKHR = inline CUInt;
const VkGeometryInstanceFlagBitsKHR GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR = 0x00000001;
const VkGeometryInstanceFlagBitsKHR GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR = 0x00000002;
const VkGeometryInstanceFlagBitsKHR GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR = 0x00000004;
const VkGeometryInstanceFlagBitsKHR GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR = 0x00000008;
const VkGeometryInstanceFlagBitsKHR GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR = GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR;
const VkGeometryInstanceFlagBitsKHR GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV = GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR;
const VkGeometryInstanceFlagBitsKHR GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV = GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR;
const VkGeometryInstanceFlagBitsKHR GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV = GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR;
const VkGeometryInstanceFlagBitsKHR GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV = GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR;
const VkGeometryInstanceFlagBitsKHR GEOMETRY_INSTANCE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF;

alias VkGeometryInstanceFlagsKHR = VkFlags;

alias VkGeometryInstanceFlagsNV = VkGeometryInstanceFlagsKHR;

alias VkGeometryInstanceFlagBitsNV = VkGeometryInstanceFlagBitsKHR;

typedef VkBuildAccelerationStructureFlagBitsKHR = inline CUInt;
const VkBuildAccelerationStructureFlagBitsKHR BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR = 0x00000001;
const VkBuildAccelerationStructureFlagBitsKHR BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR = 0x00000002;
const VkBuildAccelerationStructureFlagBitsKHR BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR = 0x00000004;
const VkBuildAccelerationStructureFlagBitsKHR BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR = 0x00000008;
const VkBuildAccelerationStructureFlagBitsKHR BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR = 0x00000010;
const VkBuildAccelerationStructureFlagBitsKHR BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV = 0x00000020;
const VkBuildAccelerationStructureFlagBitsKHR BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV = BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR;
const VkBuildAccelerationStructureFlagBitsKHR BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV = BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR;
const VkBuildAccelerationStructureFlagBitsKHR BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV = BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR;
const VkBuildAccelerationStructureFlagBitsKHR BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV = BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR;
const VkBuildAccelerationStructureFlagBitsKHR BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV = BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR;
const VkBuildAccelerationStructureFlagBitsKHR BUILD_ACCELERATION_STRUCTURE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF;

alias VkBuildAccelerationStructureFlagsKHR = VkFlags;

alias VkBuildAccelerationStructureFlagsNV = VkBuildAccelerationStructureFlagsKHR;

alias VkBuildAccelerationStructureFlagBitsNV = VkBuildAccelerationStructureFlagBitsKHR;

struct VkRayTracingShaderGroupCreateInfoNV {
  VkStructureType sType;
  void * pNext;
  VkRayTracingShaderGroupTypeKHR type;
  uint generalShader;
  uint closestHitShader;
  uint anyHitShader;
  uint intersectionShader;
}

struct VkRayTracingPipelineCreateInfoNV {
  VkStructureType sType;
  void * pNext;
  VkPipelineCreateFlags flags;
  uint stageCount;
  VkPipelineShaderStageCreateInfo * pStages;
  uint groupCount;
  VkRayTracingShaderGroupCreateInfoNV * pGroups;
  uint maxRecursionDepth;
  VkPipelineLayout layout;
  VkPipeline basePipelineHandle;
  int basePipelineIndex;
}

struct VkGeometryTrianglesNV {
  VkStructureType sType;
  void * pNext;
  VkBuffer vertexData;
  VkDeviceSize vertexOffset;
  uint vertexCount;
  VkDeviceSize vertexStride;
  VkFormat vertexFormat;
  VkBuffer indexData;
  VkDeviceSize indexOffset;
  uint indexCount;
  VkIndexType indexType;
  VkBuffer transformData;
  VkDeviceSize transformOffset;
}

struct VkGeometryAABBNV {
  VkStructureType sType;
  void * pNext;
  VkBuffer aabbData;
  uint numAABBs;
  uint stride;
  VkDeviceSize offset;
}

struct VkGeometryDataNV {
  VkGeometryTrianglesNV triangles;
  VkGeometryAABBNV aabbs;
}

struct VkGeometryNV {
  VkStructureType sType;
  void * pNext;
  VkGeometryTypeKHR geometryType;
  VkGeometryDataNV geometry;
  VkGeometryFlagsKHR flags;
}

struct VkAccelerationStructureInfoNV {
  VkStructureType sType;
  void * pNext;
  VkAccelerationStructureTypeNV type;
  VkBuildAccelerationStructureFlagsNV flags;
  uint instanceCount;
  uint geometryCount;
  VkGeometryNV * pGeometries;
}

struct VkAccelerationStructureCreateInfoNV {
  VkStructureType sType;
  void * pNext;
  VkDeviceSize compactedSize;
  VkAccelerationStructureInfoNV info;
}

struct VkBindAccelerationStructureMemoryInfoNV {
  VkStructureType sType;
  void * pNext;
  VkAccelerationStructureNV accelerationStructure;
  VkDeviceMemory memory;
  VkDeviceSize memoryOffset;
  uint deviceIndexCount;
  uint * pDeviceIndices;
}

struct VkWriteDescriptorSetAccelerationStructureNV {
  VkStructureType sType;
  void * pNext;
  uint accelerationStructureCount;
  VkAccelerationStructureNV * pAccelerationStructures;
}

struct VkAccelerationStructureMemoryRequirementsInfoNV {
  VkStructureType sType;
  void * pNext;
  VkAccelerationStructureMemoryRequirementsTypeNV type;
  VkAccelerationStructureNV accelerationStructure;
}

struct VkPhysicalDeviceRayTracingPropertiesNV {
  VkStructureType sType;
  void * pNext;
  uint shaderGroupHandleSize;
  uint maxRecursionDepth;
  uint maxShaderGroupStride;
  uint shaderGroupBaseAlignment;
  ulong maxGeometryCount;
  ulong maxInstanceCount;
  ulong maxTriangleCount;
  uint maxDescriptorSetAccelerationStructures;
}

struct VkTransformMatrixKHR {
  float[3][4] matrix;
}

alias VkTransformMatrixNV = VkTransformMatrixKHR;

struct VkAabbPositionsKHR {
  float minX;
  float minY;
  float minZ;
  float maxX;
  float maxY;
  float maxZ;
}

alias VkAabbPositionsNV = VkAabbPositionsKHR;

struct VkAccelerationStructureInstanceKHR {
  VkTransformMatrixKHR transform;
  bitstruct : ulong {
    uint instanceCustomIndex : 0..23;
    uint mask : 24..31;
    uint instanceShaderBindingTableRecordOffset : 32..55;
    VkGeometryInstanceFlagsKHR flags : 56..63;
  }
  ulong accelerationStructureReference;
}

alias VkAccelerationStructureInstanceNV = VkAccelerationStructureInstanceKHR;

alias PFN_vkCreateAccelerationStructureNV = fn VkResult(
  VkDevice device, 
  VkAccelerationStructureCreateInfoNV * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkAccelerationStructureNV * pAccelerationStructure);

alias PFN_vkDestroyAccelerationStructureNV = fn void(
  VkDevice device, 
  VkAccelerationStructureNV accelerationStructure, 
  VkAllocationCallbacks * pAllocator);

alias PFN_vkGetAccelerationStructureMemoryRequirementsNV = fn void(
  VkDevice device, 
  VkAccelerationStructureMemoryRequirementsInfoNV * pInfo, 
  VkMemoryRequirements2KHR * pMemoryRequirements);

alias PFN_vkBindAccelerationStructureMemoryNV = fn VkResult(
  VkDevice device, 
  uint bindInfoCount, 
  VkBindAccelerationStructureMemoryInfoNV * pBindInfos);

alias PFN_vkCmdBuildAccelerationStructureNV = fn void(
  VkCommandBuffer commandBuffer, 
  VkAccelerationStructureInfoNV * pInfo, 
  VkBuffer instanceData, 
  VkDeviceSize instanceOffset, 
  VkBool32 update, 
  VkAccelerationStructureNV dst, 
  VkAccelerationStructureNV src, 
  VkBuffer scratch, 
  VkDeviceSize scratchOffset);

alias PFN_vkCmdCopyAccelerationStructureNV = fn void(
  VkCommandBuffer commandBuffer, 
  VkAccelerationStructureNV dst, 
  VkAccelerationStructureNV src, 
  VkCopyAccelerationStructureModeKHR mode);

alias PFN_vkCmdTraceRaysNV = fn void(
  VkCommandBuffer commandBuffer, 
  VkBuffer raygenShaderBindingTableBuffer, 
  VkDeviceSize raygenShaderBindingOffset, 
  VkBuffer missShaderBindingTableBuffer, 
  VkDeviceSize missShaderBindingOffset, 
  VkDeviceSize missShaderBindingStride, 
  VkBuffer hitShaderBindingTableBuffer, 
  VkDeviceSize hitShaderBindingOffset, 
  VkDeviceSize hitShaderBindingStride, 
  VkBuffer callableShaderBindingTableBuffer, 
  VkDeviceSize callableShaderBindingOffset, 
  VkDeviceSize callableShaderBindingStride, 
  uint width, 
  uint height, 
  uint depth);

alias PFN_vkCreateRayTracingPipelinesNV = fn VkResult(
  VkDevice device, 
  VkPipelineCache pipelineCache, 
  uint createInfoCount, 
  VkRayTracingPipelineCreateInfoNV * pCreateInfos, 
  VkAllocationCallbacks * pAllocator, 
  VkPipeline * pPipelines);

alias PFN_vkGetRayTracingShaderGroupHandlesKHR = fn VkResult(
  VkDevice device, 
  VkPipeline pipeline, 
  uint firstGroup, 
  uint groupCount, 
  usz dataSize, 
  void * pData);

alias PFN_vkGetRayTracingShaderGroupHandlesNV = fn VkResult(
  VkDevice device, 
  VkPipeline pipeline, 
  uint firstGroup, 
  uint groupCount, 
  usz dataSize, 
  void * pData);

alias PFN_vkGetAccelerationStructureHandleNV = fn VkResult(
  VkDevice device, 
  VkAccelerationStructureNV accelerationStructure, 
  usz dataSize, 
  void * pData);

alias PFN_vkCmdWriteAccelerationStructuresPropertiesNV = fn void(
  VkCommandBuffer commandBuffer, 
  uint accelerationStructureCount, 
  VkAccelerationStructureNV * pAccelerationStructures, 
  VkQueryType queryType, 
  VkQueryPool queryPool, 
  uint firstQuery);

alias PFN_vkCompileDeferredNV = fn VkResult(
  VkDevice device, 
  VkPipeline pipeline, 
  uint shader);

fn VkResult createAccelerationStructureNV(
  VkDevice device, 
  VkAccelerationStructureCreateInfoNV * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkAccelerationStructureNV * pAccelerationStructure)
@extern("vkCreateAccelerationStructureNV");

fn void destroyAccelerationStructureNV(
  VkDevice device, 
  VkAccelerationStructureNV accelerationStructure, 
  VkAllocationCallbacks * pAllocator)
@extern("vkDestroyAccelerationStructureNV");

fn void getAccelerationStructureMemoryRequirementsNV(
  VkDevice device, 
  VkAccelerationStructureMemoryRequirementsInfoNV * pInfo, 
  VkMemoryRequirements2KHR * pMemoryRequirements)
@extern("vkGetAccelerationStructureMemoryRequirementsNV");

fn VkResult bindAccelerationStructureMemoryNV(
  VkDevice device, 
  uint bindInfoCount, 
  VkBindAccelerationStructureMemoryInfoNV * pBindInfos)
@extern("vkBindAccelerationStructureMemoryNV");

fn void cmdBuildAccelerationStructureNV(
  VkCommandBuffer commandBuffer, 
  VkAccelerationStructureInfoNV * pInfo, 
  VkBuffer instanceData, 
  VkDeviceSize instanceOffset, 
  VkBool32 update, 
  VkAccelerationStructureNV dst, 
  VkAccelerationStructureNV src, 
  VkBuffer scratch, 
  VkDeviceSize scratchOffset)
@extern("vkCmdBuildAccelerationStructureNV");

fn void cmdCopyAccelerationStructureNV(
  VkCommandBuffer commandBuffer, 
  VkAccelerationStructureNV dst, 
  VkAccelerationStructureNV src, 
  VkCopyAccelerationStructureModeKHR mode)
@extern("vkCmdCopyAccelerationStructureNV");

fn void cmdTraceRaysNV(
  VkCommandBuffer commandBuffer, 
  VkBuffer raygenShaderBindingTableBuffer, 
  VkDeviceSize raygenShaderBindingOffset, 
  VkBuffer missShaderBindingTableBuffer, 
  VkDeviceSize missShaderBindingOffset, 
  VkDeviceSize missShaderBindingStride, 
  VkBuffer hitShaderBindingTableBuffer, 
  VkDeviceSize hitShaderBindingOffset, 
  VkDeviceSize hitShaderBindingStride, 
  VkBuffer callableShaderBindingTableBuffer, 
  VkDeviceSize callableShaderBindingOffset, 
  VkDeviceSize callableShaderBindingStride, 
  uint width, 
  uint height, 
  uint depth)
@extern("vkCmdTraceRaysNV");

fn VkResult createRayTracingPipelinesNV(
  VkDevice device, 
  VkPipelineCache pipelineCache, 
  uint createInfoCount, 
  VkRayTracingPipelineCreateInfoNV * pCreateInfos, 
  VkAllocationCallbacks * pAllocator, 
  VkPipeline * pPipelines)
@extern("vkCreateRayTracingPipelinesNV");

fn VkResult getRayTracingShaderGroupHandlesKHR(
  VkDevice device, 
  VkPipeline pipeline, 
  uint firstGroup, 
  uint groupCount, 
  usz dataSize, 
  void * pData)
@extern("vkGetRayTracingShaderGroupHandlesKHR");

fn VkResult getRayTracingShaderGroupHandlesNV(
  VkDevice device, 
  VkPipeline pipeline, 
  uint firstGroup, 
  uint groupCount, 
  usz dataSize, 
  void * pData)
@extern("vkGetRayTracingShaderGroupHandlesNV");

fn VkResult getAccelerationStructureHandleNV(
  VkDevice device, 
  VkAccelerationStructureNV accelerationStructure, 
  usz dataSize, 
  void * pData)
@extern("vkGetAccelerationStructureHandleNV");

fn void cmdWriteAccelerationStructuresPropertiesNV(
  VkCommandBuffer commandBuffer, 
  uint accelerationStructureCount, 
  VkAccelerationStructureNV * pAccelerationStructures, 
  VkQueryType queryType, 
  VkQueryPool queryPool, 
  uint firstQuery)
@extern("vkCmdWriteAccelerationStructuresPropertiesNV");

fn VkResult compileDeferredNV(
  VkDevice device, 
  VkPipeline pipeline, 
  uint shader)
@extern("vkCompileDeferredNV");

struct VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV {
  VkStructureType sType;
  void * pNext;
  VkBool32 representativeFragmentTest;
}

struct VkPipelineRepresentativeFragmentTestStateCreateInfoNV {
  VkStructureType sType;
  void * pNext;
  VkBool32 representativeFragmentTestEnable;
}

struct VkPhysicalDeviceImageViewImageFormatInfoEXT {
  VkStructureType sType;
  void * pNext;
  VkImageViewType imageViewType;
}

struct VkFilterCubicImageViewImageFormatPropertiesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 filterCubic;
  VkBool32 filterCubicMinmax;
}

typedef VkQueueGlobalPriorityEXT = inline CUInt;
const VkQueueGlobalPriorityEXT QUEUE_GLOBAL_PRIORITY_LOW_EXT = 128;
const VkQueueGlobalPriorityEXT QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT = 256;
const VkQueueGlobalPriorityEXT QUEUE_GLOBAL_PRIORITY_HIGH_EXT = 512;
const VkQueueGlobalPriorityEXT QUEUE_GLOBAL_PRIORITY_REALTIME_EXT = 1024;
const VkQueueGlobalPriorityEXT QUEUE_GLOBAL_PRIORITY_MAX_ENUM_EXT = 0x7FFFFFFF;

struct VkDeviceQueueGlobalPriorityCreateInfoEXT {
  VkStructureType sType;
  void * pNext;
  VkQueueGlobalPriorityEXT globalPriority;
}

struct VkImportMemoryHostPointerInfoEXT {
  VkStructureType sType;
  void * pNext;
  VkExternalMemoryHandleTypeFlagBits handleType;
  void * pHostPointer;
}

struct VkMemoryHostPointerPropertiesEXT {
  VkStructureType sType;
  void * pNext;
  uint memoryTypeBits;
}

struct VkPhysicalDeviceExternalMemoryHostPropertiesEXT {
  VkStructureType sType;
  void * pNext;
  VkDeviceSize minImportedHostPointerAlignment;
}

alias PFN_vkGetMemoryHostPointerPropertiesEXT = fn VkResult(
  VkDevice device, 
  VkExternalMemoryHandleTypeFlagBits handleType, 
  void * pHostPointer, 
  VkMemoryHostPointerPropertiesEXT * pMemoryHostPointerProperties);

fn VkResult getMemoryHostPointerPropertiesEXT(
  VkDevice device, 
  VkExternalMemoryHandleTypeFlagBits handleType, 
  void * pHostPointer, 
  VkMemoryHostPointerPropertiesEXT * pMemoryHostPointerProperties)
@extern("vkGetMemoryHostPointerPropertiesEXT");

alias PFN_vkCmdWriteBufferMarkerAMD = fn void(
  VkCommandBuffer commandBuffer, 
  VkPipelineStageFlagBits pipelineStage, 
  VkBuffer dstBuffer, 
  VkDeviceSize dstOffset, 
  uint marker);

fn void cmdWriteBufferMarkerAMD(
  VkCommandBuffer commandBuffer, 
  VkPipelineStageFlagBits pipelineStage, 
  VkBuffer dstBuffer, 
  VkDeviceSize dstOffset, 
  uint marker)
@extern("vkCmdWriteBufferMarkerAMD");

typedef VkPipelineCompilerControlFlagBitsAMD = inline CUInt;
const VkPipelineCompilerControlFlagBitsAMD PIPELINE_COMPILER_CONTROL_FLAG_BITS_MAX_ENUM_AMD = 0x7FFFFFFF;

alias VkPipelineCompilerControlFlagsAMD = VkFlags;

struct VkPipelineCompilerControlCreateInfoAMD {
  VkStructureType sType;
  void * pNext;
  VkPipelineCompilerControlFlagsAMD compilerControlFlags;
}

typedef VkTimeDomainEXT = inline CUInt;
const VkTimeDomainEXT TIME_DOMAIN_DEVICE_EXT = 0;
const VkTimeDomainEXT TIME_DOMAIN_CLOCK_MONOTONIC_EXT = 1;
const VkTimeDomainEXT TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT = 2;
const VkTimeDomainEXT TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT = 3;
const VkTimeDomainEXT TIME_DOMAIN_MAX_ENUM_EXT = 0x7FFFFFFF;

struct VkCalibratedTimestampInfoEXT {
  VkStructureType sType;
  void * pNext;
  VkTimeDomainEXT timeDomain;
}

alias PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT = fn VkResult(
  VkPhysicalDevice physicalDevice, 
  uint * pTimeDomainCount, 
  VkTimeDomainEXT * pTimeDomains);

alias PFN_vkGetCalibratedTimestampsEXT = fn VkResult(
  VkDevice device, 
  uint timestampCount, 
  VkCalibratedTimestampInfoEXT * pTimestampInfos, 
  ulong * pTimestamps, 
  ulong * pMaxDeviation);

fn VkResult getPhysicalDeviceCalibrateableTimeDomainsEXT(
  VkPhysicalDevice physicalDevice, 
  uint * pTimeDomainCount, 
  VkTimeDomainEXT * pTimeDomains)
@extern("vkGetPhysicalDeviceCalibrateableTimeDomainsEXT");

fn VkResult getCalibratedTimestampsEXT(
  VkDevice device, 
  uint timestampCount, 
  VkCalibratedTimestampInfoEXT * pTimestampInfos, 
  ulong * pTimestamps, 
  ulong * pMaxDeviation)
@extern("vkGetCalibratedTimestampsEXT");

struct VkPhysicalDeviceShaderCorePropertiesAMD {
  VkStructureType sType;
  void * pNext;
  uint shaderEngineCount;
  uint shaderArraysPerEngineCount;
  uint computeUnitsPerShaderArray;
  uint simdPerComputeUnit;
  uint wavefrontsPerSimd;
  uint wavefrontSize;
  uint sgprsPerSimd;
  uint minSgprAllocation;
  uint maxSgprAllocation;
  uint sgprAllocationGranularity;
  uint vgprsPerSimd;
  uint minVgprAllocation;
  uint maxVgprAllocation;
  uint vgprAllocationGranularity;
}

typedef VkMemoryOverallocationBehaviorAMD = inline CUInt;
const VkMemoryOverallocationBehaviorAMD MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD = 0;
const VkMemoryOverallocationBehaviorAMD MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD = 1;
const VkMemoryOverallocationBehaviorAMD MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD = 2;
const VkMemoryOverallocationBehaviorAMD MEMORY_OVERALLOCATION_BEHAVIOR_MAX_ENUM_AMD = 0x7FFFFFFF;

struct VkDeviceMemoryOverallocationCreateInfoAMD {
  VkStructureType sType;
  void * pNext;
  VkMemoryOverallocationBehaviorAMD overallocationBehavior;
}

struct VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT {
  VkStructureType sType;
  void * pNext;
  uint maxVertexAttribDivisor;
}

struct VkVertexInputBindingDivisorDescriptionEXT {
  uint binding;
  uint divisor;
}

struct VkPipelineVertexInputDivisorStateCreateInfoEXT {
  VkStructureType sType;
  void * pNext;
  uint vertexBindingDivisorCount;
  VkVertexInputBindingDivisorDescriptionEXT * pVertexBindingDivisors;
}

struct VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 vertexAttributeInstanceRateDivisor;
  VkBool32 vertexAttributeInstanceRateZeroDivisor;
}

typedef VkPipelineCreationFeedbackFlagBitsEXT = inline CUInt;
const VkPipelineCreationFeedbackFlagBitsEXT PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT = 0x00000001;
const VkPipelineCreationFeedbackFlagBitsEXT PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT = 0x00000002;
const VkPipelineCreationFeedbackFlagBitsEXT PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT = 0x00000004;
const VkPipelineCreationFeedbackFlagBitsEXT PIPELINE_CREATION_FEEDBACK_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF;

alias VkPipelineCreationFeedbackFlagsEXT = VkFlags;

struct VkPipelineCreationFeedbackEXT {
  VkPipelineCreationFeedbackFlagsEXT flags;
  ulong duration;
}

struct VkPipelineCreationFeedbackCreateInfoEXT {
  VkStructureType sType;
  void * pNext;
  VkPipelineCreationFeedbackEXT * pPipelineCreationFeedback;
  uint pipelineStageCreationFeedbackCount;
  VkPipelineCreationFeedbackEXT * pPipelineStageCreationFeedbacks;
}

struct VkPhysicalDeviceComputeShaderDerivativesFeaturesNV {
  VkStructureType sType;
  void * pNext;
  VkBool32 computeDerivativeGroupQuads;
  VkBool32 computeDerivativeGroupLinear;
}

struct VkPhysicalDeviceMeshShaderFeaturesNV {
  VkStructureType sType;
  void * pNext;
  VkBool32 taskShader;
  VkBool32 meshShader;
}

struct VkPhysicalDeviceMeshShaderPropertiesNV {
  VkStructureType sType;
  void * pNext;
  uint maxDrawMeshTasksCount;
  uint maxTaskWorkGroupInvocations;
  uint[3] maxTaskWorkGroupSize;
  uint maxTaskTotalMemorySize;
  uint maxTaskOutputCount;
  uint maxMeshWorkGroupInvocations;
  uint[3] maxMeshWorkGroupSize;
  uint maxMeshTotalMemorySize;
  uint maxMeshOutputVertices;
  uint maxMeshOutputPrimitives;
  uint maxMeshMultiviewViewCount;
  uint meshOutputPerVertexGranularity;
  uint meshOutputPerPrimitiveGranularity;
}

struct VkDrawMeshTasksIndirectCommandNV {
  uint taskCount;
  uint firstTask;
}

alias PFN_vkCmdDrawMeshTasksNV = fn void(
  VkCommandBuffer commandBuffer, 
  uint taskCount, 
  uint firstTask);

alias PFN_vkCmdDrawMeshTasksIndirectNV = fn void(
  VkCommandBuffer commandBuffer, 
  VkBuffer buffer, 
  VkDeviceSize offset, 
  uint drawCount, 
  uint stride);

alias PFN_vkCmdDrawMeshTasksIndirectCountNV = fn void(
  VkCommandBuffer commandBuffer, 
  VkBuffer buffer, 
  VkDeviceSize offset, 
  VkBuffer countBuffer, 
  VkDeviceSize countBufferOffset, 
  uint maxDrawCount, 
  uint stride);

fn void cmdDrawMeshTasksNV(
  VkCommandBuffer commandBuffer, 
  uint taskCount, 
  uint firstTask)
@extern("vkCmdDrawMeshTasksNV");

fn void cmdDrawMeshTasksIndirectNV(
  VkCommandBuffer commandBuffer, 
  VkBuffer buffer, 
  VkDeviceSize offset, 
  uint drawCount, 
  uint stride)
@extern("vkCmdDrawMeshTasksIndirectNV");

fn void cmdDrawMeshTasksIndirectCountNV(
  VkCommandBuffer commandBuffer, 
  VkBuffer buffer, 
  VkDeviceSize offset, 
  VkBuffer countBuffer, 
  VkDeviceSize countBufferOffset, 
  uint maxDrawCount, 
  uint stride)
@extern("vkCmdDrawMeshTasksIndirectCountNV");

struct VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV {
  VkStructureType sType;
  void * pNext;
  VkBool32 fragmentShaderBarycentric;
}

struct VkPhysicalDeviceShaderImageFootprintFeaturesNV {
  VkStructureType sType;
  void * pNext;
  VkBool32 imageFootprint;
}

struct VkPipelineViewportExclusiveScissorStateCreateInfoNV {
  VkStructureType sType;
  void * pNext;
  uint exclusiveScissorCount;
  VkRect2D * pExclusiveScissors;
}

struct VkPhysicalDeviceExclusiveScissorFeaturesNV {
  VkStructureType sType;
  void * pNext;
  VkBool32 exclusiveScissor;
}

alias PFN_vkCmdSetExclusiveScissorNV = fn void(
  VkCommandBuffer commandBuffer, 
  uint firstExclusiveScissor, 
  uint exclusiveScissorCount, 
  VkRect2D * pExclusiveScissors);

fn void cmdSetExclusiveScissorNV(
  VkCommandBuffer commandBuffer, 
  uint firstExclusiveScissor, 
  uint exclusiveScissorCount, 
  VkRect2D * pExclusiveScissors)
@extern("vkCmdSetExclusiveScissorNV");

struct VkQueueFamilyCheckpointPropertiesNV {
  VkStructureType sType;
  void * pNext;
  VkPipelineStageFlags checkpointExecutionStageMask;
}

struct VkCheckpointDataNV {
  VkStructureType sType;
  void * pNext;
  VkPipelineStageFlagBits stage;
  void * pCheckpointMarker;
}

alias PFN_vkCmdSetCheckpointNV = fn void(
  VkCommandBuffer commandBuffer, 
  void * pCheckpointMarker);

alias PFN_vkGetQueueCheckpointDataNV = fn void(
  VkQueue queue, 
  uint * pCheckpointDataCount, 
  VkCheckpointDataNV * pCheckpointData);

fn void cmdSetCheckpointNV(
  VkCommandBuffer commandBuffer, 
  void * pCheckpointMarker)
@extern("vkCmdSetCheckpointNV");

fn void getQueueCheckpointDataNV(
  VkQueue queue, 
  uint * pCheckpointDataCount, 
  VkCheckpointDataNV * pCheckpointData)
@extern("vkGetQueueCheckpointDataNV");

struct VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL {
  VkStructureType sType;
  void * pNext;
  VkBool32 shaderIntegerFunctions2;
}

typedef VkPerformanceConfigurationINTEL_T = void;

alias VkPerformanceConfigurationINTEL = VkPerformanceConfigurationINTEL_T *;

typedef VkPerformanceConfigurationTypeINTEL = inline CUInt;
const VkPerformanceConfigurationTypeINTEL PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL = 0;
const VkPerformanceConfigurationTypeINTEL PERFORMANCE_CONFIGURATION_TYPE_MAX_ENUM_INTEL = 0x7FFFFFFF;

typedef VkQueryPoolSamplingModeINTEL = inline CUInt;
const VkQueryPoolSamplingModeINTEL QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL = 0;
const VkQueryPoolSamplingModeINTEL QUERY_POOL_SAMPLING_MODE_MAX_ENUM_INTEL = 0x7FFFFFFF;

typedef VkPerformanceOverrideTypeINTEL = inline CUInt;
const VkPerformanceOverrideTypeINTEL PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL = 0;
const VkPerformanceOverrideTypeINTEL PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL = 1;
const VkPerformanceOverrideTypeINTEL PERFORMANCE_OVERRIDE_TYPE_MAX_ENUM_INTEL = 0x7FFFFFFF;

typedef VkPerformanceParameterTypeINTEL = inline CUInt;
const VkPerformanceParameterTypeINTEL PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL = 0;
const VkPerformanceParameterTypeINTEL PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL = 1;
const VkPerformanceParameterTypeINTEL PERFORMANCE_PARAMETER_TYPE_MAX_ENUM_INTEL = 0x7FFFFFFF;

typedef VkPerformanceValueTypeINTEL = inline CUInt;
const VkPerformanceValueTypeINTEL PERFORMANCE_VALUE_TYPE_UINT32_INTEL = 0;
const VkPerformanceValueTypeINTEL PERFORMANCE_VALUE_TYPE_UINT64_INTEL = 1;
const VkPerformanceValueTypeINTEL PERFORMANCE_VALUE_TYPE_FLOAT_INTEL = 2;
const VkPerformanceValueTypeINTEL PERFORMANCE_VALUE_TYPE_BOOL_INTEL = 3;
const VkPerformanceValueTypeINTEL PERFORMANCE_VALUE_TYPE_STRING_INTEL = 4;
const VkPerformanceValueTypeINTEL PERFORMANCE_VALUE_TYPE_MAX_ENUM_INTEL = 0x7FFFFFFF;

union VkPerformanceValueDataINTEL {
  uint value32;
  ulong value64;
  float valueFloat;
  VkBool32 valueBool;
  CChar * valueString;
}

struct VkPerformanceValueINTEL {
  VkPerformanceValueTypeINTEL type;
  VkPerformanceValueDataINTEL data;
}

struct VkInitializePerformanceApiInfoINTEL {
  VkStructureType sType;
  void * pNext;
  void * pUserData;
}

struct VkQueryPoolPerformanceQueryCreateInfoINTEL {
  VkStructureType sType;
  void * pNext;
  VkQueryPoolSamplingModeINTEL performanceCountersSampling;
}

alias VkQueryPoolCreateInfoINTEL = VkQueryPoolPerformanceQueryCreateInfoINTEL;

struct VkPerformanceMarkerInfoINTEL {
  VkStructureType sType;
  void * pNext;
  ulong marker;
}

struct VkPerformanceStreamMarkerInfoINTEL {
  VkStructureType sType;
  void * pNext;
  uint marker;
}

struct VkPerformanceOverrideInfoINTEL {
  VkStructureType sType;
  void * pNext;
  VkPerformanceOverrideTypeINTEL type;
  VkBool32 enable;
  ulong parameter;
}

struct VkPerformanceConfigurationAcquireInfoINTEL {
  VkStructureType sType;
  void * pNext;
  VkPerformanceConfigurationTypeINTEL type;
}

alias PFN_vkInitializePerformanceApiINTEL = fn VkResult(
  VkDevice device, 
  VkInitializePerformanceApiInfoINTEL * pInitializeInfo);

alias PFN_vkUninitializePerformanceApiINTEL = fn void(  VkDevice device);

alias PFN_vkCmdSetPerformanceMarkerINTEL = fn VkResult(
  VkCommandBuffer commandBuffer, 
  VkPerformanceMarkerInfoINTEL * pMarkerInfo);

alias PFN_vkCmdSetPerformanceStreamMarkerINTEL = fn VkResult(
  VkCommandBuffer commandBuffer, 
  VkPerformanceStreamMarkerInfoINTEL * pMarkerInfo);

alias PFN_vkCmdSetPerformanceOverrideINTEL = fn VkResult(
  VkCommandBuffer commandBuffer, 
  VkPerformanceOverrideInfoINTEL * pOverrideInfo);

alias PFN_vkAcquirePerformanceConfigurationINTEL = fn VkResult(
  VkDevice device, 
  VkPerformanceConfigurationAcquireInfoINTEL * pAcquireInfo, 
  VkPerformanceConfigurationINTEL * pConfiguration);

alias PFN_vkReleasePerformanceConfigurationINTEL = fn VkResult(
  VkDevice device, 
  VkPerformanceConfigurationINTEL configuration);

alias PFN_vkQueueSetPerformanceConfigurationINTEL = fn VkResult(
  VkQueue queue, 
  VkPerformanceConfigurationINTEL configuration);

alias PFN_vkGetPerformanceParameterINTEL = fn VkResult(
  VkDevice device, 
  VkPerformanceParameterTypeINTEL parameter, 
  VkPerformanceValueINTEL * pValue);

fn VkResult initializePerformanceApiINTEL(
  VkDevice device, 
  VkInitializePerformanceApiInfoINTEL * pInitializeInfo)
@extern("vkInitializePerformanceApiINTEL");

fn void uninitializePerformanceApiINTEL(
  VkDevice device)
@extern("vkUninitializePerformanceApiINTEL");

fn VkResult cmdSetPerformanceMarkerINTEL(
  VkCommandBuffer commandBuffer, 
  VkPerformanceMarkerInfoINTEL * pMarkerInfo)
@extern("vkCmdSetPerformanceMarkerINTEL");

fn VkResult cmdSetPerformanceStreamMarkerINTEL(
  VkCommandBuffer commandBuffer, 
  VkPerformanceStreamMarkerInfoINTEL * pMarkerInfo)
@extern("vkCmdSetPerformanceStreamMarkerINTEL");

fn VkResult cmdSetPerformanceOverrideINTEL(
  VkCommandBuffer commandBuffer, 
  VkPerformanceOverrideInfoINTEL * pOverrideInfo)
@extern("vkCmdSetPerformanceOverrideINTEL");

fn VkResult acquirePerformanceConfigurationINTEL(
  VkDevice device, 
  VkPerformanceConfigurationAcquireInfoINTEL * pAcquireInfo, 
  VkPerformanceConfigurationINTEL * pConfiguration)
@extern("vkAcquirePerformanceConfigurationINTEL");

fn VkResult releasePerformanceConfigurationINTEL(
  VkDevice device, 
  VkPerformanceConfigurationINTEL configuration)
@extern("vkReleasePerformanceConfigurationINTEL");

fn VkResult queueSetPerformanceConfigurationINTEL(
  VkQueue queue, 
  VkPerformanceConfigurationINTEL configuration)
@extern("vkQueueSetPerformanceConfigurationINTEL");

fn VkResult getPerformanceParameterINTEL(
  VkDevice device, 
  VkPerformanceParameterTypeINTEL parameter, 
  VkPerformanceValueINTEL * pValue)
@extern("vkGetPerformanceParameterINTEL");

struct VkPhysicalDevicePCIBusInfoPropertiesEXT {
  VkStructureType sType;
  void * pNext;
  uint pciDomain;
  uint pciBus;
  uint pciDevice;
  uint pciFunction;
}

struct VkDisplayNativeHdrSurfaceCapabilitiesAMD {
  VkStructureType sType;
  void * pNext;
  VkBool32 localDimmingSupport;
}

struct VkSwapchainDisplayNativeHdrCreateInfoAMD {
  VkStructureType sType;
  void * pNext;
  VkBool32 localDimmingEnable;
}

alias PFN_vkSetLocalDimmingAMD = fn void(
  VkDevice device, 
  VkSwapchainKHR swapChain, 
  VkBool32 localDimmingEnable);

fn void setLocalDimmingAMD(
  VkDevice device, 
  VkSwapchainKHR swapChain, 
  VkBool32 localDimmingEnable)
@extern("vkSetLocalDimmingAMD");

struct VkPhysicalDeviceFragmentDensityMapFeaturesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 fragmentDensityMap;
  VkBool32 fragmentDensityMapDynamic;
  VkBool32 fragmentDensityMapNonSubsampledImages;
}

struct VkPhysicalDeviceFragmentDensityMapPropertiesEXT {
  VkStructureType sType;
  void * pNext;
  VkExtent2D minFragmentDensityTexelSize;
  VkExtent2D maxFragmentDensityTexelSize;
  VkBool32 fragmentDensityInvocations;
}

struct VkRenderPassFragmentDensityMapCreateInfoEXT {
  VkStructureType sType;
  void * pNext;
  VkAttachmentReference fragmentDensityMapAttachment;
}

alias VkPhysicalDeviceScalarBlockLayoutFeaturesEXT = VkPhysicalDeviceScalarBlockLayoutFeatures;

struct VkPhysicalDeviceSubgroupSizeControlFeaturesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 subgroupSizeControl;
  VkBool32 computeFullSubgroups;
}

struct VkPhysicalDeviceSubgroupSizeControlPropertiesEXT {
  VkStructureType sType;
  void * pNext;
  uint minSubgroupSize;
  uint maxSubgroupSize;
  uint maxComputeWorkgroupSubgroups;
  VkShaderStageFlags requiredSubgroupSizeStages;
}

struct VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT {
  VkStructureType sType;
  void * pNext;
  uint requiredSubgroupSize;
}

typedef VkShaderCorePropertiesFlagBitsAMD = inline CUInt;
const VkShaderCorePropertiesFlagBitsAMD SHADER_CORE_PROPERTIES_FLAG_BITS_MAX_ENUM_AMD = 0x7FFFFFFF;

alias VkShaderCorePropertiesFlagsAMD = VkFlags;

struct VkPhysicalDeviceShaderCoreProperties2AMD {
  VkStructureType sType;
  void * pNext;
  VkShaderCorePropertiesFlagsAMD shaderCoreFeatures;
  uint activeComputeUnitCount;
}

struct VkPhysicalDeviceCoherentMemoryFeaturesAMD {
  VkStructureType sType;
  void * pNext;
  VkBool32 deviceCoherentMemory;
}

struct VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 shaderImageInt64Atomics;
  VkBool32 sparseImageInt64Atomics;
}

struct VkPhysicalDeviceMemoryBudgetPropertiesEXT {
  VkStructureType sType;
  void * pNext;
  VkDeviceSize[16] heapBudget;
  VkDeviceSize[16] heapUsage;
}

struct VkPhysicalDeviceMemoryPriorityFeaturesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 memoryPriority;
}

struct VkMemoryPriorityAllocateInfoEXT {
  VkStructureType sType;
  void * pNext;
  float priority;
}

struct VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV {
  VkStructureType sType;
  void * pNext;
  VkBool32 dedicatedAllocationImageAliasing;
}

struct VkPhysicalDeviceBufferDeviceAddressFeaturesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 bufferDeviceAddress;
  VkBool32 bufferDeviceAddressCaptureReplay;
  VkBool32 bufferDeviceAddressMultiDevice;
}

alias VkPhysicalDeviceBufferAddressFeaturesEXT = VkPhysicalDeviceBufferDeviceAddressFeaturesEXT;

alias VkBufferDeviceAddressInfoEXT = VkBufferDeviceAddressInfo;

struct VkBufferDeviceAddressCreateInfoEXT {
  VkStructureType sType;
  void * pNext;
  VkDeviceAddress deviceAddress;
}

alias PFN_vkGetBufferDeviceAddressEXT = fn VkDeviceAddress(
  VkDevice device, 
  VkBufferDeviceAddressInfo * pInfo);

fn VkDeviceAddress getBufferDeviceAddressEXT(
  VkDevice device, 
  VkBufferDeviceAddressInfo * pInfo)
@extern("vkGetBufferDeviceAddressEXT");

typedef VkToolPurposeFlagBitsEXT = inline CUInt;
const VkToolPurposeFlagBitsEXT TOOL_PURPOSE_VALIDATION_BIT_EXT = 0x00000001;
const VkToolPurposeFlagBitsEXT TOOL_PURPOSE_PROFILING_BIT_EXT = 0x00000002;
const VkToolPurposeFlagBitsEXT TOOL_PURPOSE_TRACING_BIT_EXT = 0x00000004;
const VkToolPurposeFlagBitsEXT TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT = 0x00000008;
const VkToolPurposeFlagBitsEXT TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT = 0x00000010;
const VkToolPurposeFlagBitsEXT TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT = 0x00000020;
const VkToolPurposeFlagBitsEXT TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT = 0x00000040;
const VkToolPurposeFlagBitsEXT TOOL_PURPOSE_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF;

alias VkToolPurposeFlagsEXT = VkFlags;

struct VkPhysicalDeviceToolPropertiesEXT {
  VkStructureType sType;
  void * pNext;
  CChar[256] name;
  CChar[256] version;
  VkToolPurposeFlagsEXT purposes;
  CChar[256] description;
  CChar[256] layer;
}

alias PFN_vkGetPhysicalDeviceToolPropertiesEXT = fn VkResult(
  VkPhysicalDevice physicalDevice, 
  uint * pToolCount, 
  VkPhysicalDeviceToolPropertiesEXT * pToolProperties);

fn VkResult getPhysicalDeviceToolPropertiesEXT(
  VkPhysicalDevice physicalDevice, 
  uint * pToolCount, 
  VkPhysicalDeviceToolPropertiesEXT * pToolProperties)
@extern("vkGetPhysicalDeviceToolPropertiesEXT");

alias VkImageStencilUsageCreateInfoEXT = VkImageStencilUsageCreateInfo;

typedef VkValidationFeatureEnableEXT = inline CUInt;
const VkValidationFeatureEnableEXT VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT = 0;
const VkValidationFeatureEnableEXT VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT = 1;
const VkValidationFeatureEnableEXT VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT = 2;
const VkValidationFeatureEnableEXT VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT = 3;
const VkValidationFeatureEnableEXT VALIDATION_FEATURE_ENABLE_SYNCHRONIZATION_VALIDATION_EXT = 4;
const VkValidationFeatureEnableEXT VALIDATION_FEATURE_ENABLE_MAX_ENUM_EXT = 0x7FFFFFFF;

typedef VkValidationFeatureDisableEXT = inline CUInt;
const VkValidationFeatureDisableEXT VALIDATION_FEATURE_DISABLE_ALL_EXT = 0;
const VkValidationFeatureDisableEXT VALIDATION_FEATURE_DISABLE_SHADERS_EXT = 1;
const VkValidationFeatureDisableEXT VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT = 2;
const VkValidationFeatureDisableEXT VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT = 3;
const VkValidationFeatureDisableEXT VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT = 4;
const VkValidationFeatureDisableEXT VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT = 5;
const VkValidationFeatureDisableEXT VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT = 6;
const VkValidationFeatureDisableEXT VALIDATION_FEATURE_DISABLE_SHADER_VALIDATION_CACHE_EXT = 7;
const VkValidationFeatureDisableEXT VALIDATION_FEATURE_DISABLE_MAX_ENUM_EXT = 0x7FFFFFFF;

struct VkValidationFeaturesEXT {
  VkStructureType sType;
  void * pNext;
  uint enabledValidationFeatureCount;
  VkValidationFeatureEnableEXT * pEnabledValidationFeatures;
  uint disabledValidationFeatureCount;
  VkValidationFeatureDisableEXT * pDisabledValidationFeatures;
}

typedef VkComponentTypeNV = inline CUInt;
const VkComponentTypeNV COMPONENT_TYPE_FLOAT16_NV = 0;
const VkComponentTypeNV COMPONENT_TYPE_FLOAT32_NV = 1;
const VkComponentTypeNV COMPONENT_TYPE_FLOAT64_NV = 2;
const VkComponentTypeNV COMPONENT_TYPE_SINT8_NV = 3;
const VkComponentTypeNV COMPONENT_TYPE_SINT16_NV = 4;
const VkComponentTypeNV COMPONENT_TYPE_SINT32_NV = 5;
const VkComponentTypeNV COMPONENT_TYPE_SINT64_NV = 6;
const VkComponentTypeNV COMPONENT_TYPE_UINT8_NV = 7;
const VkComponentTypeNV COMPONENT_TYPE_UINT16_NV = 8;
const VkComponentTypeNV COMPONENT_TYPE_UINT32_NV = 9;
const VkComponentTypeNV COMPONENT_TYPE_UINT64_NV = 10;
const VkComponentTypeNV COMPONENT_TYPE_MAX_ENUM_NV = 0x7FFFFFFF;

typedef VkScopeNV = inline CUInt;
const VkScopeNV SCOPE_DEVICE_NV = 1;
const VkScopeNV SCOPE_WORKGROUP_NV = 2;
const VkScopeNV SCOPE_SUBGROUP_NV = 3;
const VkScopeNV SCOPE_QUEUE_FAMILY_NV = 5;
const VkScopeNV SCOPE_MAX_ENUM_NV = 0x7FFFFFFF;

struct VkCooperativeMatrixPropertiesNV {
  VkStructureType sType;
  void * pNext;
  uint mSize;
  uint nSize;
  uint kSize;
  VkComponentTypeNV aType;
  VkComponentTypeNV bType;
  VkComponentTypeNV cType;
  VkComponentTypeNV dType;
  VkScopeNV scope;
}

struct VkPhysicalDeviceCooperativeMatrixFeaturesNV {
  VkStructureType sType;
  void * pNext;
  VkBool32 cooperativeMatrix;
  VkBool32 cooperativeMatrixRobustBufferAccess;
}

struct VkPhysicalDeviceCooperativeMatrixPropertiesNV {
  VkStructureType sType;
  void * pNext;
  VkShaderStageFlags cooperativeMatrixSupportedStages;
}

alias PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV = fn VkResult(
  VkPhysicalDevice physicalDevice, 
  uint * pPropertyCount, 
  VkCooperativeMatrixPropertiesNV * pProperties);

fn VkResult getPhysicalDeviceCooperativeMatrixPropertiesNV(
  VkPhysicalDevice physicalDevice, 
  uint * pPropertyCount, 
  VkCooperativeMatrixPropertiesNV * pProperties)
@extern("vkGetPhysicalDeviceCooperativeMatrixPropertiesNV");

typedef VkCoverageReductionModeNV = inline CUInt;
const VkCoverageReductionModeNV COVERAGE_REDUCTION_MODE_MERGE_NV = 0;
const VkCoverageReductionModeNV COVERAGE_REDUCTION_MODE_TRUNCATE_NV = 1;
const VkCoverageReductionModeNV COVERAGE_REDUCTION_MODE_MAX_ENUM_NV = 0x7FFFFFFF;

alias VkPipelineCoverageReductionStateCreateFlagsNV = VkFlags;

struct VkPhysicalDeviceCoverageReductionModeFeaturesNV {
  VkStructureType sType;
  void * pNext;
  VkBool32 coverageReductionMode;
}

struct VkPipelineCoverageReductionStateCreateInfoNV {
  VkStructureType sType;
  void * pNext;
  VkPipelineCoverageReductionStateCreateFlagsNV flags;
  VkCoverageReductionModeNV coverageReductionMode;
}

struct VkFramebufferMixedSamplesCombinationNV {
  VkStructureType sType;
  void * pNext;
  VkCoverageReductionModeNV coverageReductionMode;
  VkSampleCountFlagBits rasterizationSamples;
  VkSampleCountFlags depthStencilSamples;
  VkSampleCountFlags colorSamples;
}

alias PFN_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV = fn VkResult(
  VkPhysicalDevice physicalDevice, 
  uint * pCombinationCount, 
  VkFramebufferMixedSamplesCombinationNV * pCombinations);

fn VkResult getPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(
  VkPhysicalDevice physicalDevice, 
  uint * pCombinationCount, 
  VkFramebufferMixedSamplesCombinationNV * pCombinations)
@extern("vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV");

struct VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 fragmentShaderSampleInterlock;
  VkBool32 fragmentShaderPixelInterlock;
  VkBool32 fragmentShaderShadingRateInterlock;
}

struct VkPhysicalDeviceYcbcrImageArraysFeaturesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 ycbcrImageArrays;
}

typedef VkProvokingVertexModeEXT = inline CUInt;
const VkProvokingVertexModeEXT PROVOKING_VERTEX_MODE_FIRST_VERTEX_EXT = 0;
const VkProvokingVertexModeEXT PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT = 1;
const VkProvokingVertexModeEXT PROVOKING_VERTEX_MODE_MAX_ENUM_EXT = 0x7FFFFFFF;

struct VkPhysicalDeviceProvokingVertexFeaturesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 provokingVertexLast;
  VkBool32 transformFeedbackPreservesProvokingVertex;
}

struct VkPhysicalDeviceProvokingVertexPropertiesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 provokingVertexModePerPipeline;
  VkBool32 transformFeedbackPreservesTriangleFanProvokingVertex;
}

struct VkPipelineRasterizationProvokingVertexStateCreateInfoEXT {
  VkStructureType sType;
  void * pNext;
  VkProvokingVertexModeEXT provokingVertexMode;
}

alias VkHeadlessSurfaceCreateFlagsEXT = VkFlags;

struct VkHeadlessSurfaceCreateInfoEXT {
  VkStructureType sType;
  void * pNext;
  VkHeadlessSurfaceCreateFlagsEXT flags;
}

alias PFN_vkCreateHeadlessSurfaceEXT = fn VkResult(
  VkInstance instance, 
  VkHeadlessSurfaceCreateInfoEXT * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkSurfaceKHR * pSurface);

fn VkResult createHeadlessSurfaceEXT(
  VkInstance instance, 
  VkHeadlessSurfaceCreateInfoEXT * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkSurfaceKHR * pSurface)
@extern("vkCreateHeadlessSurfaceEXT");

typedef VkLineRasterizationModeEXT = inline CUInt;
const VkLineRasterizationModeEXT LINE_RASTERIZATION_MODE_DEFAULT_EXT = 0;
const VkLineRasterizationModeEXT LINE_RASTERIZATION_MODE_RECTANGULAR_EXT = 1;
const VkLineRasterizationModeEXT LINE_RASTERIZATION_MODE_BRESENHAM_EXT = 2;
const VkLineRasterizationModeEXT LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT = 3;
const VkLineRasterizationModeEXT LINE_RASTERIZATION_MODE_MAX_ENUM_EXT = 0x7FFFFFFF;

struct VkPhysicalDeviceLineRasterizationFeaturesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 rectangularLines;
  VkBool32 bresenhamLines;
  VkBool32 smoothLines;
  VkBool32 stippledRectangularLines;
  VkBool32 stippledBresenhamLines;
  VkBool32 stippledSmoothLines;
}

struct VkPhysicalDeviceLineRasterizationPropertiesEXT {
  VkStructureType sType;
  void * pNext;
  uint lineSubPixelPrecisionBits;
}

struct VkPipelineRasterizationLineStateCreateInfoEXT {
  VkStructureType sType;
  void * pNext;
  VkLineRasterizationModeEXT lineRasterizationMode;
  VkBool32 stippledLineEnable;
  uint lineStippleFactor;
  ushort lineStipplePattern;
}

alias PFN_vkCmdSetLineStippleEXT = fn void(
  VkCommandBuffer commandBuffer, 
  uint lineStippleFactor, 
  ushort lineStipplePattern);

fn void cmdSetLineStippleEXT(
  VkCommandBuffer commandBuffer, 
  uint lineStippleFactor, 
  ushort lineStipplePattern)
@extern("vkCmdSetLineStippleEXT");

struct VkPhysicalDeviceShaderAtomicFloatFeaturesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 shaderBufferFloat32Atomics;
  VkBool32 shaderBufferFloat32AtomicAdd;
  VkBool32 shaderBufferFloat64Atomics;
  VkBool32 shaderBufferFloat64AtomicAdd;
  VkBool32 shaderSharedFloat32Atomics;
  VkBool32 shaderSharedFloat32AtomicAdd;
  VkBool32 shaderSharedFloat64Atomics;
  VkBool32 shaderSharedFloat64AtomicAdd;
  VkBool32 shaderImageFloat32Atomics;
  VkBool32 shaderImageFloat32AtomicAdd;
  VkBool32 sparseImageFloat32Atomics;
  VkBool32 sparseImageFloat32AtomicAdd;
}

alias VkPhysicalDeviceHostQueryResetFeaturesEXT = VkPhysicalDeviceHostQueryResetFeatures;

alias PFN_vkResetQueryPoolEXT = fn void(
  VkDevice device, 
  VkQueryPool queryPool, 
  uint firstQuery, 
  uint queryCount);

fn void resetQueryPoolEXT(
  VkDevice device, 
  VkQueryPool queryPool, 
  uint firstQuery, 
  uint queryCount)
@extern("vkResetQueryPoolEXT");

struct VkPhysicalDeviceIndexTypeUint8FeaturesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 indexTypeUint8;
}

struct VkPhysicalDeviceExtendedDynamicStateFeaturesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 extendedDynamicState;
}

alias PFN_vkCmdSetCullModeEXT = fn void(
  VkCommandBuffer commandBuffer, 
  VkCullModeFlags cullMode);

alias PFN_vkCmdSetFrontFaceEXT = fn void(
  VkCommandBuffer commandBuffer, 
  VkFrontFace frontFace);

alias PFN_vkCmdSetPrimitiveTopologyEXT = fn void(
  VkCommandBuffer commandBuffer, 
  VkPrimitiveTopology primitiveTopology);

alias PFN_vkCmdSetViewportWithCountEXT = fn void(
  VkCommandBuffer commandBuffer, 
  uint viewportCount, 
  VkViewport * pViewports);

alias PFN_vkCmdSetScissorWithCountEXT = fn void(
  VkCommandBuffer commandBuffer, 
  uint scissorCount, 
  VkRect2D * pScissors);

alias PFN_vkCmdBindVertexBuffers2EXT = fn void(
  VkCommandBuffer commandBuffer, 
  uint firstBinding, 
  uint bindingCount, 
  VkBuffer * pBuffers, 
  VkDeviceSize * pOffsets, 
  VkDeviceSize * pSizes, 
  VkDeviceSize * pStrides);

alias PFN_vkCmdSetDepthTestEnableEXT = fn void(
  VkCommandBuffer commandBuffer, 
  VkBool32 depthTestEnable);

alias PFN_vkCmdSetDepthWriteEnableEXT = fn void(
  VkCommandBuffer commandBuffer, 
  VkBool32 depthWriteEnable);

alias PFN_vkCmdSetDepthCompareOpEXT = fn void(
  VkCommandBuffer commandBuffer, 
  VkCompareOp depthCompareOp);

alias PFN_vkCmdSetDepthBoundsTestEnableEXT = fn void(
  VkCommandBuffer commandBuffer, 
  VkBool32 depthBoundsTestEnable);

alias PFN_vkCmdSetStencilTestEnableEXT = fn void(
  VkCommandBuffer commandBuffer, 
  VkBool32 stencilTestEnable);

alias PFN_vkCmdSetStencilOpEXT = fn void(
  VkCommandBuffer commandBuffer, 
  VkStencilFaceFlags faceMask, 
  VkStencilOp failOp, 
  VkStencilOp passOp, 
  VkStencilOp depthFailOp, 
  VkCompareOp compareOp);

fn void cmdSetCullModeEXT(
  VkCommandBuffer commandBuffer, 
  VkCullModeFlags cullMode)
@extern("vkCmdSetCullModeEXT");

fn void cmdSetFrontFaceEXT(
  VkCommandBuffer commandBuffer, 
  VkFrontFace frontFace)
@extern("vkCmdSetFrontFaceEXT");

fn void cmdSetPrimitiveTopologyEXT(
  VkCommandBuffer commandBuffer, 
  VkPrimitiveTopology primitiveTopology)
@extern("vkCmdSetPrimitiveTopologyEXT");

fn void cmdSetViewportWithCountEXT(
  VkCommandBuffer commandBuffer, 
  uint viewportCount, 
  VkViewport * pViewports)
@extern("vkCmdSetViewportWithCountEXT");

fn void cmdSetScissorWithCountEXT(
  VkCommandBuffer commandBuffer, 
  uint scissorCount, 
  VkRect2D * pScissors)
@extern("vkCmdSetScissorWithCountEXT");

fn void cmdBindVertexBuffers2EXT(
  VkCommandBuffer commandBuffer, 
  uint firstBinding, 
  uint bindingCount, 
  VkBuffer * pBuffers, 
  VkDeviceSize * pOffsets, 
  VkDeviceSize * pSizes, 
  VkDeviceSize * pStrides)
@extern("vkCmdBindVertexBuffers2EXT");

fn void cmdSetDepthTestEnableEXT(
  VkCommandBuffer commandBuffer, 
  VkBool32 depthTestEnable)
@extern("vkCmdSetDepthTestEnableEXT");

fn void cmdSetDepthWriteEnableEXT(
  VkCommandBuffer commandBuffer, 
  VkBool32 depthWriteEnable)
@extern("vkCmdSetDepthWriteEnableEXT");

fn void cmdSetDepthCompareOpEXT(
  VkCommandBuffer commandBuffer, 
  VkCompareOp depthCompareOp)
@extern("vkCmdSetDepthCompareOpEXT");

fn void cmdSetDepthBoundsTestEnableEXT(
  VkCommandBuffer commandBuffer, 
  VkBool32 depthBoundsTestEnable)
@extern("vkCmdSetDepthBoundsTestEnableEXT");

fn void cmdSetStencilTestEnableEXT(
  VkCommandBuffer commandBuffer, 
  VkBool32 stencilTestEnable)
@extern("vkCmdSetStencilTestEnableEXT");

fn void cmdSetStencilOpEXT(
  VkCommandBuffer commandBuffer, 
  VkStencilFaceFlags faceMask, 
  VkStencilOp failOp, 
  VkStencilOp passOp, 
  VkStencilOp depthFailOp, 
  VkCompareOp compareOp)
@extern("vkCmdSetStencilOpEXT");

struct VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 shaderBufferFloat16Atomics;
  VkBool32 shaderBufferFloat16AtomicAdd;
  VkBool32 shaderBufferFloat16AtomicMinMax;
  VkBool32 shaderBufferFloat32AtomicMinMax;
  VkBool32 shaderBufferFloat64AtomicMinMax;
  VkBool32 shaderSharedFloat16Atomics;
  VkBool32 shaderSharedFloat16AtomicAdd;
  VkBool32 shaderSharedFloat16AtomicMinMax;
  VkBool32 shaderSharedFloat32AtomicMinMax;
  VkBool32 shaderSharedFloat64AtomicMinMax;
  VkBool32 shaderImageFloat32AtomicMinMax;
  VkBool32 sparseImageFloat32AtomicMinMax;
}

struct VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 shaderDemoteToHelperInvocation;
}

typedef VkIndirectCommandsLayoutNV_T = void;

alias VkIndirectCommandsLayoutNV = VkIndirectCommandsLayoutNV_T *;

typedef VkIndirectCommandsTokenTypeNV = inline CUInt;
const VkIndirectCommandsTokenTypeNV INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV = 0;
const VkIndirectCommandsTokenTypeNV INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV = 1;
const VkIndirectCommandsTokenTypeNV INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV = 2;
const VkIndirectCommandsTokenTypeNV INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV = 3;
const VkIndirectCommandsTokenTypeNV INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV = 4;
const VkIndirectCommandsTokenTypeNV INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV = 5;
const VkIndirectCommandsTokenTypeNV INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV = 6;
const VkIndirectCommandsTokenTypeNV INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV = 7;
const VkIndirectCommandsTokenTypeNV INDIRECT_COMMANDS_TOKEN_TYPE_MAX_ENUM_NV = 0x7FFFFFFF;

typedef VkIndirectStateFlagBitsNV = inline CUInt;
const VkIndirectStateFlagBitsNV INDIRECT_STATE_FLAG_FRONTFACE_BIT_NV = 0x00000001;
const VkIndirectStateFlagBitsNV INDIRECT_STATE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF;

alias VkIndirectStateFlagsNV = VkFlags;

typedef VkIndirectCommandsLayoutUsageFlagBitsNV = inline CUInt;
const VkIndirectCommandsLayoutUsageFlagBitsNV INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV = 0x00000001;
const VkIndirectCommandsLayoutUsageFlagBitsNV INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV = 0x00000002;
const VkIndirectCommandsLayoutUsageFlagBitsNV INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NV = 0x00000004;
const VkIndirectCommandsLayoutUsageFlagBitsNV INDIRECT_COMMANDS_LAYOUT_USAGE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF;

alias VkIndirectCommandsLayoutUsageFlagsNV = VkFlags;

struct VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV {
  VkStructureType sType;
  void * pNext;
  uint maxGraphicsShaderGroupCount;
  uint maxIndirectSequenceCount;
  uint maxIndirectCommandsTokenCount;
  uint maxIndirectCommandsStreamCount;
  uint maxIndirectCommandsTokenOffset;
  uint maxIndirectCommandsStreamStride;
  uint minSequencesCountBufferOffsetAlignment;
  uint minSequencesIndexBufferOffsetAlignment;
  uint minIndirectCommandsBufferOffsetAlignment;
}

struct VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV {
  VkStructureType sType;
  void * pNext;
  VkBool32 deviceGeneratedCommands;
}

struct VkGraphicsShaderGroupCreateInfoNV {
  VkStructureType sType;
  void * pNext;
  uint stageCount;
  VkPipelineShaderStageCreateInfo * pStages;
  VkPipelineVertexInputStateCreateInfo * pVertexInputState;
  VkPipelineTessellationStateCreateInfo * pTessellationState;
}

struct VkGraphicsPipelineShaderGroupsCreateInfoNV {
  VkStructureType sType;
  void * pNext;
  uint groupCount;
  VkGraphicsShaderGroupCreateInfoNV * pGroups;
  uint pipelineCount;
  VkPipeline * pPipelines;
}

struct VkBindShaderGroupIndirectCommandNV {
  uint groupIndex;
}

struct VkBindIndexBufferIndirectCommandNV {
  VkDeviceAddress bufferAddress;
  uint size;
  VkIndexType indexType;
}

struct VkBindVertexBufferIndirectCommandNV {
  VkDeviceAddress bufferAddress;
  uint size;
  uint stride;
}

struct VkSetStateFlagsIndirectCommandNV {
  uint data;
}

struct VkIndirectCommandsStreamNV {
  VkBuffer buffer;
  VkDeviceSize offset;
}

struct VkIndirectCommandsLayoutTokenNV {
  VkStructureType sType;
  void * pNext;
  VkIndirectCommandsTokenTypeNV tokenType;
  uint stream;
  uint offset;
  uint vertexBindingUnit;
  VkBool32 vertexDynamicStride;
  VkPipelineLayout pushconstantPipelineLayout;
  VkShaderStageFlags pushconstantShaderStageFlags;
  uint pushconstantOffset;
  uint pushconstantSize;
  VkIndirectStateFlagsNV indirectStateFlags;
  uint indexTypeCount;
  VkIndexType * pIndexTypes;
  uint * pIndexTypeValues;
}

struct VkIndirectCommandsLayoutCreateInfoNV {
  VkStructureType sType;
  void * pNext;
  VkIndirectCommandsLayoutUsageFlagsNV flags;
  VkPipelineBindPoint pipelineBindPoint;
  uint tokenCount;
  VkIndirectCommandsLayoutTokenNV * pTokens;
  uint streamCount;
  uint * pStreamStrides;
}

struct VkGeneratedCommandsInfoNV {
  VkStructureType sType;
  void * pNext;
  VkPipelineBindPoint pipelineBindPoint;
  VkPipeline pipeline;
  VkIndirectCommandsLayoutNV indirectCommandsLayout;
  uint streamCount;
  VkIndirectCommandsStreamNV * pStreams;
  uint sequencesCount;
  VkBuffer preprocessBuffer;
  VkDeviceSize preprocessOffset;
  VkDeviceSize preprocessSize;
  VkBuffer sequencesCountBuffer;
  VkDeviceSize sequencesCountOffset;
  VkBuffer sequencesIndexBuffer;
  VkDeviceSize sequencesIndexOffset;
}

struct VkGeneratedCommandsMemoryRequirementsInfoNV {
  VkStructureType sType;
  void * pNext;
  VkPipelineBindPoint pipelineBindPoint;
  VkPipeline pipeline;
  VkIndirectCommandsLayoutNV indirectCommandsLayout;
  uint maxSequencesCount;
}

alias PFN_vkGetGeneratedCommandsMemoryRequirementsNV = fn void(
  VkDevice device, 
  VkGeneratedCommandsMemoryRequirementsInfoNV * pInfo, 
  VkMemoryRequirements2 * pMemoryRequirements);

alias PFN_vkCmdPreprocessGeneratedCommandsNV = fn void(
  VkCommandBuffer commandBuffer, 
  VkGeneratedCommandsInfoNV * pGeneratedCommandsInfo);

alias PFN_vkCmdExecuteGeneratedCommandsNV = fn void(
  VkCommandBuffer commandBuffer, 
  VkBool32 isPreprocessed, 
  VkGeneratedCommandsInfoNV * pGeneratedCommandsInfo);

alias PFN_vkCmdBindPipelineShaderGroupNV = fn void(
  VkCommandBuffer commandBuffer, 
  VkPipelineBindPoint pipelineBindPoint, 
  VkPipeline pipeline, 
  uint groupIndex);

alias PFN_vkCreateIndirectCommandsLayoutNV = fn VkResult(
  VkDevice device, 
  VkIndirectCommandsLayoutCreateInfoNV * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkIndirectCommandsLayoutNV * pIndirectCommandsLayout);

alias PFN_vkDestroyIndirectCommandsLayoutNV = fn void(
  VkDevice device, 
  VkIndirectCommandsLayoutNV indirectCommandsLayout, 
  VkAllocationCallbacks * pAllocator);

fn void getGeneratedCommandsMemoryRequirementsNV(
  VkDevice device, 
  VkGeneratedCommandsMemoryRequirementsInfoNV * pInfo, 
  VkMemoryRequirements2 * pMemoryRequirements)
@extern("vkGetGeneratedCommandsMemoryRequirementsNV");

fn void cmdPreprocessGeneratedCommandsNV(
  VkCommandBuffer commandBuffer, 
  VkGeneratedCommandsInfoNV * pGeneratedCommandsInfo)
@extern("vkCmdPreprocessGeneratedCommandsNV");

fn void cmdExecuteGeneratedCommandsNV(
  VkCommandBuffer commandBuffer, 
  VkBool32 isPreprocessed, 
  VkGeneratedCommandsInfoNV * pGeneratedCommandsInfo)
@extern("vkCmdExecuteGeneratedCommandsNV");

fn void cmdBindPipelineShaderGroupNV(
  VkCommandBuffer commandBuffer, 
  VkPipelineBindPoint pipelineBindPoint, 
  VkPipeline pipeline, 
  uint groupIndex)
@extern("vkCmdBindPipelineShaderGroupNV");

fn VkResult createIndirectCommandsLayoutNV(
  VkDevice device, 
  VkIndirectCommandsLayoutCreateInfoNV * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkIndirectCommandsLayoutNV * pIndirectCommandsLayout)
@extern("vkCreateIndirectCommandsLayoutNV");

fn void destroyIndirectCommandsLayoutNV(
  VkDevice device, 
  VkIndirectCommandsLayoutNV indirectCommandsLayout, 
  VkAllocationCallbacks * pAllocator)
@extern("vkDestroyIndirectCommandsLayoutNV");

struct VkPhysicalDeviceInheritedViewportScissorFeaturesNV {
  VkStructureType sType;
  void * pNext;
  VkBool32 inheritedViewportScissor2D;
}

struct VkCommandBufferInheritanceViewportScissorInfoNV {
  VkStructureType sType;
  void * pNext;
  VkBool32 viewportScissor2D;
  uint viewportDepthCount;
  VkViewport * pViewportDepths;
}

struct VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 texelBufferAlignment;
}

struct VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT {
  VkStructureType sType;
  void * pNext;
  VkDeviceSize storageTexelBufferOffsetAlignmentBytes;
  VkBool32 storageTexelBufferOffsetSingleTexelAlignment;
  VkDeviceSize uniformTexelBufferOffsetAlignmentBytes;
  VkBool32 uniformTexelBufferOffsetSingleTexelAlignment;
}

struct VkRenderPassTransformBeginInfoQCOM {
  VkStructureType sType;
  void * pNext;
  VkSurfaceTransformFlagBitsKHR transform;
}

struct VkCommandBufferInheritanceRenderPassTransformInfoQCOM {
  VkStructureType sType;
  void * pNext;
  VkSurfaceTransformFlagBitsKHR transform;
  VkRect2D renderArea;
}

typedef VkDeviceMemoryReportEventTypeEXT = inline CUInt;
const VkDeviceMemoryReportEventTypeEXT DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT = 0;
const VkDeviceMemoryReportEventTypeEXT DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT = 1;
const VkDeviceMemoryReportEventTypeEXT DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT = 2;
const VkDeviceMemoryReportEventTypeEXT DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT = 3;
const VkDeviceMemoryReportEventTypeEXT DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT = 4;
const VkDeviceMemoryReportEventTypeEXT DEVICE_MEMORY_REPORT_EVENT_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF;

alias VkDeviceMemoryReportFlagsEXT = VkFlags;

struct VkPhysicalDeviceDeviceMemoryReportFeaturesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 deviceMemoryReport;
}

struct VkDeviceMemoryReportCallbackDataEXT {
  VkStructureType sType;
  void * pNext;
  VkDeviceMemoryReportFlagsEXT flags;
  VkDeviceMemoryReportEventTypeEXT type;
  ulong memoryObjectId;
  VkDeviceSize size;
  VkObjectType objectType;
  ulong objectHandle;
  uint heapIndex;
}

alias PFN_vkDeviceMemoryReportCallbackEXT = fn void(
  VkDeviceMemoryReportCallbackDataEXT * pCallbackData, 
  void * pUserData);

struct VkDeviceDeviceMemoryReportCreateInfoEXT {
  VkStructureType sType;
  void * pNext;
  VkDeviceMemoryReportFlagsEXT flags;
  PFN_vkDeviceMemoryReportCallbackEXT pfnUserCallback;
  void * pUserData;
}

alias PFN_vkAcquireDrmDisplayEXT = fn VkResult(
  VkPhysicalDevice physicalDevice, 
  int drmFd, 
  VkDisplayKHR display);

alias PFN_vkGetDrmDisplayEXT = fn VkResult(
  VkPhysicalDevice physicalDevice, 
  int drmFd, 
  uint connectorId, 
  VkDisplayKHR * display);

fn VkResult acquireDrmDisplayEXT(
  VkPhysicalDevice physicalDevice, 
  int drmFd, 
  VkDisplayKHR display)
@extern("vkAcquireDrmDisplayEXT");

fn VkResult getDrmDisplayEXT(
  VkPhysicalDevice physicalDevice, 
  int drmFd, 
  uint connectorId, 
  VkDisplayKHR * display)
@extern("vkGetDrmDisplayEXT");

struct VkPhysicalDeviceRobustness2FeaturesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 robustBufferAccess2;
  VkBool32 robustImageAccess2;
  VkBool32 nullDescriptor;
}

struct VkPhysicalDeviceRobustness2PropertiesEXT {
  VkStructureType sType;
  void * pNext;
  VkDeviceSize robustStorageBufferAccessSizeAlignment;
  VkDeviceSize robustUniformBufferAccessSizeAlignment;
}

struct VkSamplerCustomBorderColorCreateInfoEXT {
  VkStructureType sType;
  void * pNext;
  VkClearColorValue customBorderColor;
  VkFormat format;
}

struct VkPhysicalDeviceCustomBorderColorPropertiesEXT {
  VkStructureType sType;
  void * pNext;
  uint maxCustomBorderColorSamplers;
}

struct VkPhysicalDeviceCustomBorderColorFeaturesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 customBorderColors;
  VkBool32 customBorderColorWithoutFormat;
}

typedef VkPrivateDataSlotEXT_T = void;

alias VkPrivateDataSlotEXT = VkPrivateDataSlotEXT_T *;

typedef VkPrivateDataSlotCreateFlagBitsEXT = inline CUInt;
const VkPrivateDataSlotCreateFlagBitsEXT PRIVATE_DATA_SLOT_CREATE_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF;

alias VkPrivateDataSlotCreateFlagsEXT = VkFlags;

struct VkPhysicalDevicePrivateDataFeaturesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 privateData;
}

struct VkDevicePrivateDataCreateInfoEXT {
  VkStructureType sType;
  void * pNext;
  uint privateDataSlotRequestCount;
}

struct VkPrivateDataSlotCreateInfoEXT {
  VkStructureType sType;
  void * pNext;
  VkPrivateDataSlotCreateFlagsEXT flags;
}

alias PFN_vkCreatePrivateDataSlotEXT = fn VkResult(
  VkDevice device, 
  VkPrivateDataSlotCreateInfoEXT * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkPrivateDataSlotEXT * pPrivateDataSlot);

alias PFN_vkDestroyPrivateDataSlotEXT = fn void(
  VkDevice device, 
  VkPrivateDataSlotEXT privateDataSlot, 
  VkAllocationCallbacks * pAllocator);

alias PFN_vkSetPrivateDataEXT = fn VkResult(
  VkDevice device, 
  VkObjectType objectType, 
  ulong objectHandle, 
  VkPrivateDataSlotEXT privateDataSlot, 
  ulong data);

alias PFN_vkGetPrivateDataEXT = fn void(
  VkDevice device, 
  VkObjectType objectType, 
  ulong objectHandle, 
  VkPrivateDataSlotEXT privateDataSlot, 
  ulong * pData);

fn VkResult createPrivateDataSlotEXT(
  VkDevice device, 
  VkPrivateDataSlotCreateInfoEXT * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkPrivateDataSlotEXT * pPrivateDataSlot)
@extern("vkCreatePrivateDataSlotEXT");

fn void destroyPrivateDataSlotEXT(
  VkDevice device, 
  VkPrivateDataSlotEXT privateDataSlot, 
  VkAllocationCallbacks * pAllocator)
@extern("vkDestroyPrivateDataSlotEXT");

fn VkResult setPrivateDataEXT(
  VkDevice device, 
  VkObjectType objectType, 
  ulong objectHandle, 
  VkPrivateDataSlotEXT privateDataSlot, 
  ulong data)
@extern("vkSetPrivateDataEXT");

fn void getPrivateDataEXT(
  VkDevice device, 
  VkObjectType objectType, 
  ulong objectHandle, 
  VkPrivateDataSlotEXT privateDataSlot, 
  ulong * pData)
@extern("vkGetPrivateDataEXT");

struct VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 pipelineCreationCacheControl;
}

typedef VkDeviceDiagnosticsConfigFlagBitsNV = inline CUInt;
const VkDeviceDiagnosticsConfigFlagBitsNV DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV = 0x00000001;
const VkDeviceDiagnosticsConfigFlagBitsNV DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV = 0x00000002;
const VkDeviceDiagnosticsConfigFlagBitsNV DEVICE_DIAGNOSTICS_CONFIG_ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV = 0x00000004;
const VkDeviceDiagnosticsConfigFlagBitsNV DEVICE_DIAGNOSTICS_CONFIG_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF;

alias VkDeviceDiagnosticsConfigFlagsNV = VkFlags;

struct VkPhysicalDeviceDiagnosticsConfigFeaturesNV {
  VkStructureType sType;
  void * pNext;
  VkBool32 diagnosticsConfig;
}

struct VkDeviceDiagnosticsConfigCreateInfoNV {
  VkStructureType sType;
  void * pNext;
  VkDeviceDiagnosticsConfigFlagsNV flags;
}

typedef VkFragmentShadingRateTypeNV = inline CUInt;
const VkFragmentShadingRateTypeNV FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV = 0;
const VkFragmentShadingRateTypeNV FRAGMENT_SHADING_RATE_TYPE_ENUMS_NV = 1;
const VkFragmentShadingRateTypeNV FRAGMENT_SHADING_RATE_TYPE_MAX_ENUM_NV = 0x7FFFFFFF;

typedef VkFragmentShadingRateNV = inline CUInt;
const VkFragmentShadingRateNV FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV = 0;
const VkFragmentShadingRateNV FRAGMENT_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV = 1;
const VkFragmentShadingRateNV FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV = 4;
const VkFragmentShadingRateNV FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV = 5;
const VkFragmentShadingRateNV FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV = 6;
const VkFragmentShadingRateNV FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV = 9;
const VkFragmentShadingRateNV FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV = 10;
const VkFragmentShadingRateNV FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV = 11;
const VkFragmentShadingRateNV FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV = 12;
const VkFragmentShadingRateNV FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV = 13;
const VkFragmentShadingRateNV FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV = 14;
const VkFragmentShadingRateNV FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV = 15;
const VkFragmentShadingRateNV FRAGMENT_SHADING_RATE_MAX_ENUM_NV = 0x7FFFFFFF;

struct VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV {
  VkStructureType sType;
  void * pNext;
  VkBool32 fragmentShadingRateEnums;
  VkBool32 supersampleFragmentShadingRates;
  VkBool32 noInvocationFragmentShadingRates;
}

struct VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV {
  VkStructureType sType;
  void * pNext;
  VkSampleCountFlagBits maxFragmentShadingRateInvocationCount;
}

struct VkPipelineFragmentShadingRateEnumStateCreateInfoNV {
  VkStructureType sType;
  void * pNext;
  VkFragmentShadingRateTypeNV shadingRateType;
  VkFragmentShadingRateNV shadingRate;
  VkFragmentShadingRateCombinerOpKHR[2] combinerOps;
}

alias PFN_vkCmdSetFragmentShadingRateEnumNV = fn void(
  VkCommandBuffer commandBuffer, 
  VkFragmentShadingRateNV shadingRate, 
  VkFragmentShadingRateCombinerOpKHR[2] combinerOps);

fn void cmdSetFragmentShadingRateEnumNV(
  VkCommandBuffer commandBuffer, 
  VkFragmentShadingRateNV shadingRate, 
  VkFragmentShadingRateCombinerOpKHR[2] combinerOps)
@extern("vkCmdSetFragmentShadingRateEnumNV");

typedef VkAccelerationStructureMotionInstanceTypeNV = inline CUInt;
const VkAccelerationStructureMotionInstanceTypeNV ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV = 0;
const VkAccelerationStructureMotionInstanceTypeNV ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV = 1;
const VkAccelerationStructureMotionInstanceTypeNV ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV = 2;
const VkAccelerationStructureMotionInstanceTypeNV ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MAX_ENUM_NV = 0x7FFFFFFF;

alias VkAccelerationStructureMotionInfoFlagsNV = VkFlags;

alias VkAccelerationStructureMotionInstanceFlagsNV = VkFlags;

union VkDeviceOrHostAddressConstKHR {
  VkDeviceAddress deviceAddress;
  void * hostAddress;
}

struct VkAccelerationStructureGeometryMotionTrianglesDataNV {
  VkStructureType sType;
  void * pNext;
  VkDeviceOrHostAddressConstKHR vertexData;
}

struct VkAccelerationStructureMotionInfoNV {
  VkStructureType sType;
  void * pNext;
  uint maxInstances;
  VkAccelerationStructureMotionInfoFlagsNV flags;
}

struct VkAccelerationStructureMatrixMotionInstanceNV {
  VkTransformMatrixKHR transformT0;
  VkTransformMatrixKHR transformT1;
  bitstruct : ulong {
    uint instanceCustomIndex : 0..23;
    uint mask : 24..31;
    uint instanceShaderBindingTableRecordOffset : 32..55;
    VkGeometryInstanceFlagsKHR flags : 56..63;
  }
  ulong accelerationStructureReference;
}

struct VkSRTDataNV {
  float sx;
  float a;
  float b;
  float pvx;
  float sy;
  float c;
  float pvy;
  float sz;
  float pvz;
  float qx;
  float qy;
  float qz;
  float qw;
  float tx;
  float ty;
  float tz;
}

struct VkAccelerationStructureSRTMotionInstanceNV {
  VkSRTDataNV transformT0;
  VkSRTDataNV transformT1;
  bitstruct : ulong {
    uint instanceCustomIndex : 0..23;
    uint mask : 24..31;
    uint instanceShaderBindingTableRecordOffset : 32..55;
    VkGeometryInstanceFlagsKHR flags : 56..63;
  }
  ulong accelerationStructureReference;
}

union VkAccelerationStructureMotionInstanceDataNV {
  VkAccelerationStructureInstanceKHR staticInstance;
  VkAccelerationStructureMatrixMotionInstanceNV matrixMotionInstance;
  VkAccelerationStructureSRTMotionInstanceNV srtMotionInstance;
}

struct VkAccelerationStructureMotionInstanceNV {
  VkAccelerationStructureMotionInstanceTypeNV type;
  VkAccelerationStructureMotionInstanceFlagsNV flags;
  VkAccelerationStructureMotionInstanceDataNV data;
}

struct VkPhysicalDeviceRayTracingMotionBlurFeaturesNV {
  VkStructureType sType;
  void * pNext;
  VkBool32 rayTracingMotionBlur;
  VkBool32 rayTracingMotionBlurPipelineTraceRaysIndirect;
}

struct VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 ycbcr2plane444Formats;
}

struct VkPhysicalDeviceFragmentDensityMap2FeaturesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 fragmentDensityMapDeferred;
}

struct VkPhysicalDeviceFragmentDensityMap2PropertiesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 subsampledLoads;
  VkBool32 subsampledCoarseReconstructionEarlyAccess;
  uint maxSubsampledArrayLayers;
  uint maxDescriptorSetSubsampledSamplers;
}

struct VkCopyCommandTransformInfoQCOM {
  VkStructureType sType;
  void * pNext;
  VkSurfaceTransformFlagBitsKHR transform;
}

struct VkPhysicalDeviceImageRobustnessFeaturesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 robustImageAccess;
}

struct VkPhysicalDevice4444FormatsFeaturesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 formatA4R4G4B4;
  VkBool32 formatA4B4G4R4;
}

struct VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM {
  VkStructureType sType;
  void * pNext;
  VkBool32 rasterizationOrderColorAttachmentAccess;
  VkBool32 rasterizationOrderDepthAttachmentAccess;
  VkBool32 rasterizationOrderStencilAttachmentAccess;
}

struct VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 formatRgba10x6WithoutYCbCrSampler;
}

alias PFN_vkAcquireWinrtDisplayNV = fn VkResult(
  VkPhysicalDevice physicalDevice, 
  VkDisplayKHR display);

alias PFN_vkGetWinrtDisplayNV = fn VkResult(
  VkPhysicalDevice physicalDevice, 
  uint deviceRelativeId, 
  VkDisplayKHR * pDisplay);

fn VkResult acquireWinrtDisplayNV(
  VkPhysicalDevice physicalDevice, 
  VkDisplayKHR display)
@extern("vkAcquireWinrtDisplayNV");

fn VkResult getWinrtDisplayNV(
  VkPhysicalDevice physicalDevice, 
  uint deviceRelativeId, 
  VkDisplayKHR * pDisplay)
@extern("vkGetWinrtDisplayNV");

struct VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE {
  VkStructureType sType;
  void * pNext;
  VkBool32 mutableDescriptorType;
}

struct VkMutableDescriptorTypeListVALVE {
  uint descriptorTypeCount;
  VkDescriptorType * pDescriptorTypes;
}

struct VkMutableDescriptorTypeCreateInfoVALVE {
  VkStructureType sType;
  void * pNext;
  uint mutableDescriptorTypeListCount;
  VkMutableDescriptorTypeListVALVE * pMutableDescriptorTypeLists;
}

struct VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 vertexInputDynamicState;
}

struct VkVertexInputBindingDescription2EXT {
  VkStructureType sType;
  void * pNext;
  uint binding;
  uint stride;
  VkVertexInputRate inputRate;
  uint divisor;
}

struct VkVertexInputAttributeDescription2EXT {
  VkStructureType sType;
  void * pNext;
  uint location;
  uint binding;
  VkFormat format;
  uint offset;
}

alias PFN_vkCmdSetVertexInputEXT = fn void(
  VkCommandBuffer commandBuffer, 
  uint vertexBindingDescriptionCount, 
  VkVertexInputBindingDescription2EXT * pVertexBindingDescriptions, 
  uint vertexAttributeDescriptionCount, 
  VkVertexInputAttributeDescription2EXT * pVertexAttributeDescriptions);

fn void cmdSetVertexInputEXT(
  VkCommandBuffer commandBuffer, 
  uint vertexBindingDescriptionCount, 
  VkVertexInputBindingDescription2EXT * pVertexBindingDescriptions, 
  uint vertexAttributeDescriptionCount, 
  VkVertexInputAttributeDescription2EXT * pVertexAttributeDescriptions)
@extern("vkCmdSetVertexInputEXT");

struct VkPhysicalDeviceDrmPropertiesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 hasPrimary;
  VkBool32 hasRender;
  long primaryMajor;
  long primaryMinor;
  long renderMajor;
  long renderMinor;
}

struct VkPhysicalDeviceDepthClipControlFeaturesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 depthClipControl;
}

struct VkPipelineViewportDepthClipControlCreateInfoEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 negativeOneToOne;
}

struct VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 primitiveTopologyListRestart;
  VkBool32 primitiveTopologyPatchListRestart;
}

struct VkSubpassShadingPipelineCreateInfoHUAWEI {
  VkStructureType sType;
  void * pNext;
  VkRenderPass renderPass;
  uint subpass;
}

struct VkPhysicalDeviceSubpassShadingFeaturesHUAWEI {
  VkStructureType sType;
  void * pNext;
  VkBool32 subpassShading;
}

struct VkPhysicalDeviceSubpassShadingPropertiesHUAWEI {
  VkStructureType sType;
  void * pNext;
  uint maxSubpassShadingWorkgroupSizeAspectRatio;
}

alias PFN_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI = fn VkResult(
  VkDevice device, 
  VkRenderPass renderpass, 
  VkExtent2D * pMaxWorkgroupSize);

alias PFN_vkCmdSubpassShadingHUAWEI = fn void(  VkCommandBuffer commandBuffer);

fn VkResult getDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(
  VkDevice device, 
  VkRenderPass renderpass, 
  VkExtent2D * pMaxWorkgroupSize)
@extern("vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI");

fn void cmdSubpassShadingHUAWEI(
  VkCommandBuffer commandBuffer)
@extern("vkCmdSubpassShadingHUAWEI");

struct VkPhysicalDeviceInvocationMaskFeaturesHUAWEI {
  VkStructureType sType;
  void * pNext;
  VkBool32 invocationMask;
}

alias PFN_vkCmdBindInvocationMaskHUAWEI = fn void(
  VkCommandBuffer commandBuffer, 
  VkImageView imageView, 
  VkImageLayout imageLayout);

fn void cmdBindInvocationMaskHUAWEI(
  VkCommandBuffer commandBuffer, 
  VkImageView imageView, 
  VkImageLayout imageLayout)
@extern("vkCmdBindInvocationMaskHUAWEI");

alias VkRemoteAddressNV = void *;

struct VkMemoryGetRemoteAddressInfoNV {
  VkStructureType sType;
  void * pNext;
  VkDeviceMemory memory;
  VkExternalMemoryHandleTypeFlagBits handleType;
}

struct VkPhysicalDeviceExternalMemoryRDMAFeaturesNV {
  VkStructureType sType;
  void * pNext;
  VkBool32 externalMemoryRDMA;
}

alias PFN_vkGetMemoryRemoteAddressNV = fn VkResult(
  VkDevice device, 
  VkMemoryGetRemoteAddressInfoNV * pMemoryGetRemoteAddressInfo, 
  VkRemoteAddressNV * pAddress);

fn VkResult getMemoryRemoteAddressNV(
  VkDevice device, 
  VkMemoryGetRemoteAddressInfoNV * pMemoryGetRemoteAddressInfo, 
  VkRemoteAddressNV * pAddress)
@extern("vkGetMemoryRemoteAddressNV");

struct VkPhysicalDeviceExtendedDynamicState2FeaturesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 extendedDynamicState2;
  VkBool32 extendedDynamicState2LogicOp;
  VkBool32 extendedDynamicState2PatchControlPoints;
}

alias PFN_vkCmdSetPatchControlPointsEXT = fn void(
  VkCommandBuffer commandBuffer, 
  uint patchControlPoints);

alias PFN_vkCmdSetRasterizerDiscardEnableEXT = fn void(
  VkCommandBuffer commandBuffer, 
  VkBool32 rasterizerDiscardEnable);

alias PFN_vkCmdSetDepthBiasEnableEXT = fn void(
  VkCommandBuffer commandBuffer, 
  VkBool32 depthBiasEnable);

alias PFN_vkCmdSetLogicOpEXT = fn void(
  VkCommandBuffer commandBuffer, 
  VkLogicOp logicOp);

alias PFN_vkCmdSetPrimitiveRestartEnableEXT = fn void(
  VkCommandBuffer commandBuffer, 
  VkBool32 primitiveRestartEnable);

fn void cmdSetPatchControlPointsEXT(
  VkCommandBuffer commandBuffer, 
  uint patchControlPoints)
@extern("vkCmdSetPatchControlPointsEXT");

fn void cmdSetRasterizerDiscardEnableEXT(
  VkCommandBuffer commandBuffer, 
  VkBool32 rasterizerDiscardEnable)
@extern("vkCmdSetRasterizerDiscardEnableEXT");

fn void cmdSetDepthBiasEnableEXT(
  VkCommandBuffer commandBuffer, 
  VkBool32 depthBiasEnable)
@extern("vkCmdSetDepthBiasEnableEXT");

fn void cmdSetLogicOpEXT(
  VkCommandBuffer commandBuffer, 
  VkLogicOp logicOp)
@extern("vkCmdSetLogicOpEXT");

fn void cmdSetPrimitiveRestartEnableEXT(
  VkCommandBuffer commandBuffer, 
  VkBool32 primitiveRestartEnable)
@extern("vkCmdSetPrimitiveRestartEnableEXT");

struct VkPhysicalDeviceColorWriteEnableFeaturesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 colorWriteEnable;
}

struct VkPipelineColorWriteCreateInfoEXT {
  VkStructureType sType;
  void * pNext;
  uint attachmentCount;
  VkBool32 * pColorWriteEnables;
}

alias PFN_vkCmdSetColorWriteEnableEXT = fn void(
  VkCommandBuffer commandBuffer, 
  uint attachmentCount, 
  VkBool32 * pColorWriteEnables);

fn void cmdSetColorWriteEnableEXT(
  VkCommandBuffer commandBuffer, 
  uint attachmentCount, 
  VkBool32 * pColorWriteEnables)
@extern("vkCmdSetColorWriteEnableEXT");

struct VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 globalPriorityQuery;
}

struct VkQueueFamilyGlobalPriorityPropertiesEXT {
  VkStructureType sType;
  void * pNext;
  uint priorityCount;
  VkQueueGlobalPriorityEXT[16] priorities;
}

struct VkPhysicalDeviceImageViewMinLodFeaturesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 minLod;
}

struct VkImageViewMinLodCreateInfoEXT {
  VkStructureType sType;
  void * pNext;
  float minLod;
}

struct VkPhysicalDeviceMultiDrawFeaturesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 multiDraw;
}

struct VkPhysicalDeviceMultiDrawPropertiesEXT {
  VkStructureType sType;
  void * pNext;
  uint maxMultiDrawCount;
}

struct VkMultiDrawInfoEXT {
  uint firstVertex;
  uint vertexCount;
}

struct VkMultiDrawIndexedInfoEXT {
  uint firstIndex;
  uint indexCount;
  int vertexOffset;
}

alias PFN_vkCmdDrawMultiEXT = fn void(
  VkCommandBuffer commandBuffer, 
  uint drawCount, 
  VkMultiDrawInfoEXT * pVertexInfo, 
  uint instanceCount, 
  uint firstInstance, 
  uint stride);

alias PFN_vkCmdDrawMultiIndexedEXT = fn void(
  VkCommandBuffer commandBuffer, 
  uint drawCount, 
  VkMultiDrawIndexedInfoEXT * pIndexInfo, 
  uint instanceCount, 
  uint firstInstance, 
  uint stride, 
  int * pVertexOffset);

fn void cmdDrawMultiEXT(
  VkCommandBuffer commandBuffer, 
  uint drawCount, 
  VkMultiDrawInfoEXT * pVertexInfo, 
  uint instanceCount, 
  uint firstInstance, 
  uint stride)
@extern("vkCmdDrawMultiEXT");

fn void cmdDrawMultiIndexedEXT(
  VkCommandBuffer commandBuffer, 
  uint drawCount, 
  VkMultiDrawIndexedInfoEXT * pIndexInfo, 
  uint instanceCount, 
  uint firstInstance, 
  uint stride, 
  int * pVertexOffset)
@extern("vkCmdDrawMultiIndexedEXT");

struct VkPhysicalDeviceBorderColorSwizzleFeaturesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 borderColorSwizzle;
  VkBool32 borderColorSwizzleFromImage;
}

struct VkSamplerBorderColorComponentMappingCreateInfoEXT {
  VkStructureType sType;
  void * pNext;
  VkComponentMapping components;
  VkBool32 srgb;
}

struct VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 pageableDeviceLocalMemory;
}

alias PFN_vkSetDeviceMemoryPriorityEXT = fn void(
  VkDevice device, 
  VkDeviceMemory memory, 
  float priority);

fn void setDeviceMemoryPriorityEXT(
  VkDevice device, 
  VkDeviceMemory memory, 
  float priority)
@extern("vkSetDeviceMemoryPriorityEXT");

struct VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM {
  VkStructureType sType;
  void * pNext;
  VkBool32 fragmentDensityMapOffset;
}

struct VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM {
  VkStructureType sType;
  void * pNext;
  VkExtent2D fragmentDensityOffsetGranularity;
}

struct VkSubpassFragmentDensityMapOffsetEndInfoQCOM {
  VkStructureType sType;
  void * pNext;
  uint fragmentDensityOffsetCount;
  VkOffset2D * pFragmentDensityOffsets;
}

struct VkPhysicalDeviceLinearColorAttachmentFeaturesNV {
  VkStructureType sType;
  void * pNext;
  VkBool32 linearColorAttachment;
}

typedef VkAccelerationStructureKHR_T = void;

alias VkAccelerationStructureKHR = VkAccelerationStructureKHR_T *;

typedef VkBuildAccelerationStructureModeKHR = inline CUInt;
const VkBuildAccelerationStructureModeKHR BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR = 0;
const VkBuildAccelerationStructureModeKHR BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR = 1;
const VkBuildAccelerationStructureModeKHR BUILD_ACCELERATION_STRUCTURE_MODE_MAX_ENUM_KHR = 0x7FFFFFFF;

typedef VkAccelerationStructureBuildTypeKHR = inline CUInt;
const VkAccelerationStructureBuildTypeKHR ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR = 0;
const VkAccelerationStructureBuildTypeKHR ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR = 1;
const VkAccelerationStructureBuildTypeKHR ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR = 2;
const VkAccelerationStructureBuildTypeKHR ACCELERATION_STRUCTURE_BUILD_TYPE_MAX_ENUM_KHR = 0x7FFFFFFF;

typedef VkAccelerationStructureCompatibilityKHR = inline CUInt;
const VkAccelerationStructureCompatibilityKHR ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR = 0;
const VkAccelerationStructureCompatibilityKHR ACCELERATION_STRUCTURE_COMPATIBILITY_INCOMPATIBLE_KHR = 1;
const VkAccelerationStructureCompatibilityKHR ACCELERATION_STRUCTURE_COMPATIBILITY_MAX_ENUM_KHR = 0x7FFFFFFF;

typedef VkAccelerationStructureCreateFlagBitsKHR = inline CUInt;
const VkAccelerationStructureCreateFlagBitsKHR ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR = 0x00000001;
const VkAccelerationStructureCreateFlagBitsKHR ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV = 0x00000004;
const VkAccelerationStructureCreateFlagBitsKHR ACCELERATION_STRUCTURE_CREATE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF;

alias VkAccelerationStructureCreateFlagsKHR = VkFlags;

union VkDeviceOrHostAddressKHR {
  VkDeviceAddress deviceAddress;
  void * hostAddress;
}

struct VkAccelerationStructureBuildRangeInfoKHR {
  uint primitiveCount;
  uint primitiveOffset;
  uint firstVertex;
  uint transformOffset;
}

struct VkAccelerationStructureGeometryTrianglesDataKHR {
  VkStructureType sType;
  void * pNext;
  VkFormat vertexFormat;
  VkDeviceOrHostAddressConstKHR vertexData;
  VkDeviceSize vertexStride;
  uint maxVertex;
  VkIndexType indexType;
  VkDeviceOrHostAddressConstKHR indexData;
  VkDeviceOrHostAddressConstKHR transformData;
}

struct VkAccelerationStructureGeometryAabbsDataKHR {
  VkStructureType sType;
  void * pNext;
  VkDeviceOrHostAddressConstKHR data;
  VkDeviceSize stride;
}

struct VkAccelerationStructureGeometryInstancesDataKHR {
  VkStructureType sType;
  void * pNext;
  VkBool32 arrayOfPointers;
  VkDeviceOrHostAddressConstKHR data;
}

union VkAccelerationStructureGeometryDataKHR {
  VkAccelerationStructureGeometryTrianglesDataKHR triangles;
  VkAccelerationStructureGeometryAabbsDataKHR aabbs;
  VkAccelerationStructureGeometryInstancesDataKHR instances;
}

struct VkAccelerationStructureGeometryKHR {
  VkStructureType sType;
  void * pNext;
  VkGeometryTypeKHR geometryType;
  VkAccelerationStructureGeometryDataKHR geometry;
  VkGeometryFlagsKHR flags;
}

struct VkAccelerationStructureBuildGeometryInfoKHR {
  VkStructureType sType;
  void * pNext;
  VkAccelerationStructureTypeKHR type;
  VkBuildAccelerationStructureFlagsKHR flags;
  VkBuildAccelerationStructureModeKHR mode;
  VkAccelerationStructureKHR srcAccelerationStructure;
  VkAccelerationStructureKHR dstAccelerationStructure;
  uint geometryCount;
  VkAccelerationStructureGeometryKHR * pGeometries;
  VkAccelerationStructureGeometryKHR ** ppGeometries;
  VkDeviceOrHostAddressKHR scratchData;
}

struct VkAccelerationStructureCreateInfoKHR {
  VkStructureType sType;
  void * pNext;
  VkAccelerationStructureCreateFlagsKHR createFlags;
  VkBuffer buffer;
  VkDeviceSize offset;
  VkDeviceSize size;
  VkAccelerationStructureTypeKHR type;
  VkDeviceAddress deviceAddress;
}

struct VkWriteDescriptorSetAccelerationStructureKHR {
  VkStructureType sType;
  void * pNext;
  uint accelerationStructureCount;
  VkAccelerationStructureKHR * pAccelerationStructures;
}

struct VkPhysicalDeviceAccelerationStructureFeaturesKHR {
  VkStructureType sType;
  void * pNext;
  VkBool32 accelerationStructure;
  VkBool32 accelerationStructureCaptureReplay;
  VkBool32 accelerationStructureIndirectBuild;
  VkBool32 accelerationStructureHostCommands;
  VkBool32 descriptorBindingAccelerationStructureUpdateAfterBind;
}

struct VkPhysicalDeviceAccelerationStructurePropertiesKHR {
  VkStructureType sType;
  void * pNext;
  ulong maxGeometryCount;
  ulong maxInstanceCount;
  ulong maxPrimitiveCount;
  uint maxPerStageDescriptorAccelerationStructures;
  uint maxPerStageDescriptorUpdateAfterBindAccelerationStructures;
  uint maxDescriptorSetAccelerationStructures;
  uint maxDescriptorSetUpdateAfterBindAccelerationStructures;
  uint minAccelerationStructureScratchOffsetAlignment;
}

struct VkAccelerationStructureDeviceAddressInfoKHR {
  VkStructureType sType;
  void * pNext;
  VkAccelerationStructureKHR accelerationStructure;
}

struct VkAccelerationStructureVersionInfoKHR {
  VkStructureType sType;
  void * pNext;
  char * pVersionData;
}

struct VkCopyAccelerationStructureToMemoryInfoKHR {
  VkStructureType sType;
  void * pNext;
  VkAccelerationStructureKHR src;
  VkDeviceOrHostAddressKHR dst;
  VkCopyAccelerationStructureModeKHR mode;
}

struct VkCopyMemoryToAccelerationStructureInfoKHR {
  VkStructureType sType;
  void * pNext;
  VkDeviceOrHostAddressConstKHR src;
  VkAccelerationStructureKHR dst;
  VkCopyAccelerationStructureModeKHR mode;
}

struct VkCopyAccelerationStructureInfoKHR {
  VkStructureType sType;
  void * pNext;
  VkAccelerationStructureKHR src;
  VkAccelerationStructureKHR dst;
  VkCopyAccelerationStructureModeKHR mode;
}

struct VkAccelerationStructureBuildSizesInfoKHR {
  VkStructureType sType;
  void * pNext;
  VkDeviceSize accelerationStructureSize;
  VkDeviceSize updateScratchSize;
  VkDeviceSize buildScratchSize;
}

alias PFN_vkCreateAccelerationStructureKHR = fn VkResult(
  VkDevice device, 
  VkAccelerationStructureCreateInfoKHR * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkAccelerationStructureKHR * pAccelerationStructure);

alias PFN_vkDestroyAccelerationStructureKHR = fn void(
  VkDevice device, 
  VkAccelerationStructureKHR accelerationStructure, 
  VkAllocationCallbacks * pAllocator);

alias PFN_vkCmdBuildAccelerationStructuresKHR = fn void(
  VkCommandBuffer commandBuffer, 
  uint infoCount, 
  VkAccelerationStructureBuildGeometryInfoKHR * pInfos, 
  VkAccelerationStructureBuildRangeInfoKHR ** ppBuildRangeInfos);

alias PFN_vkCmdBuildAccelerationStructuresIndirectKHR = fn void(
  VkCommandBuffer commandBuffer, 
  uint infoCount, 
  VkAccelerationStructureBuildGeometryInfoKHR * pInfos, 
  VkDeviceAddress * pIndirectDeviceAddresses, 
  uint * pIndirectStrides, 
  uint ** ppMaxPrimitiveCounts);

alias PFN_vkBuildAccelerationStructuresKHR = fn VkResult(
  VkDevice device, 
  VkDeferredOperationKHR deferredOperation, 
  uint infoCount, 
  VkAccelerationStructureBuildGeometryInfoKHR * pInfos, 
  VkAccelerationStructureBuildRangeInfoKHR ** ppBuildRangeInfos);

alias PFN_vkCopyAccelerationStructureKHR = fn VkResult(
  VkDevice device, 
  VkDeferredOperationKHR deferredOperation, 
  VkCopyAccelerationStructureInfoKHR * pInfo);

alias PFN_vkCopyAccelerationStructureToMemoryKHR = fn VkResult(
  VkDevice device, 
  VkDeferredOperationKHR deferredOperation, 
  VkCopyAccelerationStructureToMemoryInfoKHR * pInfo);

alias PFN_vkCopyMemoryToAccelerationStructureKHR = fn VkResult(
  VkDevice device, 
  VkDeferredOperationKHR deferredOperation, 
  VkCopyMemoryToAccelerationStructureInfoKHR * pInfo);

alias PFN_vkWriteAccelerationStructuresPropertiesKHR = fn VkResult(
  VkDevice device, 
  uint accelerationStructureCount, 
  VkAccelerationStructureKHR * pAccelerationStructures, 
  VkQueryType queryType, 
  usz dataSize, 
  void * pData, 
  usz stride);

alias PFN_vkCmdCopyAccelerationStructureKHR = fn void(
  VkCommandBuffer commandBuffer, 
  VkCopyAccelerationStructureInfoKHR * pInfo);

alias PFN_vkCmdCopyAccelerationStructureToMemoryKHR = fn void(
  VkCommandBuffer commandBuffer, 
  VkCopyAccelerationStructureToMemoryInfoKHR * pInfo);

alias PFN_vkCmdCopyMemoryToAccelerationStructureKHR = fn void(
  VkCommandBuffer commandBuffer, 
  VkCopyMemoryToAccelerationStructureInfoKHR * pInfo);

alias PFN_vkGetAccelerationStructureDeviceAddressKHR = fn VkDeviceAddress(
  VkDevice device, 
  VkAccelerationStructureDeviceAddressInfoKHR * pInfo);

alias PFN_vkCmdWriteAccelerationStructuresPropertiesKHR = fn void(
  VkCommandBuffer commandBuffer, 
  uint accelerationStructureCount, 
  VkAccelerationStructureKHR * pAccelerationStructures, 
  VkQueryType queryType, 
  VkQueryPool queryPool, 
  uint firstQuery);

alias PFN_vkGetDeviceAccelerationStructureCompatibilityKHR = fn void(
  VkDevice device, 
  VkAccelerationStructureVersionInfoKHR * pVersionInfo, 
  VkAccelerationStructureCompatibilityKHR * pCompatibility);

alias PFN_vkGetAccelerationStructureBuildSizesKHR = fn void(
  VkDevice device, 
  VkAccelerationStructureBuildTypeKHR buildType, 
  VkAccelerationStructureBuildGeometryInfoKHR * pBuildInfo, 
  uint * pMaxPrimitiveCounts, 
  VkAccelerationStructureBuildSizesInfoKHR * pSizeInfo);

fn VkResult createAccelerationStructureKHR(
  VkDevice device, 
  VkAccelerationStructureCreateInfoKHR * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkAccelerationStructureKHR * pAccelerationStructure)
@extern("vkCreateAccelerationStructureKHR");

fn void destroyAccelerationStructureKHR(
  VkDevice device, 
  VkAccelerationStructureKHR accelerationStructure, 
  VkAllocationCallbacks * pAllocator)
@extern("vkDestroyAccelerationStructureKHR");

fn void cmdBuildAccelerationStructuresKHR(
  VkCommandBuffer commandBuffer, 
  uint infoCount, 
  VkAccelerationStructureBuildGeometryInfoKHR * pInfos, 
  VkAccelerationStructureBuildRangeInfoKHR ** ppBuildRangeInfos)
@extern("vkCmdBuildAccelerationStructuresKHR");

fn void cmdBuildAccelerationStructuresIndirectKHR(
  VkCommandBuffer commandBuffer, 
  uint infoCount, 
  VkAccelerationStructureBuildGeometryInfoKHR * pInfos, 
  VkDeviceAddress * pIndirectDeviceAddresses, 
  uint * pIndirectStrides, 
  uint ** ppMaxPrimitiveCounts)
@extern("vkCmdBuildAccelerationStructuresIndirectKHR");

fn VkResult buildAccelerationStructuresKHR(
  VkDevice device, 
  VkDeferredOperationKHR deferredOperation, 
  uint infoCount, 
  VkAccelerationStructureBuildGeometryInfoKHR * pInfos, 
  VkAccelerationStructureBuildRangeInfoKHR ** ppBuildRangeInfos)
@extern("vkBuildAccelerationStructuresKHR");

fn VkResult copyAccelerationStructureKHR(
  VkDevice device, 
  VkDeferredOperationKHR deferredOperation, 
  VkCopyAccelerationStructureInfoKHR * pInfo)
@extern("vkCopyAccelerationStructureKHR");

fn VkResult copyAccelerationStructureToMemoryKHR(
  VkDevice device, 
  VkDeferredOperationKHR deferredOperation, 
  VkCopyAccelerationStructureToMemoryInfoKHR * pInfo)
@extern("vkCopyAccelerationStructureToMemoryKHR");

fn VkResult copyMemoryToAccelerationStructureKHR(
  VkDevice device, 
  VkDeferredOperationKHR deferredOperation, 
  VkCopyMemoryToAccelerationStructureInfoKHR * pInfo)
@extern("vkCopyMemoryToAccelerationStructureKHR");

fn VkResult writeAccelerationStructuresPropertiesKHR(
  VkDevice device, 
  uint accelerationStructureCount, 
  VkAccelerationStructureKHR * pAccelerationStructures, 
  VkQueryType queryType, 
  usz dataSize, 
  void * pData, 
  usz stride)
@extern("vkWriteAccelerationStructuresPropertiesKHR");

fn void cmdCopyAccelerationStructureKHR(
  VkCommandBuffer commandBuffer, 
  VkCopyAccelerationStructureInfoKHR * pInfo)
@extern("vkCmdCopyAccelerationStructureKHR");

fn void cmdCopyAccelerationStructureToMemoryKHR(
  VkCommandBuffer commandBuffer, 
  VkCopyAccelerationStructureToMemoryInfoKHR * pInfo)
@extern("vkCmdCopyAccelerationStructureToMemoryKHR");

fn void cmdCopyMemoryToAccelerationStructureKHR(
  VkCommandBuffer commandBuffer, 
  VkCopyMemoryToAccelerationStructureInfoKHR * pInfo)
@extern("vkCmdCopyMemoryToAccelerationStructureKHR");

fn VkDeviceAddress getAccelerationStructureDeviceAddressKHR(
  VkDevice device, 
  VkAccelerationStructureDeviceAddressInfoKHR * pInfo)
@extern("vkGetAccelerationStructureDeviceAddressKHR");

fn void cmdWriteAccelerationStructuresPropertiesKHR(
  VkCommandBuffer commandBuffer, 
  uint accelerationStructureCount, 
  VkAccelerationStructureKHR * pAccelerationStructures, 
  VkQueryType queryType, 
  VkQueryPool queryPool, 
  uint firstQuery)
@extern("vkCmdWriteAccelerationStructuresPropertiesKHR");

fn void getDeviceAccelerationStructureCompatibilityKHR(
  VkDevice device, 
  VkAccelerationStructureVersionInfoKHR * pVersionInfo, 
  VkAccelerationStructureCompatibilityKHR * pCompatibility)
@extern("vkGetDeviceAccelerationStructureCompatibilityKHR");

fn void getAccelerationStructureBuildSizesKHR(
  VkDevice device, 
  VkAccelerationStructureBuildTypeKHR buildType, 
  VkAccelerationStructureBuildGeometryInfoKHR * pBuildInfo, 
  uint * pMaxPrimitiveCounts, 
  VkAccelerationStructureBuildSizesInfoKHR * pSizeInfo)
@extern("vkGetAccelerationStructureBuildSizesKHR");

typedef VkShaderGroupShaderKHR = inline CUInt;
const VkShaderGroupShaderKHR SHADER_GROUP_SHADER_GENERAL_KHR = 0;
const VkShaderGroupShaderKHR SHADER_GROUP_SHADER_CLOSEST_HIT_KHR = 1;
const VkShaderGroupShaderKHR SHADER_GROUP_SHADER_ANY_HIT_KHR = 2;
const VkShaderGroupShaderKHR SHADER_GROUP_SHADER_INTERSECTION_KHR = 3;
const VkShaderGroupShaderKHR SHADER_GROUP_SHADER_MAX_ENUM_KHR = 0x7FFFFFFF;

struct VkRayTracingShaderGroupCreateInfoKHR {
  VkStructureType sType;
  void * pNext;
  VkRayTracingShaderGroupTypeKHR type;
  uint generalShader;
  uint closestHitShader;
  uint anyHitShader;
  uint intersectionShader;
  void * pShaderGroupCaptureReplayHandle;
}

struct VkRayTracingPipelineInterfaceCreateInfoKHR {
  VkStructureType sType;
  void * pNext;
  uint maxPipelineRayPayloadSize;
  uint maxPipelineRayHitAttributeSize;
}

struct VkRayTracingPipelineCreateInfoKHR {
  VkStructureType sType;
  void * pNext;
  VkPipelineCreateFlags flags;
  uint stageCount;
  VkPipelineShaderStageCreateInfo * pStages;
  uint groupCount;
  VkRayTracingShaderGroupCreateInfoKHR * pGroups;
  uint maxPipelineRayRecursionDepth;
  VkPipelineLibraryCreateInfoKHR * pLibraryInfo;
  VkRayTracingPipelineInterfaceCreateInfoKHR * pLibraryInterface;
  VkPipelineDynamicStateCreateInfo * pDynamicState;
  VkPipelineLayout layout;
  VkPipeline basePipelineHandle;
  int basePipelineIndex;
}

struct VkPhysicalDeviceRayTracingPipelineFeaturesKHR {
  VkStructureType sType;
  void * pNext;
  VkBool32 rayTracingPipeline;
  VkBool32 rayTracingPipelineShaderGroupHandleCaptureReplay;
  VkBool32 rayTracingPipelineShaderGroupHandleCaptureReplayMixed;
  VkBool32 rayTracingPipelineTraceRaysIndirect;
  VkBool32 rayTraversalPrimitiveCulling;
}

struct VkPhysicalDeviceRayTracingPipelinePropertiesKHR {
  VkStructureType sType;
  void * pNext;
  uint shaderGroupHandleSize;
  uint maxRayRecursionDepth;
  uint maxShaderGroupStride;
  uint shaderGroupBaseAlignment;
  uint shaderGroupHandleCaptureReplaySize;
  uint maxRayDispatchInvocationCount;
  uint shaderGroupHandleAlignment;
  uint maxRayHitAttributeSize;
}

struct VkStridedDeviceAddressRegionKHR {
  VkDeviceAddress deviceAddress;
  VkDeviceSize stride;
  VkDeviceSize size;
}

struct VkTraceRaysIndirectCommandKHR {
  uint width;
  uint height;
  uint depth;
}

alias PFN_vkCmdTraceRaysKHR = fn void(
  VkCommandBuffer commandBuffer, 
  VkStridedDeviceAddressRegionKHR * pRaygenShaderBindingTable, 
  VkStridedDeviceAddressRegionKHR * pMissShaderBindingTable, 
  VkStridedDeviceAddressRegionKHR * pHitShaderBindingTable, 
  VkStridedDeviceAddressRegionKHR * pCallableShaderBindingTable, 
  uint width, 
  uint height, 
  uint depth);

alias PFN_vkCreateRayTracingPipelinesKHR = fn VkResult(
  VkDevice device, 
  VkDeferredOperationKHR deferredOperation, 
  VkPipelineCache pipelineCache, 
  uint createInfoCount, 
  VkRayTracingPipelineCreateInfoKHR * pCreateInfos, 
  VkAllocationCallbacks * pAllocator, 
  VkPipeline * pPipelines);

alias PFN_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR = fn VkResult(
  VkDevice device, 
  VkPipeline pipeline, 
  uint firstGroup, 
  uint groupCount, 
  usz dataSize, 
  void * pData);

alias PFN_vkCmdTraceRaysIndirectKHR = fn void(
  VkCommandBuffer commandBuffer, 
  VkStridedDeviceAddressRegionKHR * pRaygenShaderBindingTable, 
  VkStridedDeviceAddressRegionKHR * pMissShaderBindingTable, 
  VkStridedDeviceAddressRegionKHR * pHitShaderBindingTable, 
  VkStridedDeviceAddressRegionKHR * pCallableShaderBindingTable, 
  VkDeviceAddress indirectDeviceAddress);

alias PFN_vkGetRayTracingShaderGroupStackSizeKHR = fn VkDeviceSize(
  VkDevice device, 
  VkPipeline pipeline, 
  uint group, 
  VkShaderGroupShaderKHR groupShader);

alias PFN_vkCmdSetRayTracingPipelineStackSizeKHR = fn void(
  VkCommandBuffer commandBuffer, 
  uint pipelineStackSize);

fn void cmdTraceRaysKHR(
  VkCommandBuffer commandBuffer, 
  VkStridedDeviceAddressRegionKHR * pRaygenShaderBindingTable, 
  VkStridedDeviceAddressRegionKHR * pMissShaderBindingTable, 
  VkStridedDeviceAddressRegionKHR * pHitShaderBindingTable, 
  VkStridedDeviceAddressRegionKHR * pCallableShaderBindingTable, 
  uint width, 
  uint height, 
  uint depth)
@extern("vkCmdTraceRaysKHR");

fn VkResult createRayTracingPipelinesKHR(
  VkDevice device, 
  VkDeferredOperationKHR deferredOperation, 
  VkPipelineCache pipelineCache, 
  uint createInfoCount, 
  VkRayTracingPipelineCreateInfoKHR * pCreateInfos, 
  VkAllocationCallbacks * pAllocator, 
  VkPipeline * pPipelines)
@extern("vkCreateRayTracingPipelinesKHR");

fn VkResult getRayTracingCaptureReplayShaderGroupHandlesKHR(
  VkDevice device, 
  VkPipeline pipeline, 
  uint firstGroup, 
  uint groupCount, 
  usz dataSize, 
  void * pData)
@extern("vkGetRayTracingCaptureReplayShaderGroupHandlesKHR");

fn void cmdTraceRaysIndirectKHR(
  VkCommandBuffer commandBuffer, 
  VkStridedDeviceAddressRegionKHR * pRaygenShaderBindingTable, 
  VkStridedDeviceAddressRegionKHR * pMissShaderBindingTable, 
  VkStridedDeviceAddressRegionKHR * pHitShaderBindingTable, 
  VkStridedDeviceAddressRegionKHR * pCallableShaderBindingTable, 
  VkDeviceAddress indirectDeviceAddress)
@extern("vkCmdTraceRaysIndirectKHR");

fn VkDeviceSize getRayTracingShaderGroupStackSizeKHR(
  VkDevice device, 
  VkPipeline pipeline, 
  uint group, 
  VkShaderGroupShaderKHR groupShader)
@extern("vkGetRayTracingShaderGroupStackSizeKHR");

fn void cmdSetRayTracingPipelineStackSizeKHR(
  VkCommandBuffer commandBuffer, 
  uint pipelineStackSize)
@extern("vkCmdSetRayTracingPipelineStackSizeKHR");

struct VkPhysicalDeviceRayQueryFeaturesKHR {
  VkStructureType sType;
  void * pNext;
  VkBool32 rayQuery;
}

typedef ANativeWindow = void;

alias VkAndroidSurfaceCreateFlagsKHR @if($defined(env::VK_USE_PLATFORM_ANDROID_KHR) &&& env::VK_USE_PLATFORM_ANDROID_KHR) = VkFlags;

struct VkAndroidSurfaceCreateInfoKHR @if($defined(env::VK_USE_PLATFORM_ANDROID_KHR) &&& env::VK_USE_PLATFORM_ANDROID_KHR) {
  VkStructureType sType;
  void * pNext;
  VkAndroidSurfaceCreateFlagsKHR flags;
  ANativeWindow * window;
}

alias PFN_vkCreateAndroidSurfaceKHR @if($defined(env::VK_USE_PLATFORM_ANDROID_KHR) &&& env::VK_USE_PLATFORM_ANDROID_KHR) = fn VkResult(
  VkInstance instance, 
  VkAndroidSurfaceCreateInfoKHR * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkSurfaceKHR * pSurface);

fn VkResult createAndroidSurfaceKHR(
  VkInstance instance, 
  VkAndroidSurfaceCreateInfoKHR * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkSurfaceKHR * pSurface)
@extern("vkCreateAndroidSurfaceKHR") @if($defined(env::VK_USE_PLATFORM_ANDROID_KHR) &&& env::VK_USE_PLATFORM_ANDROID_KHR);

typedef AHardwareBuffer = void;

struct VkAndroidHardwareBufferUsageANDROID @if($defined(env::VK_USE_PLATFORM_ANDROID_KHR) &&& env::VK_USE_PLATFORM_ANDROID_KHR) {
  VkStructureType sType;
  void * pNext;
  ulong androidHardwareBufferUsage;
}

struct VkAndroidHardwareBufferPropertiesANDROID @if($defined(env::VK_USE_PLATFORM_ANDROID_KHR) &&& env::VK_USE_PLATFORM_ANDROID_KHR) {
  VkStructureType sType;
  void * pNext;
  VkDeviceSize allocationSize;
  uint memoryTypeBits;
}

struct VkAndroidHardwareBufferFormatPropertiesANDROID @if($defined(env::VK_USE_PLATFORM_ANDROID_KHR) &&& env::VK_USE_PLATFORM_ANDROID_KHR) {
  VkStructureType sType;
  void * pNext;
  VkFormat format;
  ulong externalFormat;
  VkFormatFeatureFlags formatFeatures;
  VkComponentMapping samplerYcbcrConversionComponents;
  VkSamplerYcbcrModelConversion suggestedYcbcrModel;
  VkSamplerYcbcrRange suggestedYcbcrRange;
  VkChromaLocation suggestedXChromaOffset;
  VkChromaLocation suggestedYChromaOffset;
}

struct VkImportAndroidHardwareBufferInfoANDROID @if($defined(env::VK_USE_PLATFORM_ANDROID_KHR) &&& env::VK_USE_PLATFORM_ANDROID_KHR) {
  VkStructureType sType;
  void * pNext;
  AHardwareBuffer * buffer;
}

struct VkMemoryGetAndroidHardwareBufferInfoANDROID @if($defined(env::VK_USE_PLATFORM_ANDROID_KHR) &&& env::VK_USE_PLATFORM_ANDROID_KHR) {
  VkStructureType sType;
  void * pNext;
  VkDeviceMemory memory;
}

struct VkExternalFormatANDROID {
  VkStructureType sType;
  void * pNext;
  ulong externalFormat;
}

struct VkAndroidHardwareBufferFormatProperties2ANDROID @if($defined(env::VK_USE_PLATFORM_ANDROID_KHR) &&& env::VK_USE_PLATFORM_ANDROID_KHR) {
  VkStructureType sType;
  void * pNext;
  VkFormat format;
  ulong externalFormat;
  VkFormatFeatureFlags2KHR formatFeatures;
  VkComponentMapping samplerYcbcrConversionComponents;
  VkSamplerYcbcrModelConversion suggestedYcbcrModel;
  VkSamplerYcbcrRange suggestedYcbcrRange;
  VkChromaLocation suggestedXChromaOffset;
  VkChromaLocation suggestedYChromaOffset;
}

alias PFN_vkGetAndroidHardwareBufferPropertiesANDROID @if($defined(env::VK_USE_PLATFORM_ANDROID_KHR) &&& env::VK_USE_PLATFORM_ANDROID_KHR) = fn VkResult(
  VkDevice device, 
  AHardwareBuffer * buffer, 
  VkAndroidHardwareBufferPropertiesANDROID * pProperties);

alias PFN_vkGetMemoryAndroidHardwareBufferANDROID @if($defined(env::VK_USE_PLATFORM_ANDROID_KHR) &&& env::VK_USE_PLATFORM_ANDROID_KHR) = fn VkResult(
  VkDevice device, 
  VkMemoryGetAndroidHardwareBufferInfoANDROID * pInfo, 
  AHardwareBuffer ** pBuffer);

fn VkResult getAndroidHardwareBufferPropertiesANDROID(
  VkDevice device, 
  AHardwareBuffer * buffer, 
  VkAndroidHardwareBufferPropertiesANDROID * pProperties)
@extern("vkGetAndroidHardwareBufferPropertiesANDROID") @if($defined(env::VK_USE_PLATFORM_ANDROID_KHR) &&& env::VK_USE_PLATFORM_ANDROID_KHR);

fn VkResult getMemoryAndroidHardwareBufferANDROID(
  VkDevice device, 
  VkMemoryGetAndroidHardwareBufferInfoANDROID * pInfo, 
  AHardwareBuffer ** pBuffer)
@extern("vkGetMemoryAndroidHardwareBufferANDROID") @if($defined(env::VK_USE_PLATFORM_ANDROID_KHR) &&& env::VK_USE_PLATFORM_ANDROID_KHR);

alias VkImagePipeSurfaceCreateFlagsFUCHSIA @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) = VkFlags;

struct VkImagePipeSurfaceCreateInfoFUCHSIA @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) {
  VkStructureType sType;
  void * pNext;
  VkImagePipeSurfaceCreateFlagsFUCHSIA flags;
  Zx_handle_t imagePipeHandle;
}

alias PFN_vkCreateImagePipeSurfaceFUCHSIA @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) = fn VkResult(
  VkInstance instance, 
  VkImagePipeSurfaceCreateInfoFUCHSIA * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkSurfaceKHR * pSurface);

fn VkResult createImagePipeSurfaceFUCHSIA(
  VkInstance instance, 
  VkImagePipeSurfaceCreateInfoFUCHSIA * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkSurfaceKHR * pSurface)
@extern("vkCreateImagePipeSurfaceFUCHSIA") @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA);

struct VkImportMemoryZirconHandleInfoFUCHSIA @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) {
  VkStructureType sType;
  void * pNext;
  VkExternalMemoryHandleTypeFlagBits handleType;
  Zx_handle_t handle;
}

struct VkMemoryZirconHandlePropertiesFUCHSIA @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) {
  VkStructureType sType;
  void * pNext;
  uint memoryTypeBits;
}

struct VkMemoryGetZirconHandleInfoFUCHSIA @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) {
  VkStructureType sType;
  void * pNext;
  VkDeviceMemory memory;
  VkExternalMemoryHandleTypeFlagBits handleType;
}

alias PFN_vkGetMemoryZirconHandleFUCHSIA @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) = fn VkResult(
  VkDevice device, 
  VkMemoryGetZirconHandleInfoFUCHSIA * pGetZirconHandleInfo, 
  Zx_handle_t * pZirconHandle);

alias PFN_vkGetMemoryZirconHandlePropertiesFUCHSIA @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) = fn VkResult(
  VkDevice device, 
  VkExternalMemoryHandleTypeFlagBits handleType, 
  Zx_handle_t zirconHandle, 
  VkMemoryZirconHandlePropertiesFUCHSIA * pMemoryZirconHandleProperties);

fn VkResult getMemoryZirconHandleFUCHSIA(
  VkDevice device, 
  VkMemoryGetZirconHandleInfoFUCHSIA * pGetZirconHandleInfo, 
  Zx_handle_t * pZirconHandle)
@extern("vkGetMemoryZirconHandleFUCHSIA") @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA);

fn VkResult getMemoryZirconHandlePropertiesFUCHSIA(
  VkDevice device, 
  VkExternalMemoryHandleTypeFlagBits handleType, 
  Zx_handle_t zirconHandle, 
  VkMemoryZirconHandlePropertiesFUCHSIA * pMemoryZirconHandleProperties)
@extern("vkGetMemoryZirconHandlePropertiesFUCHSIA") @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA);

struct VkImportSemaphoreZirconHandleInfoFUCHSIA @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) {
  VkStructureType sType;
  void * pNext;
  VkSemaphore semaphore;
  VkSemaphoreImportFlags flags;
  VkExternalSemaphoreHandleTypeFlagBits handleType;
  Zx_handle_t zirconHandle;
}

struct VkSemaphoreGetZirconHandleInfoFUCHSIA @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) {
  VkStructureType sType;
  void * pNext;
  VkSemaphore semaphore;
  VkExternalSemaphoreHandleTypeFlagBits handleType;
}

alias PFN_vkImportSemaphoreZirconHandleFUCHSIA @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) = fn VkResult(
  VkDevice device, 
  VkImportSemaphoreZirconHandleInfoFUCHSIA * pImportSemaphoreZirconHandleInfo);

alias PFN_vkGetSemaphoreZirconHandleFUCHSIA @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) = fn VkResult(
  VkDevice device, 
  VkSemaphoreGetZirconHandleInfoFUCHSIA * pGetZirconHandleInfo, 
  Zx_handle_t * pZirconHandle);

fn VkResult importSemaphoreZirconHandleFUCHSIA(
  VkDevice device, 
  VkImportSemaphoreZirconHandleInfoFUCHSIA * pImportSemaphoreZirconHandleInfo)
@extern("vkImportSemaphoreZirconHandleFUCHSIA") @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA);

fn VkResult getSemaphoreZirconHandleFUCHSIA(
  VkDevice device, 
  VkSemaphoreGetZirconHandleInfoFUCHSIA * pGetZirconHandleInfo, 
  Zx_handle_t * pZirconHandle)
@extern("vkGetSemaphoreZirconHandleFUCHSIA") @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA);

typedef VkBufferCollectionFUCHSIA_T @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) = void;

alias VkBufferCollectionFUCHSIA @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) = VkBufferCollectionFUCHSIA_T *;

alias VkImageFormatConstraintsFlagsFUCHSIA @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) = VkFlags;

typedef VkImageConstraintsInfoFlagBitsFUCHSIA @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) = inline CUInt;
const VkImageConstraintsInfoFlagBitsFUCHSIA IMAGE_CONSTRAINTS_INFO_CPU_READ_RARELY_FUCHSIA @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) = 0x00000001;
const VkImageConstraintsInfoFlagBitsFUCHSIA IMAGE_CONSTRAINTS_INFO_CPU_READ_OFTEN_FUCHSIA @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) = 0x00000002;
const VkImageConstraintsInfoFlagBitsFUCHSIA IMAGE_CONSTRAINTS_INFO_CPU_WRITE_RARELY_FUCHSIA @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) = 0x00000004;
const VkImageConstraintsInfoFlagBitsFUCHSIA IMAGE_CONSTRAINTS_INFO_CPU_WRITE_OFTEN_FUCHSIA @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) = 0x00000008;
const VkImageConstraintsInfoFlagBitsFUCHSIA IMAGE_CONSTRAINTS_INFO_PROTECTED_OPTIONAL_FUCHSIA @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) = 0x00000010;
const VkImageConstraintsInfoFlagBitsFUCHSIA IMAGE_CONSTRAINTS_INFO_FLAG_BITS_MAX_ENUM_FUCHSIA @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) = 0x7FFFFFFF;

alias VkImageConstraintsInfoFlagsFUCHSIA @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) = VkFlags;

struct VkBufferCollectionCreateInfoFUCHSIA @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) {
  VkStructureType sType;
  void * pNext;
  Zx_handle_t collectionToken;
}

struct VkImportMemoryBufferCollectionFUCHSIA @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) {
  VkStructureType sType;
  void * pNext;
  VkBufferCollectionFUCHSIA collection;
  uint index;
}

struct VkBufferCollectionImageCreateInfoFUCHSIA @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) {
  VkStructureType sType;
  void * pNext;
  VkBufferCollectionFUCHSIA collection;
  uint index;
}

struct VkBufferCollectionConstraintsInfoFUCHSIA @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) {
  VkStructureType sType;
  void * pNext;
  uint minBufferCount;
  uint maxBufferCount;
  uint minBufferCountForCamping;
  uint minBufferCountForDedicatedSlack;
  uint minBufferCountForSharedSlack;
}

struct VkBufferConstraintsInfoFUCHSIA @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) {
  VkStructureType sType;
  void * pNext;
  VkBufferCreateInfo createInfo;
  VkFormatFeatureFlags requiredFormatFeatures;
  VkBufferCollectionConstraintsInfoFUCHSIA bufferCollectionConstraints;
}

struct VkBufferCollectionBufferCreateInfoFUCHSIA @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) {
  VkStructureType sType;
  void * pNext;
  VkBufferCollectionFUCHSIA collection;
  uint index;
}

struct VkSysmemColorSpaceFUCHSIA @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) {
  VkStructureType sType;
  void * pNext;
  uint colorSpace;
}

struct VkBufferCollectionPropertiesFUCHSIA @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) {
  VkStructureType sType;
  void * pNext;
  uint memoryTypeBits;
  uint bufferCount;
  uint createInfoIndex;
  ulong sysmemPixelFormat;
  VkFormatFeatureFlags formatFeatures;
  VkSysmemColorSpaceFUCHSIA sysmemColorSpaceIndex;
  VkComponentMapping samplerYcbcrConversionComponents;
  VkSamplerYcbcrModelConversion suggestedYcbcrModel;
  VkSamplerYcbcrRange suggestedYcbcrRange;
  VkChromaLocation suggestedXChromaOffset;
  VkChromaLocation suggestedYChromaOffset;
}

struct VkImageFormatConstraintsInfoFUCHSIA @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) {
  VkStructureType sType;
  void * pNext;
  VkImageCreateInfo imageCreateInfo;
  VkFormatFeatureFlags requiredFormatFeatures;
  VkImageFormatConstraintsFlagsFUCHSIA flags;
  ulong sysmemPixelFormat;
  uint colorSpaceCount;
  VkSysmemColorSpaceFUCHSIA * pColorSpaces;
}

struct VkImageConstraintsInfoFUCHSIA @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) {
  VkStructureType sType;
  void * pNext;
  uint formatConstraintsCount;
  VkImageFormatConstraintsInfoFUCHSIA * pFormatConstraints;
  VkBufferCollectionConstraintsInfoFUCHSIA bufferCollectionConstraints;
  VkImageConstraintsInfoFlagsFUCHSIA flags;
}

alias PFN_vkCreateBufferCollectionFUCHSIA @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) = fn VkResult(
  VkDevice device, 
  VkBufferCollectionCreateInfoFUCHSIA * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkBufferCollectionFUCHSIA * pCollection);

alias PFN_vkSetBufferCollectionImageConstraintsFUCHSIA @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) = fn VkResult(
  VkDevice device, 
  VkBufferCollectionFUCHSIA collection, 
  VkImageConstraintsInfoFUCHSIA * pImageConstraintsInfo);

alias PFN_vkSetBufferCollectionBufferConstraintsFUCHSIA @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) = fn VkResult(
  VkDevice device, 
  VkBufferCollectionFUCHSIA collection, 
  VkBufferConstraintsInfoFUCHSIA * pBufferConstraintsInfo);

alias PFN_vkDestroyBufferCollectionFUCHSIA @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) = fn void(
  VkDevice device, 
  VkBufferCollectionFUCHSIA collection, 
  VkAllocationCallbacks * pAllocator);

alias PFN_vkGetBufferCollectionPropertiesFUCHSIA @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA) = fn VkResult(
  VkDevice device, 
  VkBufferCollectionFUCHSIA collection, 
  VkBufferCollectionPropertiesFUCHSIA * pProperties);

fn VkResult createBufferCollectionFUCHSIA(
  VkDevice device, 
  VkBufferCollectionCreateInfoFUCHSIA * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkBufferCollectionFUCHSIA * pCollection)
@extern("vkCreateBufferCollectionFUCHSIA") @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA);

fn VkResult setBufferCollectionImageConstraintsFUCHSIA(
  VkDevice device, 
  VkBufferCollectionFUCHSIA collection, 
  VkImageConstraintsInfoFUCHSIA * pImageConstraintsInfo)
@extern("vkSetBufferCollectionImageConstraintsFUCHSIA") @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA);

fn VkResult setBufferCollectionBufferConstraintsFUCHSIA(
  VkDevice device, 
  VkBufferCollectionFUCHSIA collection, 
  VkBufferConstraintsInfoFUCHSIA * pBufferConstraintsInfo)
@extern("vkSetBufferCollectionBufferConstraintsFUCHSIA") @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA);

fn void destroyBufferCollectionFUCHSIA(
  VkDevice device, 
  VkBufferCollectionFUCHSIA collection, 
  VkAllocationCallbacks * pAllocator)
@extern("vkDestroyBufferCollectionFUCHSIA") @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA);

fn VkResult getBufferCollectionPropertiesFUCHSIA(
  VkDevice device, 
  VkBufferCollectionFUCHSIA collection, 
  VkBufferCollectionPropertiesFUCHSIA * pProperties)
@extern("vkGetBufferCollectionPropertiesFUCHSIA") @if($defined(env::VK_USE_PLATFORM_FUCHSIA) &&& env::VK_USE_PLATFORM_FUCHSIA);

alias VkIOSSurfaceCreateFlagsMVK @if($defined(env::VK_USE_PLATFORM_IOS_MVK) &&& env::VK_USE_PLATFORM_IOS_MVK) = VkFlags;

struct VkIOSSurfaceCreateInfoMVK @if($defined(env::VK_USE_PLATFORM_IOS_MVK) &&& env::VK_USE_PLATFORM_IOS_MVK) {
  VkStructureType sType;
  void * pNext;
  VkIOSSurfaceCreateFlagsMVK flags;
  void * pView;
}

alias PFN_vkCreateIOSSurfaceMVK @if($defined(env::VK_USE_PLATFORM_IOS_MVK) &&& env::VK_USE_PLATFORM_IOS_MVK) = fn VkResult(
  VkInstance instance, 
  VkIOSSurfaceCreateInfoMVK * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkSurfaceKHR * pSurface);

fn VkResult createIOSSurfaceMVK(
  VkInstance instance, 
  VkIOSSurfaceCreateInfoMVK * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkSurfaceKHR * pSurface)
@extern("vkCreateIOSSurfaceMVK") @if($defined(env::VK_USE_PLATFORM_IOS_MVK) &&& env::VK_USE_PLATFORM_IOS_MVK);

alias VkMacOSSurfaceCreateFlagsMVK @if($defined(env::VK_USE_PLATFORM_MACOS_MVK) &&& env::VK_USE_PLATFORM_MACOS_MVK) = VkFlags;

struct VkMacOSSurfaceCreateInfoMVK @if($defined(env::VK_USE_PLATFORM_MACOS_MVK) &&& env::VK_USE_PLATFORM_MACOS_MVK) {
  VkStructureType sType;
  void * pNext;
  VkMacOSSurfaceCreateFlagsMVK flags;
  void * pView;
}

alias PFN_vkCreateMacOSSurfaceMVK @if($defined(env::VK_USE_PLATFORM_MACOS_MVK) &&& env::VK_USE_PLATFORM_MACOS_MVK) = fn VkResult(
  VkInstance instance, 
  VkMacOSSurfaceCreateInfoMVK * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkSurfaceKHR * pSurface);

fn VkResult createMacOSSurfaceMVK(
  VkInstance instance, 
  VkMacOSSurfaceCreateInfoMVK * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkSurfaceKHR * pSurface)
@extern("vkCreateMacOSSurfaceMVK") @if($defined(env::VK_USE_PLATFORM_MACOS_MVK) &&& env::VK_USE_PLATFORM_MACOS_MVK);

alias CAMetalLayer @if($defined(env::VK_USE_PLATFORM_METAL_EXT) &&& env::VK_USE_PLATFORM_METAL_EXT) = void;

alias VkMetalSurfaceCreateFlagsEXT @if($defined(env::VK_USE_PLATFORM_METAL_EXT) &&& env::VK_USE_PLATFORM_METAL_EXT) = VkFlags;

struct VkMetalSurfaceCreateInfoEXT @if($defined(env::VK_USE_PLATFORM_METAL_EXT) &&& env::VK_USE_PLATFORM_METAL_EXT) {
  VkStructureType sType;
  void * pNext;
  VkMetalSurfaceCreateFlagsEXT flags;
  CAMetalLayer * pLayer;
}

alias PFN_vkCreateMetalSurfaceEXT @if($defined(env::VK_USE_PLATFORM_METAL_EXT) &&& env::VK_USE_PLATFORM_METAL_EXT) = fn VkResult(
  VkInstance instance, 
  VkMetalSurfaceCreateInfoEXT * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkSurfaceKHR * pSurface);

fn VkResult createMetalSurfaceEXT(
  VkInstance instance, 
  VkMetalSurfaceCreateInfoEXT * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkSurfaceKHR * pSurface)
@extern("vkCreateMetalSurfaceEXT") @if($defined(env::VK_USE_PLATFORM_METAL_EXT) &&& env::VK_USE_PLATFORM_METAL_EXT);

alias VkViSurfaceCreateFlagsNN @if($defined(env::VK_USE_PLATFORM_VI_NN) &&& env::VK_USE_PLATFORM_VI_NN) = VkFlags;

struct VkViSurfaceCreateInfoNN @if($defined(env::VK_USE_PLATFORM_VI_NN) &&& env::VK_USE_PLATFORM_VI_NN) {
  VkStructureType sType;
  void * pNext;
  VkViSurfaceCreateFlagsNN flags;
  void * window;
}

alias PFN_vkCreateViSurfaceNN @if($defined(env::VK_USE_PLATFORM_VI_NN) &&& env::VK_USE_PLATFORM_VI_NN) = fn VkResult(
  VkInstance instance, 
  VkViSurfaceCreateInfoNN * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkSurfaceKHR * pSurface);

fn VkResult createViSurfaceNN(
  VkInstance instance, 
  VkViSurfaceCreateInfoNN * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkSurfaceKHR * pSurface)
@extern("vkCreateViSurfaceNN") @if($defined(env::VK_USE_PLATFORM_VI_NN) &&& env::VK_USE_PLATFORM_VI_NN);

alias VkWaylandSurfaceCreateFlagsKHR @if($defined(env::VK_USE_PLATFORM_WAYLAND_KHR) &&& env::VK_USE_PLATFORM_WAYLAND_KHR) = VkFlags;

typedef WlSurface = void;

struct VkWaylandSurfaceCreateInfoKHR @if($defined(env::VK_USE_PLATFORM_WAYLAND_KHR) &&& env::VK_USE_PLATFORM_WAYLAND_KHR) {
  VkStructureType sType;
  void * pNext;
  VkWaylandSurfaceCreateFlagsKHR flags;
  WlDisplay * display;
  WlSurface * surface;
}

alias PFN_vkCreateWaylandSurfaceKHR @if($defined(env::VK_USE_PLATFORM_WAYLAND_KHR) &&& env::VK_USE_PLATFORM_WAYLAND_KHR) = fn VkResult(
  VkInstance instance, 
  VkWaylandSurfaceCreateInfoKHR * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkSurfaceKHR * pSurface);

alias PFN_vkGetPhysicalDeviceWaylandPresentationSupportKHR @if($defined(env::VK_USE_PLATFORM_WAYLAND_KHR) &&& env::VK_USE_PLATFORM_WAYLAND_KHR) = fn VkBool32(
  VkPhysicalDevice physicalDevice, 
  uint queueFamilyIndex, 
  WlDisplay * display);

fn VkResult createWaylandSurfaceKHR(
  VkInstance instance, 
  VkWaylandSurfaceCreateInfoKHR * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkSurfaceKHR * pSurface)
@extern("vkCreateWaylandSurfaceKHR") @if($defined(env::VK_USE_PLATFORM_WAYLAND_KHR) &&& env::VK_USE_PLATFORM_WAYLAND_KHR);

fn VkBool32 getPhysicalDeviceWaylandPresentationSupportKHR(
  VkPhysicalDevice physicalDevice, 
  uint queueFamilyIndex, 
  WlDisplay * display)
@extern("vkGetPhysicalDeviceWaylandPresentationSupportKHR") @if($defined(env::VK_USE_PLATFORM_WAYLAND_KHR) &&& env::VK_USE_PLATFORM_WAYLAND_KHR);

alias VkWin32SurfaceCreateFlagsKHR @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR) = VkFlags;

struct VkWin32SurfaceCreateInfoKHR @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR) {
  VkStructureType sType;
  void * pNext;
  VkWin32SurfaceCreateFlagsKHR flags;
  Hinstance hinstance;
  Hwnd hwnd;
}

alias PFN_vkCreateWin32SurfaceKHR @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR) = fn VkResult(
  VkInstance instance, 
  VkWin32SurfaceCreateInfoKHR * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkSurfaceKHR * pSurface);

alias PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR) = fn VkBool32(
  VkPhysicalDevice physicalDevice, 
  uint queueFamilyIndex);

fn VkResult createWin32SurfaceKHR(
  VkInstance instance, 
  VkWin32SurfaceCreateInfoKHR * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkSurfaceKHR * pSurface)
@extern("vkCreateWin32SurfaceKHR") @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR);

fn VkBool32 getPhysicalDeviceWin32PresentationSupportKHR(
  VkPhysicalDevice physicalDevice, 
  uint queueFamilyIndex)
@extern("vkGetPhysicalDeviceWin32PresentationSupportKHR") @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR);

struct VkImportMemoryWin32HandleInfoKHR @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR) {
  VkStructureType sType;
  void * pNext;
  VkExternalMemoryHandleTypeFlagBits handleType;
  Handle handle;
  Lpcwstr name;
}

struct VkExportMemoryWin32HandleInfoKHR @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR) {
  VkStructureType sType;
  void * pNext;
  SecurityAttributes * pAttributes;
  Dword dwAccess;
  Lpcwstr name;
}

struct VkMemoryWin32HandlePropertiesKHR @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR) {
  VkStructureType sType;
  void * pNext;
  uint memoryTypeBits;
}

struct VkMemoryGetWin32HandleInfoKHR @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR) {
  VkStructureType sType;
  void * pNext;
  VkDeviceMemory memory;
  VkExternalMemoryHandleTypeFlagBits handleType;
}

alias PFN_vkGetMemoryWin32HandleKHR @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR) = fn VkResult(
  VkDevice device, 
  VkMemoryGetWin32HandleInfoKHR * pGetWin32HandleInfo, 
  Handle * pHandle);

alias PFN_vkGetMemoryWin32HandlePropertiesKHR @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR) = fn VkResult(
  VkDevice device, 
  VkExternalMemoryHandleTypeFlagBits handleType, 
  Handle handle, 
  VkMemoryWin32HandlePropertiesKHR * pMemoryWin32HandleProperties);

fn VkResult getMemoryWin32HandleKHR(
  VkDevice device, 
  VkMemoryGetWin32HandleInfoKHR * pGetWin32HandleInfo, 
  Handle * pHandle)
@extern("vkGetMemoryWin32HandleKHR") @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR);

fn VkResult getMemoryWin32HandlePropertiesKHR(
  VkDevice device, 
  VkExternalMemoryHandleTypeFlagBits handleType, 
  Handle handle, 
  VkMemoryWin32HandlePropertiesKHR * pMemoryWin32HandleProperties)
@extern("vkGetMemoryWin32HandlePropertiesKHR") @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR);

struct VkWin32KeyedMutexAcquireReleaseInfoKHR @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR) {
  VkStructureType sType;
  void * pNext;
  uint acquireCount;
  VkDeviceMemory * pAcquireSyncs;
  ulong * pAcquireKeys;
  uint * pAcquireTimeouts;
  uint releaseCount;
  VkDeviceMemory * pReleaseSyncs;
  ulong * pReleaseKeys;
}

struct VkImportSemaphoreWin32HandleInfoKHR @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR) {
  VkStructureType sType;
  void * pNext;
  VkSemaphore semaphore;
  VkSemaphoreImportFlags flags;
  VkExternalSemaphoreHandleTypeFlagBits handleType;
  Handle handle;
  Lpcwstr name;
}

struct VkExportSemaphoreWin32HandleInfoKHR @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR) {
  VkStructureType sType;
  void * pNext;
  SecurityAttributes * pAttributes;
  Dword dwAccess;
  Lpcwstr name;
}

struct VkD3D12FenceSubmitInfoKHR {
  VkStructureType sType;
  void * pNext;
  uint waitSemaphoreValuesCount;
  ulong * pWaitSemaphoreValues;
  uint signalSemaphoreValuesCount;
  ulong * pSignalSemaphoreValues;
}

struct VkSemaphoreGetWin32HandleInfoKHR @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR) {
  VkStructureType sType;
  void * pNext;
  VkSemaphore semaphore;
  VkExternalSemaphoreHandleTypeFlagBits handleType;
}

alias PFN_vkImportSemaphoreWin32HandleKHR @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR) = fn VkResult(
  VkDevice device, 
  VkImportSemaphoreWin32HandleInfoKHR * pImportSemaphoreWin32HandleInfo);

alias PFN_vkGetSemaphoreWin32HandleKHR @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR) = fn VkResult(
  VkDevice device, 
  VkSemaphoreGetWin32HandleInfoKHR * pGetWin32HandleInfo, 
  Handle * pHandle);

fn VkResult importSemaphoreWin32HandleKHR(
  VkDevice device, 
  VkImportSemaphoreWin32HandleInfoKHR * pImportSemaphoreWin32HandleInfo)
@extern("vkImportSemaphoreWin32HandleKHR") @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR);

fn VkResult getSemaphoreWin32HandleKHR(
  VkDevice device, 
  VkSemaphoreGetWin32HandleInfoKHR * pGetWin32HandleInfo, 
  Handle * pHandle)
@extern("vkGetSemaphoreWin32HandleKHR") @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR);

struct VkImportFenceWin32HandleInfoKHR @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR) {
  VkStructureType sType;
  void * pNext;
  VkFence fence;
  VkFenceImportFlags flags;
  VkExternalFenceHandleTypeFlagBits handleType;
  Handle handle;
  Lpcwstr name;
}

struct VkExportFenceWin32HandleInfoKHR @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR) {
  VkStructureType sType;
  void * pNext;
  SecurityAttributes * pAttributes;
  Dword dwAccess;
  Lpcwstr name;
}

struct VkFenceGetWin32HandleInfoKHR @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR) {
  VkStructureType sType;
  void * pNext;
  VkFence fence;
  VkExternalFenceHandleTypeFlagBits handleType;
}

alias PFN_vkImportFenceWin32HandleKHR @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR) = fn VkResult(
  VkDevice device, 
  VkImportFenceWin32HandleInfoKHR * pImportFenceWin32HandleInfo);

alias PFN_vkGetFenceWin32HandleKHR @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR) = fn VkResult(
  VkDevice device, 
  VkFenceGetWin32HandleInfoKHR * pGetWin32HandleInfo, 
  Handle * pHandle);

fn VkResult importFenceWin32HandleKHR(
  VkDevice device, 
  VkImportFenceWin32HandleInfoKHR * pImportFenceWin32HandleInfo)
@extern("vkImportFenceWin32HandleKHR") @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR);

fn VkResult getFenceWin32HandleKHR(
  VkDevice device, 
  VkFenceGetWin32HandleInfoKHR * pGetWin32HandleInfo, 
  Handle * pHandle)
@extern("vkGetFenceWin32HandleKHR") @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR);

struct VkImportMemoryWin32HandleInfoNV @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR) {
  VkStructureType sType;
  void * pNext;
  VkExternalMemoryHandleTypeFlagsNV handleType;
  Handle handle;
}

struct VkExportMemoryWin32HandleInfoNV @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR) {
  VkStructureType sType;
  void * pNext;
  SecurityAttributes * pAttributes;
  Dword dwAccess;
}

alias PFN_vkGetMemoryWin32HandleNV @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR) = fn VkResult(
  VkDevice device, 
  VkDeviceMemory memory, 
  VkExternalMemoryHandleTypeFlagsNV handleType, 
  Handle * pHandle);

fn VkResult getMemoryWin32HandleNV(
  VkDevice device, 
  VkDeviceMemory memory, 
  VkExternalMemoryHandleTypeFlagsNV handleType, 
  Handle * pHandle)
@extern("vkGetMemoryWin32HandleNV") @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR);

struct VkWin32KeyedMutexAcquireReleaseInfoNV @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR) {
  VkStructureType sType;
  void * pNext;
  uint acquireCount;
  VkDeviceMemory * pAcquireSyncs;
  ulong * pAcquireKeys;
  uint * pAcquireTimeoutMilliseconds;
  uint releaseCount;
  VkDeviceMemory * pReleaseSyncs;
  ulong * pReleaseKeys;
}

typedef VkFullScreenExclusiveEXT = inline CUInt;
const VkFullScreenExclusiveEXT FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT = 0;
const VkFullScreenExclusiveEXT FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT = 1;
const VkFullScreenExclusiveEXT FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT = 2;
const VkFullScreenExclusiveEXT FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT = 3;
const VkFullScreenExclusiveEXT FULL_SCREEN_EXCLUSIVE_MAX_ENUM_EXT = 0x7FFFFFFF;

struct VkSurfaceFullScreenExclusiveInfoEXT {
  VkStructureType sType;
  void * pNext;
  VkFullScreenExclusiveEXT fullScreenExclusive;
}

struct VkSurfaceCapabilitiesFullScreenExclusiveEXT {
  VkStructureType sType;
  void * pNext;
  VkBool32 fullScreenExclusiveSupported;
}

struct VkSurfaceFullScreenExclusiveWin32InfoEXT @if($defined(env::VK_USE_PLATFORM_WIN32_KHR) &&& env::VK_USE_PLATFORM_WIN32_KHR) {
  VkStructureType sType;
  void * pNext;
  Hmonitor hmonitor;
}

alias PFN_vkGetPhysicalDeviceSurfacePresentModes2EXT = fn VkResult(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceSurfaceInfo2KHR * pSurfaceInfo, 
  uint * pPresentModeCount, 
  VkPresentModeKHR * pPresentModes);

alias PFN_vkAcquireFullScreenExclusiveModeEXT = fn VkResult(
  VkDevice device, 
  VkSwapchainKHR swapchain);

alias PFN_vkReleaseFullScreenExclusiveModeEXT = fn VkResult(
  VkDevice device, 
  VkSwapchainKHR swapchain);

alias PFN_vkGetDeviceGroupSurfacePresentModes2EXT = fn VkResult(
  VkDevice device, 
  VkPhysicalDeviceSurfaceInfo2KHR * pSurfaceInfo, 
  VkDeviceGroupPresentModeFlagsKHR * pModes);

fn VkResult getPhysicalDeviceSurfacePresentModes2EXT(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceSurfaceInfo2KHR * pSurfaceInfo, 
  uint * pPresentModeCount, 
  VkPresentModeKHR * pPresentModes)
@extern("vkGetPhysicalDeviceSurfacePresentModes2EXT");

fn VkResult acquireFullScreenExclusiveModeEXT(
  VkDevice device, 
  VkSwapchainKHR swapchain)
@extern("vkAcquireFullScreenExclusiveModeEXT");

fn VkResult releaseFullScreenExclusiveModeEXT(
  VkDevice device, 
  VkSwapchainKHR swapchain)
@extern("vkReleaseFullScreenExclusiveModeEXT");

fn VkResult getDeviceGroupSurfacePresentModes2EXT(
  VkDevice device, 
  VkPhysicalDeviceSurfaceInfo2KHR * pSurfaceInfo, 
  VkDeviceGroupPresentModeFlagsKHR * pModes)
@extern("vkGetDeviceGroupSurfacePresentModes2EXT");

alias VkXcbSurfaceCreateFlagsKHR @if($defined(env::VK_USE_PLATFORM_XCB_KHR) &&& env::VK_USE_PLATFORM_XCB_KHR) = VkFlags;

struct VkXcbSurfaceCreateInfoKHR @if($defined(env::VK_USE_PLATFORM_XCB_KHR) &&& env::VK_USE_PLATFORM_XCB_KHR) {
  VkStructureType sType;
  void * pNext;
  VkXcbSurfaceCreateFlagsKHR flags;
  XcbConnectionT * connection;
  XcbWindowT window;
}

alias PFN_vkCreateXcbSurfaceKHR @if($defined(env::VK_USE_PLATFORM_XCB_KHR) &&& env::VK_USE_PLATFORM_XCB_KHR) = fn VkResult(
  VkInstance instance, 
  VkXcbSurfaceCreateInfoKHR * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkSurfaceKHR * pSurface);

alias PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR @if($defined(env::VK_USE_PLATFORM_XCB_KHR) &&& env::VK_USE_PLATFORM_XCB_KHR) = fn VkBool32(
  VkPhysicalDevice physicalDevice, 
  uint queueFamilyIndex, 
  XcbConnectionT * connection, 
  XcbVisualidT visual_id);

fn VkResult createXcbSurfaceKHR(
  VkInstance instance, 
  VkXcbSurfaceCreateInfoKHR * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkSurfaceKHR * pSurface)
@extern("vkCreateXcbSurfaceKHR") @if($defined(env::VK_USE_PLATFORM_XCB_KHR) &&& env::VK_USE_PLATFORM_XCB_KHR);

fn VkBool32 getPhysicalDeviceXcbPresentationSupportKHR(
  VkPhysicalDevice physicalDevice, 
  uint queueFamilyIndex, 
  XcbConnectionT * connection, 
  XcbVisualidT visual_id)
@extern("vkGetPhysicalDeviceXcbPresentationSupportKHR") @if($defined(env::VK_USE_PLATFORM_XCB_KHR) &&& env::VK_USE_PLATFORM_XCB_KHR);

alias VkXlibSurfaceCreateFlagsKHR @if($defined(env::VK_USE_PLATFORM_XLIB_KHR) &&& env::VK_USE_PLATFORM_XLIB_KHR) = VkFlags;

struct VkXlibSurfaceCreateInfoKHR @if($defined(env::VK_USE_PLATFORM_XLIB_KHR) &&& env::VK_USE_PLATFORM_XLIB_KHR) {
  VkStructureType sType;
  void * pNext;
  VkXlibSurfaceCreateFlagsKHR flags;
  Display * dpy;
  Window window;
}

alias PFN_vkCreateXlibSurfaceKHR @if($defined(env::VK_USE_PLATFORM_XLIB_KHR) &&& env::VK_USE_PLATFORM_XLIB_KHR) = fn VkResult(
  VkInstance instance, 
  VkXlibSurfaceCreateInfoKHR * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkSurfaceKHR * pSurface);

alias PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR @if($defined(env::VK_USE_PLATFORM_XLIB_KHR) &&& env::VK_USE_PLATFORM_XLIB_KHR) = fn VkBool32(
  VkPhysicalDevice physicalDevice, 
  uint queueFamilyIndex, 
  Display * dpy, 
  VisualID visualID);

fn VkResult createXlibSurfaceKHR(
  VkInstance instance, 
  VkXlibSurfaceCreateInfoKHR * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkSurfaceKHR * pSurface)
@extern("vkCreateXlibSurfaceKHR") @if($defined(env::VK_USE_PLATFORM_XLIB_KHR) &&& env::VK_USE_PLATFORM_XLIB_KHR);

fn VkBool32 getPhysicalDeviceXlibPresentationSupportKHR(
  VkPhysicalDevice physicalDevice, 
  uint queueFamilyIndex, 
  Display * dpy, 
  VisualID visualID)
@extern("vkGetPhysicalDeviceXlibPresentationSupportKHR") @if($defined(env::VK_USE_PLATFORM_XLIB_KHR) &&& env::VK_USE_PLATFORM_XLIB_KHR);

alias VkDirectFBSurfaceCreateFlagsEXT @if($defined(env::VK_USE_PLATFORM_DIRECTFB_EXT) &&& env::VK_USE_PLATFORM_DIRECTFB_EXT) = VkFlags;

struct VkDirectFBSurfaceCreateInfoEXT @if($defined(env::VK_USE_PLATFORM_DIRECTFB_EXT) &&& env::VK_USE_PLATFORM_DIRECTFB_EXT) {
  VkStructureType sType;
  void * pNext;
  VkDirectFBSurfaceCreateFlagsEXT flags;
  IDirectFB * dfb;
  IDirectFBSurface * surface;
}

alias PFN_vkCreateDirectFBSurfaceEXT @if($defined(env::VK_USE_PLATFORM_DIRECTFB_EXT) &&& env::VK_USE_PLATFORM_DIRECTFB_EXT) = fn VkResult(
  VkInstance instance, 
  VkDirectFBSurfaceCreateInfoEXT * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkSurfaceKHR * pSurface);

alias PFN_vkGetPhysicalDeviceDirectFBPresentationSupportEXT @if($defined(env::VK_USE_PLATFORM_DIRECTFB_EXT) &&& env::VK_USE_PLATFORM_DIRECTFB_EXT) = fn VkBool32(
  VkPhysicalDevice physicalDevice, 
  uint queueFamilyIndex, 
  IDirectFB * dfb);

fn VkResult createDirectFBSurfaceEXT(
  VkInstance instance, 
  VkDirectFBSurfaceCreateInfoEXT * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkSurfaceKHR * pSurface)
@extern("vkCreateDirectFBSurfaceEXT") @if($defined(env::VK_USE_PLATFORM_DIRECTFB_EXT) &&& env::VK_USE_PLATFORM_DIRECTFB_EXT);

fn VkBool32 getPhysicalDeviceDirectFBPresentationSupportEXT(
  VkPhysicalDevice physicalDevice, 
  uint queueFamilyIndex, 
  IDirectFB * dfb)
@extern("vkGetPhysicalDeviceDirectFBPresentationSupportEXT") @if($defined(env::VK_USE_PLATFORM_DIRECTFB_EXT) &&& env::VK_USE_PLATFORM_DIRECTFB_EXT);

typedef GgpStreamDescriptor = void;

typedef GgpFrameToken = void;

alias VkStreamDescriptorSurfaceCreateFlagsGGP @if($defined(env::VK_USE_PLATFORM_GGP) &&& env::VK_USE_PLATFORM_GGP) = VkFlags;

struct VkStreamDescriptorSurfaceCreateInfoGGP @if($defined(env::VK_USE_PLATFORM_GGP) &&& env::VK_USE_PLATFORM_GGP) {
  VkStructureType sType;
  void * pNext;
  VkStreamDescriptorSurfaceCreateFlagsGGP flags;
  GgpStreamDescriptor streamDescriptor;
}

alias PFN_vkCreateStreamDescriptorSurfaceGGP @if($defined(env::VK_USE_PLATFORM_GGP) &&& env::VK_USE_PLATFORM_GGP) = fn VkResult(
  VkInstance instance, 
  VkStreamDescriptorSurfaceCreateInfoGGP * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkSurfaceKHR * pSurface);

fn VkResult createStreamDescriptorSurfaceGGP(
  VkInstance instance, 
  VkStreamDescriptorSurfaceCreateInfoGGP * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkSurfaceKHR * pSurface)
@extern("vkCreateStreamDescriptorSurfaceGGP") @if($defined(env::VK_USE_PLATFORM_GGP) &&& env::VK_USE_PLATFORM_GGP);

struct VkPresentFrameTokenGGP @if($defined(env::VK_USE_PLATFORM_GGP) &&& env::VK_USE_PLATFORM_GGP) {
  VkStructureType sType;
  void * pNext;
  GgpFrameToken frameToken;
}

alias VkScreenSurfaceCreateFlagsQNX @if($defined(env::VK_USE_PLATFORM_SCREEN_QNX) &&& env::VK_USE_PLATFORM_SCREEN_QNX) = VkFlags;

typedef _Screen_context = void;

typedef _Screen_window = void;

struct VkScreenSurfaceCreateInfoQNX @if($defined(env::VK_USE_PLATFORM_SCREEN_QNX) &&& env::VK_USE_PLATFORM_SCREEN_QNX) {
  VkStructureType sType;
  void * pNext;
  VkScreenSurfaceCreateFlagsQNX flags;
  _Screen_context * context;
  _Screen_window * window;
}

alias PFN_vkCreateScreenSurfaceQNX @if($defined(env::VK_USE_PLATFORM_SCREEN_QNX) &&& env::VK_USE_PLATFORM_SCREEN_QNX) = fn VkResult(
  VkInstance instance, 
  VkScreenSurfaceCreateInfoQNX * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkSurfaceKHR * pSurface);

alias PFN_vkGetPhysicalDeviceScreenPresentationSupportQNX @if($defined(env::VK_USE_PLATFORM_SCREEN_QNX) &&& env::VK_USE_PLATFORM_SCREEN_QNX) = fn VkBool32(
  VkPhysicalDevice physicalDevice, 
  uint queueFamilyIndex, 
  _Screen_window * window);

fn VkResult createScreenSurfaceQNX(
  VkInstance instance, 
  VkScreenSurfaceCreateInfoQNX * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkSurfaceKHR * pSurface)
@extern("vkCreateScreenSurfaceQNX") @if($defined(env::VK_USE_PLATFORM_SCREEN_QNX) &&& env::VK_USE_PLATFORM_SCREEN_QNX);

fn VkBool32 getPhysicalDeviceScreenPresentationSupportQNX(
  VkPhysicalDevice physicalDevice, 
  uint queueFamilyIndex, 
  _Screen_window * window)
@extern("vkGetPhysicalDeviceScreenPresentationSupportQNX") @if($defined(env::VK_USE_PLATFORM_SCREEN_QNX) &&& env::VK_USE_PLATFORM_SCREEN_QNX);

typedef VkVideoSessionKHR_T = void;

alias VkVideoSessionKHR = VkVideoSessionKHR_T *;

typedef VkVideoSessionParametersKHR_T = void;

alias VkVideoSessionParametersKHR = VkVideoSessionParametersKHR_T *;

typedef VkQueryResultStatusKHR = inline CInt;
const VkQueryResultStatusKHR QUERY_RESULT_STATUS_ERROR_KHR = -1;
const VkQueryResultStatusKHR QUERY_RESULT_STATUS_NOT_READY_KHR = 0;
const VkQueryResultStatusKHR QUERY_RESULT_STATUS_COMPLETE_KHR = 1;
const VkQueryResultStatusKHR QUERY_RESULT_STATUS_MAX_ENUM_KHR = 0x7FFFFFFF;

typedef VkVideoCodecOperationFlagBitsKHR = inline CUInt;
const VkVideoCodecOperationFlagBitsKHR VIDEO_CODEC_OPERATION_INVALID_BIT_KHR = 0;
const VkVideoCodecOperationFlagBitsKHR VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_EXT = 0x00010000;
const VkVideoCodecOperationFlagBitsKHR VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_EXT = 0x00020000;
const VkVideoCodecOperationFlagBitsKHR VIDEO_CODEC_OPERATION_DECODE_H264_BIT_EXT = 0x00000001;
const VkVideoCodecOperationFlagBitsKHR VIDEO_CODEC_OPERATION_DECODE_H265_BIT_EXT = 0x00000002;
const VkVideoCodecOperationFlagBitsKHR VIDEO_CODEC_OPERATION_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF;

alias VkVideoCodecOperationFlagsKHR = VkFlags;

typedef VkVideoChromaSubsamplingFlagBitsKHR = inline CUInt;
const VkVideoChromaSubsamplingFlagBitsKHR VIDEO_CHROMA_SUBSAMPLING_INVALID_BIT_KHR = 0;
const VkVideoChromaSubsamplingFlagBitsKHR VIDEO_CHROMA_SUBSAMPLING_MONOCHROME_BIT_KHR = 0x00000001;
const VkVideoChromaSubsamplingFlagBitsKHR VIDEO_CHROMA_SUBSAMPLING_420_BIT_KHR = 0x00000002;
const VkVideoChromaSubsamplingFlagBitsKHR VIDEO_CHROMA_SUBSAMPLING_422_BIT_KHR = 0x00000004;
const VkVideoChromaSubsamplingFlagBitsKHR VIDEO_CHROMA_SUBSAMPLING_444_BIT_KHR = 0x00000008;
const VkVideoChromaSubsamplingFlagBitsKHR VIDEO_CHROMA_SUBSAMPLING_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF;

alias VkVideoChromaSubsamplingFlagsKHR = VkFlags;

typedef VkVideoComponentBitDepthFlagBitsKHR = inline CUInt;
const VkVideoComponentBitDepthFlagBitsKHR VIDEO_COMPONENT_BIT_DEPTH_INVALID_KHR = 0;
const VkVideoComponentBitDepthFlagBitsKHR VIDEO_COMPONENT_BIT_DEPTH_8_BIT_KHR = 0x00000001;
const VkVideoComponentBitDepthFlagBitsKHR VIDEO_COMPONENT_BIT_DEPTH_10_BIT_KHR = 0x00000004;
const VkVideoComponentBitDepthFlagBitsKHR VIDEO_COMPONENT_BIT_DEPTH_12_BIT_KHR = 0x00000010;
const VkVideoComponentBitDepthFlagBitsKHR VIDEO_COMPONENT_BIT_DEPTH_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF;

alias VkVideoComponentBitDepthFlagsKHR = VkFlags;

typedef VkVideoCapabilityFlagBitsKHR = inline CUInt;
const VkVideoCapabilityFlagBitsKHR VIDEO_CAPABILITY_PROTECTED_CONTENT_BIT_KHR = 0x00000001;
const VkVideoCapabilityFlagBitsKHR VIDEO_CAPABILITY_SEPARATE_REFERENCE_IMAGES_BIT_KHR = 0x00000002;
const VkVideoCapabilityFlagBitsKHR VIDEO_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF;

alias VkVideoCapabilityFlagsKHR = VkFlags;

typedef VkVideoSessionCreateFlagBitsKHR = inline CUInt;
const VkVideoSessionCreateFlagBitsKHR VIDEO_SESSION_CREATE_DEFAULT_KHR = 0;
const VkVideoSessionCreateFlagBitsKHR VIDEO_SESSION_CREATE_PROTECTED_CONTENT_BIT_KHR = 0x00000001;
const VkVideoSessionCreateFlagBitsKHR VIDEO_SESSION_CREATE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF;

alias VkVideoSessionCreateFlagsKHR = VkFlags;

alias VkVideoBeginCodingFlagsKHR = VkFlags;

alias VkVideoEndCodingFlagsKHR = VkFlags;

typedef VkVideoCodingControlFlagBitsKHR = inline CUInt;
const VkVideoCodingControlFlagBitsKHR VIDEO_CODING_CONTROL_DEFAULT_KHR = 0;
const VkVideoCodingControlFlagBitsKHR VIDEO_CODING_CONTROL_RESET_BIT_KHR = 0x00000001;
const VkVideoCodingControlFlagBitsKHR VIDEO_CODING_CONTROL_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF;

alias VkVideoCodingControlFlagsKHR = VkFlags;

typedef VkVideoCodingQualityPresetFlagBitsKHR = inline CUInt;
const VkVideoCodingQualityPresetFlagBitsKHR VIDEO_CODING_QUALITY_PRESET_NORMAL_BIT_KHR = 0x00000001;
const VkVideoCodingQualityPresetFlagBitsKHR VIDEO_CODING_QUALITY_PRESET_POWER_BIT_KHR = 0x00000002;
const VkVideoCodingQualityPresetFlagBitsKHR VIDEO_CODING_QUALITY_PRESET_QUALITY_BIT_KHR = 0x00000004;
const VkVideoCodingQualityPresetFlagBitsKHR VIDEO_CODING_QUALITY_PRESET_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF;

alias VkVideoCodingQualityPresetFlagsKHR = VkFlags;

struct VkQueueFamilyQueryResultStatusProperties2KHR {
  VkStructureType sType;
  void * pNext;
  VkBool32 supported;
}

struct VkVideoQueueFamilyProperties2KHR {
  VkStructureType sType;
  void * pNext;
  VkVideoCodecOperationFlagsKHR videoCodecOperations;
}

struct VkVideoProfileKHR {
  VkStructureType sType;
  void * pNext;
  VkVideoCodecOperationFlagBitsKHR videoCodecOperation;
  VkVideoChromaSubsamplingFlagsKHR chromaSubsampling;
  VkVideoComponentBitDepthFlagsKHR lumaBitDepth;
  VkVideoComponentBitDepthFlagsKHR chromaBitDepth;
}

struct VkVideoProfilesKHR {
  VkStructureType sType;
  void * pNext;
  uint profileCount;
  VkVideoProfileKHR * pProfiles;
}

struct VkVideoCapabilitiesKHR {
  VkStructureType sType;
  void * pNext;
  VkVideoCapabilityFlagsKHR capabilityFlags;
  VkDeviceSize minBitstreamBufferOffsetAlignment;
  VkDeviceSize minBitstreamBufferSizeAlignment;
  VkExtent2D videoPictureExtentGranularity;
  VkExtent2D minExtent;
  VkExtent2D maxExtent;
  uint maxReferencePicturesSlotsCount;
  uint maxReferencePicturesActiveCount;
}

struct VkPhysicalDeviceVideoFormatInfoKHR {
  VkStructureType sType;
  void * pNext;
  VkImageUsageFlags imageUsage;
  VkVideoProfilesKHR * pVideoProfiles;
}

struct VkVideoFormatPropertiesKHR {
  VkStructureType sType;
  void * pNext;
  VkFormat format;
}

struct VkVideoPictureResourceKHR {
  VkStructureType sType;
  void * pNext;
  VkOffset2D codedOffset;
  VkExtent2D codedExtent;
  uint baseArrayLayer;
  VkImageView imageViewBinding;
}

struct VkVideoReferenceSlotKHR {
  VkStructureType sType;
  void * pNext;
  ichar slotIndex;
  VkVideoPictureResourceKHR * pPictureResource;
}

struct VkVideoGetMemoryPropertiesKHR {
  VkStructureType sType;
  void * pNext;
  uint memoryBindIndex;
  VkMemoryRequirements2 * pMemoryRequirements;
}

struct VkVideoBindMemoryKHR {
  VkStructureType sType;
  void * pNext;
  uint memoryBindIndex;
  VkDeviceMemory memory;
  VkDeviceSize memoryOffset;
  VkDeviceSize memorySize;
}

struct VkVideoSessionCreateInfoKHR {
  VkStructureType sType;
  void * pNext;
  uint queueFamilyIndex;
  VkVideoSessionCreateFlagsKHR flags;
  VkVideoProfileKHR * pVideoProfile;
  VkFormat pictureFormat;
  VkExtent2D maxCodedExtent;
  VkFormat referencePicturesFormat;
  uint maxReferencePicturesSlotsCount;
  uint maxReferencePicturesActiveCount;
}

struct VkVideoSessionParametersCreateInfoKHR {
  VkStructureType sType;
  void * pNext;
  VkVideoSessionParametersKHR videoSessionParametersTemplate;
  VkVideoSessionKHR videoSession;
}

struct VkVideoSessionParametersUpdateInfoKHR {
  VkStructureType sType;
  void * pNext;
  uint updateSequenceCount;
}

struct VkVideoBeginCodingInfoKHR {
  VkStructureType sType;
  void * pNext;
  VkVideoBeginCodingFlagsKHR flags;
  VkVideoCodingQualityPresetFlagsKHR codecQualityPreset;
  VkVideoSessionKHR videoSession;
  VkVideoSessionParametersKHR videoSessionParameters;
  uint referenceSlotCount;
  VkVideoReferenceSlotKHR * pReferenceSlots;
}

struct VkVideoEndCodingInfoKHR {
  VkStructureType sType;
  void * pNext;
  VkVideoEndCodingFlagsKHR flags;
}

struct VkVideoCodingControlInfoKHR {
  VkStructureType sType;
  void * pNext;
  VkVideoCodingControlFlagsKHR flags;
}

alias PFN_vkGetPhysicalDeviceVideoCapabilitiesKHR = fn VkResult(
  VkPhysicalDevice physicalDevice, 
  VkVideoProfileKHR * pVideoProfile, 
  VkVideoCapabilitiesKHR * pCapabilities);

alias PFN_vkGetPhysicalDeviceVideoFormatPropertiesKHR = fn VkResult(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceVideoFormatInfoKHR * pVideoFormatInfo, 
  uint * pVideoFormatPropertyCount, 
  VkVideoFormatPropertiesKHR * pVideoFormatProperties);

alias PFN_vkCreateVideoSessionKHR = fn VkResult(
  VkDevice device, 
  VkVideoSessionCreateInfoKHR * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkVideoSessionKHR * pVideoSession);

alias PFN_vkDestroyVideoSessionKHR = fn void(
  VkDevice device, 
  VkVideoSessionKHR videoSession, 
  VkAllocationCallbacks * pAllocator);

alias PFN_vkGetVideoSessionMemoryRequirementsKHR = fn VkResult(
  VkDevice device, 
  VkVideoSessionKHR videoSession, 
  uint * pVideoSessionMemoryRequirementsCount, 
  VkVideoGetMemoryPropertiesKHR * pVideoSessionMemoryRequirements);

alias PFN_vkBindVideoSessionMemoryKHR = fn VkResult(
  VkDevice device, 
  VkVideoSessionKHR videoSession, 
  uint videoSessionBindMemoryCount, 
  VkVideoBindMemoryKHR * pVideoSessionBindMemories);

alias PFN_vkCreateVideoSessionParametersKHR = fn VkResult(
  VkDevice device, 
  VkVideoSessionParametersCreateInfoKHR * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkVideoSessionParametersKHR * pVideoSessionParameters);

alias PFN_vkUpdateVideoSessionParametersKHR = fn VkResult(
  VkDevice device, 
  VkVideoSessionParametersKHR videoSessionParameters, 
  VkVideoSessionParametersUpdateInfoKHR * pUpdateInfo);

alias PFN_vkDestroyVideoSessionParametersKHR = fn void(
  VkDevice device, 
  VkVideoSessionParametersKHR videoSessionParameters, 
  VkAllocationCallbacks * pAllocator);

alias PFN_vkCmdBeginVideoCodingKHR = fn void(
  VkCommandBuffer commandBuffer, 
  VkVideoBeginCodingInfoKHR * pBeginInfo);

alias PFN_vkCmdEndVideoCodingKHR = fn void(
  VkCommandBuffer commandBuffer, 
  VkVideoEndCodingInfoKHR * pEndCodingInfo);

alias PFN_vkCmdControlVideoCodingKHR = fn void(
  VkCommandBuffer commandBuffer, 
  VkVideoCodingControlInfoKHR * pCodingControlInfo);

fn VkResult getPhysicalDeviceVideoCapabilitiesKHR(
  VkPhysicalDevice physicalDevice, 
  VkVideoProfileKHR * pVideoProfile, 
  VkVideoCapabilitiesKHR * pCapabilities)
@extern("vkGetPhysicalDeviceVideoCapabilitiesKHR");

fn VkResult getPhysicalDeviceVideoFormatPropertiesKHR(
  VkPhysicalDevice physicalDevice, 
  VkPhysicalDeviceVideoFormatInfoKHR * pVideoFormatInfo, 
  uint * pVideoFormatPropertyCount, 
  VkVideoFormatPropertiesKHR * pVideoFormatProperties)
@extern("vkGetPhysicalDeviceVideoFormatPropertiesKHR");

fn VkResult createVideoSessionKHR(
  VkDevice device, 
  VkVideoSessionCreateInfoKHR * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkVideoSessionKHR * pVideoSession)
@extern("vkCreateVideoSessionKHR");

fn void destroyVideoSessionKHR(
  VkDevice device, 
  VkVideoSessionKHR videoSession, 
  VkAllocationCallbacks * pAllocator)
@extern("vkDestroyVideoSessionKHR");

fn VkResult getVideoSessionMemoryRequirementsKHR(
  VkDevice device, 
  VkVideoSessionKHR videoSession, 
  uint * pVideoSessionMemoryRequirementsCount, 
  VkVideoGetMemoryPropertiesKHR * pVideoSessionMemoryRequirements)
@extern("vkGetVideoSessionMemoryRequirementsKHR");

fn VkResult bindVideoSessionMemoryKHR(
  VkDevice device, 
  VkVideoSessionKHR videoSession, 
  uint videoSessionBindMemoryCount, 
  VkVideoBindMemoryKHR * pVideoSessionBindMemories)
@extern("vkBindVideoSessionMemoryKHR");

fn VkResult createVideoSessionParametersKHR(
  VkDevice device, 
  VkVideoSessionParametersCreateInfoKHR * pCreateInfo, 
  VkAllocationCallbacks * pAllocator, 
  VkVideoSessionParametersKHR * pVideoSessionParameters)
@extern("vkCreateVideoSessionParametersKHR");

fn VkResult updateVideoSessionParametersKHR(
  VkDevice device, 
  VkVideoSessionParametersKHR videoSessionParameters, 
  VkVideoSessionParametersUpdateInfoKHR * pUpdateInfo)
@extern("vkUpdateVideoSessionParametersKHR");

fn void destroyVideoSessionParametersKHR(
  VkDevice device, 
  VkVideoSessionParametersKHR videoSessionParameters, 
  VkAllocationCallbacks * pAllocator)
@extern("vkDestroyVideoSessionParametersKHR");

fn void cmdBeginVideoCodingKHR(
  VkCommandBuffer commandBuffer, 
  VkVideoBeginCodingInfoKHR * pBeginInfo)
@extern("vkCmdBeginVideoCodingKHR");

fn void cmdEndVideoCodingKHR(
  VkCommandBuffer commandBuffer, 
  VkVideoEndCodingInfoKHR * pEndCodingInfo)
@extern("vkCmdEndVideoCodingKHR");

fn void cmdControlVideoCodingKHR(
  VkCommandBuffer commandBuffer, 
  VkVideoCodingControlInfoKHR * pCodingControlInfo)
@extern("vkCmdControlVideoCodingKHR");

typedef VkVideoDecodeFlagBitsKHR = inline CUInt;
const VkVideoDecodeFlagBitsKHR VIDEO_DECODE_DEFAULT_KHR = 0;
const VkVideoDecodeFlagBitsKHR VIDEO_DECODE_RESERVED_0_BIT_KHR = 0x00000001;
const VkVideoDecodeFlagBitsKHR VIDEO_DECODE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF;

alias VkVideoDecodeFlagsKHR = VkFlags;

struct VkVideoDecodeInfoKHR {
  VkStructureType sType;
  void * pNext;
  VkVideoDecodeFlagsKHR flags;
  VkOffset2D codedOffset;
  VkExtent2D codedExtent;
  VkBuffer srcBuffer;
  VkDeviceSize srcBufferOffset;
  VkDeviceSize srcBufferRange;
  VkVideoPictureResourceKHR dstPictureResource;
  VkVideoReferenceSlotKHR * pSetupReferenceSlot;
  uint referenceSlotCount;
  VkVideoReferenceSlotKHR * pReferenceSlots;
}

alias PFN_vkCmdDecodeVideoKHR = fn void(
  VkCommandBuffer commandBuffer, 
  VkVideoDecodeInfoKHR * pFrameInfo);

fn void cmdDecodeVideoKHR(
  VkCommandBuffer commandBuffer, 
  VkVideoDecodeInfoKHR * pFrameInfo)
@extern("vkCmdDecodeVideoKHR");

struct VkPhysicalDevicePortabilitySubsetFeaturesKHR {
  VkStructureType sType;
  void * pNext;
  VkBool32 constantAlphaColorBlendFactors;
  VkBool32 events;
  VkBool32 imageViewFormatReinterpretation;
  VkBool32 imageViewFormatSwizzle;
  VkBool32 imageView2DOn3DImage;
  VkBool32 multisampleArrayImage;
  VkBool32 mutableComparisonSamplers;
  VkBool32 pointPolygons;
  VkBool32 samplerMipLodBias;
  VkBool32 separateStencilMaskRef;
  VkBool32 shaderSampleRateInterpolationFunctions;
  VkBool32 tessellationIsolines;
  VkBool32 tessellationPointMode;
  VkBool32 triangleFans;
  VkBool32 vertexAttributeAccessBeyondStride;
}

struct VkPhysicalDevicePortabilitySubsetPropertiesKHR {
  VkStructureType sType;
  void * pNext;
  uint minVertexInputBindingStrideAlignment;
}

typedef VkVideoEncodeFlagBitsKHR = inline CUInt;
const VkVideoEncodeFlagBitsKHR VIDEO_ENCODE_DEFAULT_KHR = 0;
const VkVideoEncodeFlagBitsKHR VIDEO_ENCODE_RESERVED_0_BIT_KHR = 0x00000001;
const VkVideoEncodeFlagBitsKHR VIDEO_ENCODE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF;

alias VkVideoEncodeFlagsKHR = VkFlags;

typedef VkVideoEncodeRateControlFlagBitsKHR = inline CUInt;
const VkVideoEncodeRateControlFlagBitsKHR VIDEO_ENCODE_RATE_CONTROL_DEFAULT_KHR = 0;
const VkVideoEncodeRateControlFlagBitsKHR VIDEO_ENCODE_RATE_CONTROL_RESERVED_0_BIT_KHR = 0x00000001;
const VkVideoEncodeRateControlFlagBitsKHR VIDEO_ENCODE_RATE_CONTROL_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF;

alias VkVideoEncodeRateControlFlagsKHR = VkFlags;

typedef VkVideoEncodeRateControlModeFlagBitsKHR = inline CUInt;
const VkVideoEncodeRateControlModeFlagBitsKHR VIDEO_ENCODE_RATE_CONTROL_MODE_NONE_BIT_KHR = 0;
const VkVideoEncodeRateControlModeFlagBitsKHR VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR = 1;
const VkVideoEncodeRateControlModeFlagBitsKHR VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR = 2;
const VkVideoEncodeRateControlModeFlagBitsKHR VIDEO_ENCODE_RATE_CONTROL_MODE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF;

alias VkVideoEncodeRateControlModeFlagsKHR = VkFlags;

struct VkVideoEncodeInfoKHR {
  VkStructureType sType;
  void * pNext;
  VkVideoEncodeFlagsKHR flags;
  uint qualityLevel;
  VkExtent2D codedExtent;
  VkBuffer dstBitstreamBuffer;
  VkDeviceSize dstBitstreamBufferOffset;
  VkDeviceSize dstBitstreamBufferMaxRange;
  VkVideoPictureResourceKHR srcPictureResource;
  VkVideoReferenceSlotKHR * pSetupReferenceSlot;
  uint referenceSlotCount;
  VkVideoReferenceSlotKHR * pReferenceSlots;
  uint precedingExternallyEncodedBytes;
}

struct VkVideoEncodeRateControlLayerInfoKHR {
  VkStructureType sType;
  void * pNext;
  uint averageBitrate;
  uint maxBitrate;
  uint frameRateNumerator;
  uint frameRateDenominator;
  uint virtualBufferSizeInMs;
  uint initialVirtualBufferSizeInMs;
}

struct VkVideoEncodeRateControlInfoKHR {
  VkStructureType sType;
  void * pNext;
  VkVideoEncodeRateControlFlagsKHR flags;
  VkVideoEncodeRateControlModeFlagBitsKHR rateControlMode;
  char layerCount;
  VkVideoEncodeRateControlLayerInfoKHR * pLayerConfigs;
}

alias PFN_vkCmdEncodeVideoKHR = fn void(
  VkCommandBuffer commandBuffer, 
  VkVideoEncodeInfoKHR * pEncodeInfo);

fn void cmdEncodeVideoKHR(
  VkCommandBuffer commandBuffer, 
  VkVideoEncodeInfoKHR * pEncodeInfo)
@extern("vkCmdEncodeVideoKHR");

typedef StdVideoH264ChromaFormatIdc = inline CUInt;
const StdVideoH264ChromaFormatIdc STD_VIDEO_H264_CHROMA_FORMAT_IDC_MONOCHROME = 0;
const StdVideoH264ChromaFormatIdc STD_VIDEO_H264_CHROMA_FORMAT_IDC_420 = 1;
const StdVideoH264ChromaFormatIdc STD_VIDEO_H264_CHROMA_FORMAT_IDC_422 = 2;
const StdVideoH264ChromaFormatIdc STD_VIDEO_H264_CHROMA_FORMAT_IDC_444 = 3;
const StdVideoH264ChromaFormatIdc STD_VIDEO_H264_CHROMA_FORMAT_IDC_INVALID = 0x7FFFFFFF;
const StdVideoH264ChromaFormatIdc STD_VIDEO_H264_CHROMA_FORMAT_IDC_MAX_ENUM = 0x7FFFFFFF;

typedef StdVideoH264ProfileIdc = inline CUInt;
const StdVideoH264ProfileIdc STD_VIDEO_H264_PROFILE_IDC_BASELINE = 66;
const StdVideoH264ProfileIdc STD_VIDEO_H264_PROFILE_IDC_MAIN = 77;
const StdVideoH264ProfileIdc STD_VIDEO_H264_PROFILE_IDC_HIGH = 100;
const StdVideoH264ProfileIdc STD_VIDEO_H264_PROFILE_IDC_HIGH_444_PREDICTIVE = 244;
const StdVideoH264ProfileIdc STD_VIDEO_H264_PROFILE_IDC_INVALID = 0x7FFFFFFF;
const StdVideoH264ProfileIdc STD_VIDEO_H264_PROFILE_IDC_MAX_ENUM = 0x7FFFFFFF;

typedef StdVideoH264Level = inline CUInt;
const StdVideoH264Level STD_VIDEO_H264_LEVEL_1_0 = 0;
const StdVideoH264Level STD_VIDEO_H264_LEVEL_1_1 = 1;
const StdVideoH264Level STD_VIDEO_H264_LEVEL_1_2 = 2;
const StdVideoH264Level STD_VIDEO_H264_LEVEL_1_3 = 3;
const StdVideoH264Level STD_VIDEO_H264_LEVEL_2_0 = 4;
const StdVideoH264Level STD_VIDEO_H264_LEVEL_2_1 = 5;
const StdVideoH264Level STD_VIDEO_H264_LEVEL_2_2 = 6;
const StdVideoH264Level STD_VIDEO_H264_LEVEL_3_0 = 7;
const StdVideoH264Level STD_VIDEO_H264_LEVEL_3_1 = 8;
const StdVideoH264Level STD_VIDEO_H264_LEVEL_3_2 = 9;
const StdVideoH264Level STD_VIDEO_H264_LEVEL_4_0 = 10;
const StdVideoH264Level STD_VIDEO_H264_LEVEL_4_1 = 11;
const StdVideoH264Level STD_VIDEO_H264_LEVEL_4_2 = 12;
const StdVideoH264Level STD_VIDEO_H264_LEVEL_5_0 = 13;
const StdVideoH264Level STD_VIDEO_H264_LEVEL_5_1 = 14;
const StdVideoH264Level STD_VIDEO_H264_LEVEL_5_2 = 15;
const StdVideoH264Level STD_VIDEO_H264_LEVEL_6_0 = 16;
const StdVideoH264Level STD_VIDEO_H264_LEVEL_6_1 = 17;
const StdVideoH264Level STD_VIDEO_H264_LEVEL_6_2 = 18;
const StdVideoH264Level STD_VIDEO_H264_LEVEL_INVALID = 0x7FFFFFFF;
const StdVideoH264Level STD_VIDEO_H264_LEVEL_MAX_ENUM = 0x7FFFFFFF;

typedef StdVideoH264PocType = inline CUInt;
const StdVideoH264PocType STD_VIDEO_H264_POC_TYPE_0 = 0;
const StdVideoH264PocType STD_VIDEO_H264_POC_TYPE_1 = 1;
const StdVideoH264PocType STD_VIDEO_H264_POC_TYPE_2 = 2;
const StdVideoH264PocType STD_VIDEO_H264_POC_TYPE_INVALID = 0x7FFFFFFF;
const StdVideoH264PocType STD_VIDEO_H264_POC_TYPE_MAX_ENUM = 0x7FFFFFFF;

typedef StdVideoH264AspectRatioIdc = inline CUInt;
const StdVideoH264AspectRatioIdc STD_VIDEO_H264_ASPECT_RATIO_IDC_UNSPECIFIED = 0;
const StdVideoH264AspectRatioIdc STD_VIDEO_H264_ASPECT_RATIO_IDC_SQUARE = 1;
const StdVideoH264AspectRatioIdc STD_VIDEO_H264_ASPECT_RATIO_IDC_12_11 = 2;
const StdVideoH264AspectRatioIdc STD_VIDEO_H264_ASPECT_RATIO_IDC_10_11 = 3;
const StdVideoH264AspectRatioIdc STD_VIDEO_H264_ASPECT_RATIO_IDC_16_11 = 4;
const StdVideoH264AspectRatioIdc STD_VIDEO_H264_ASPECT_RATIO_IDC_40_33 = 5;
const StdVideoH264AspectRatioIdc STD_VIDEO_H264_ASPECT_RATIO_IDC_24_11 = 6;
const StdVideoH264AspectRatioIdc STD_VIDEO_H264_ASPECT_RATIO_IDC_20_11 = 7;
const StdVideoH264AspectRatioIdc STD_VIDEO_H264_ASPECT_RATIO_IDC_32_11 = 8;
const StdVideoH264AspectRatioIdc STD_VIDEO_H264_ASPECT_RATIO_IDC_80_33 = 9;
const StdVideoH264AspectRatioIdc STD_VIDEO_H264_ASPECT_RATIO_IDC_18_11 = 10;
const StdVideoH264AspectRatioIdc STD_VIDEO_H264_ASPECT_RATIO_IDC_15_11 = 11;
const StdVideoH264AspectRatioIdc STD_VIDEO_H264_ASPECT_RATIO_IDC_64_33 = 12;
const StdVideoH264AspectRatioIdc STD_VIDEO_H264_ASPECT_RATIO_IDC_160_99 = 13;
const StdVideoH264AspectRatioIdc STD_VIDEO_H264_ASPECT_RATIO_IDC_4_3 = 14;
const StdVideoH264AspectRatioIdc STD_VIDEO_H264_ASPECT_RATIO_IDC_3_2 = 15;
const StdVideoH264AspectRatioIdc STD_VIDEO_H264_ASPECT_RATIO_IDC_2_1 = 16;
const StdVideoH264AspectRatioIdc STD_VIDEO_H264_ASPECT_RATIO_IDC_EXTENDED_SAR = 255;
const StdVideoH264AspectRatioIdc STD_VIDEO_H264_ASPECT_RATIO_IDC_INVALID = 0x7FFFFFFF;
const StdVideoH264AspectRatioIdc STD_VIDEO_H264_ASPECT_RATIO_IDC_MAX_ENUM = 0x7FFFFFFF;

typedef StdVideoH264WeightedBipredIdc = inline CUInt;
const StdVideoH264WeightedBipredIdc STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_DEFAULT = 0;
const StdVideoH264WeightedBipredIdc STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_EXPLICIT = 1;
const StdVideoH264WeightedBipredIdc STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_IMPLICIT = 2;
const StdVideoH264WeightedBipredIdc STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_INVALID = 0x7FFFFFFF;
const StdVideoH264WeightedBipredIdc STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_MAX_ENUM = 0x7FFFFFFF;

typedef StdVideoH264ModificationOfPicNumsIdc = inline CUInt;
const StdVideoH264ModificationOfPicNumsIdc STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_SHORT_TERM_SUBTRACT = 0;
const StdVideoH264ModificationOfPicNumsIdc STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_SHORT_TERM_ADD = 1;
const StdVideoH264ModificationOfPicNumsIdc STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_LONG_TERM = 2;
const StdVideoH264ModificationOfPicNumsIdc STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_END = 3;
const StdVideoH264ModificationOfPicNumsIdc STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_INVALID = 0x7FFFFFFF;
const StdVideoH264ModificationOfPicNumsIdc STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_MAX_ENUM = 0x7FFFFFFF;

typedef StdVideoH264MemMgmtControlOp = inline CUInt;
const StdVideoH264MemMgmtControlOp STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_END = 0;
const StdVideoH264MemMgmtControlOp STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_UNMARK_SHORT_TERM = 1;
const StdVideoH264MemMgmtControlOp STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_UNMARK_LONG_TERM = 2;
const StdVideoH264MemMgmtControlOp STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_MARK_LONG_TERM = 3;
const StdVideoH264MemMgmtControlOp STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_SET_MAX_LONG_TERM_INDEX = 4;
const StdVideoH264MemMgmtControlOp STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_UNMARK_ALL = 5;
const StdVideoH264MemMgmtControlOp STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_MARK_CURRENT_AS_LONG_TERM = 6;
const StdVideoH264MemMgmtControlOp STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_INVALID = 0x7FFFFFFF;
const StdVideoH264MemMgmtControlOp STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_MAX_ENUM = 0x7FFFFFFF;

typedef StdVideoH264CabacInitIdc = inline CUInt;
const StdVideoH264CabacInitIdc STD_VIDEO_H264_CABAC_INIT_IDC_0 = 0;
const StdVideoH264CabacInitIdc STD_VIDEO_H264_CABAC_INIT_IDC_1 = 1;
const StdVideoH264CabacInitIdc STD_VIDEO_H264_CABAC_INIT_IDC_2 = 2;
const StdVideoH264CabacInitIdc STD_VIDEO_H264_CABAC_INIT_IDC_INVALID = 0x7FFFFFFF;
const StdVideoH264CabacInitIdc STD_VIDEO_H264_CABAC_INIT_IDC_MAX_ENUM = 0x7FFFFFFF;

typedef StdVideoH264DisableDeblockingFilterIdc = inline CUInt;
const StdVideoH264DisableDeblockingFilterIdc STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_DISABLED = 0;
const StdVideoH264DisableDeblockingFilterIdc STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_ENABLED = 1;
const StdVideoH264DisableDeblockingFilterIdc STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_PARTIAL = 2;
const StdVideoH264DisableDeblockingFilterIdc STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_INVALID = 0x7FFFFFFF;
const StdVideoH264DisableDeblockingFilterIdc STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_MAX_ENUM = 0x7FFFFFFF;

typedef StdVideoH264SliceType = inline CUInt;
const StdVideoH264SliceType STD_VIDEO_H264_SLICE_TYPE_P = 0;
const StdVideoH264SliceType STD_VIDEO_H264_SLICE_TYPE_B = 1;
const StdVideoH264SliceType STD_VIDEO_H264_SLICE_TYPE_I = 2;
const StdVideoH264SliceType STD_VIDEO_H264_SLICE_TYPE_INVALID = 0x7FFFFFFF;
const StdVideoH264SliceType STD_VIDEO_H264_SLICE_TYPE_MAX_ENUM = 0x7FFFFFFF;

typedef StdVideoH264PictureType = inline CUInt;
const StdVideoH264PictureType STD_VIDEO_H264_PICTURE_TYPE_P = 0;
const StdVideoH264PictureType STD_VIDEO_H264_PICTURE_TYPE_B = 1;
const StdVideoH264PictureType STD_VIDEO_H264_PICTURE_TYPE_I = 2;
const StdVideoH264PictureType STD_VIDEO_H264_PICTURE_TYPE_IDR = 5;
const StdVideoH264PictureType STD_VIDEO_H264_PICTURE_TYPE_INVALID = 0x7FFFFFFF;
const StdVideoH264PictureType STD_VIDEO_H264_PICTURE_TYPE_MAX_ENUM = 0x7FFFFFFF;

typedef StdVideoH264NonVclNaluType = inline CUInt;
const StdVideoH264NonVclNaluType STD_VIDEO_H264_NON_VCL_NALU_TYPE_SPS = 0;
const StdVideoH264NonVclNaluType STD_VIDEO_H264_NON_VCL_NALU_TYPE_PPS = 1;
const StdVideoH264NonVclNaluType STD_VIDEO_H264_NON_VCL_NALU_TYPE_AUD = 2;
const StdVideoH264NonVclNaluType STD_VIDEO_H264_NON_VCL_NALU_TYPE_PREFIX = 3;
const StdVideoH264NonVclNaluType STD_VIDEO_H264_NON_VCL_NALU_TYPE_END_OF_SEQUENCE = 4;
const StdVideoH264NonVclNaluType STD_VIDEO_H264_NON_VCL_NALU_TYPE_END_OF_STREAM = 5;
const StdVideoH264NonVclNaluType STD_VIDEO_H264_NON_VCL_NALU_TYPE_PRECODED = 6;
const StdVideoH264NonVclNaluType STD_VIDEO_H264_NON_VCL_NALU_TYPE_INVALID = 0x7FFFFFFF;
const StdVideoH264NonVclNaluType STD_VIDEO_H264_NON_VCL_NALU_TYPE_MAX_ENUM = 0x7FFFFFFF;

struct StdVideoH264SpsVuiFlags {
  bitstruct : ushort {
    uint aspect_ratio_info_present_flag : 0..0;
    uint overscan_info_present_flag : 1..1;
    uint overscan_appropriate_flag : 2..2;
    uint video_signal_type_present_flag : 3..3;
    uint video_full_range_flag : 4..4;
    uint color_description_present_flag : 5..5;
    uint chroma_loc_info_present_flag : 6..6;
    uint timing_info_present_flag : 7..7;
    uint fixed_frame_rate_flag : 8..8;
    uint bitstream_restriction_flag : 9..9;
    uint nal_hrd_parameters_present_flag : 10..10;
    uint vcl_hrd_parameters_present_flag : 11..11;
  }
}

struct StdVideoH264HrdParameters {
  char cpb_cnt_minus1;
  char bit_rate_scale;
  char cpb_size_scale;
  uint[32] bit_rate_value_minus1;
  uint[32] cpb_size_value_minus1;
  char[32] cbr_flag;
  uint initial_cpb_removal_delay_length_minus1;
  uint cpb_removal_delay_length_minus1;
  uint dpb_output_delay_length_minus1;
  uint time_offset_length;
}

struct StdVideoH264SequenceParameterSetVui {
  StdVideoH264AspectRatioIdc aspect_ratio_idc;
  ushort sar_width;
  ushort sar_height;
  char video_format;
  char color_primaries;
  char transfer_characteristics;
  char matrix_coefficients;
  uint num_units_in_tick;
  uint time_scale;
  StdVideoH264HrdParameters * pHrdParameters;
  char max_num_reorder_frames;
  char max_dec_frame_buffering;
  StdVideoH264SpsVuiFlags flags;
}

struct StdVideoH264SpsFlags {
  bitstruct : ushort {
    uint constraint_set0_flag : 0..0;
    uint constraint_set1_flag : 1..1;
    uint constraint_set2_flag : 2..2;
    uint constraint_set3_flag : 3..3;
    uint constraint_set4_flag : 4..4;
    uint constraint_set5_flag : 5..5;
    uint direct_8x8_inference_flag : 6..6;
    uint mb_adaptive_frame_field_flag : 7..7;
    uint frame_mbs_only_flag : 8..8;
    uint delta_pic_order_always_zero_flag : 9..9;
    uint separate_colour_plane_flag : 10..10;
    uint gaps_in_frame_num_value_allowed_flag : 11..11;
    uint qpprime_y_zero_transform_bypass_flag : 12..12;
    uint frame_cropping_flag : 13..13;
    uint seq_scaling_matrix_present_flag : 14..14;
    uint vui_parameters_present_flag : 15..15;
  }
}

struct StdVideoH264ScalingLists {
  char scaling_list_present_mask;
  char use_default_scaling_matrix_mask;
  char[6][16] scalingList4x4;
  char[2][64] scalingList8x8;
}

struct StdVideoH264SequenceParameterSet {
  StdVideoH264ProfileIdc profile_idc;
  StdVideoH264Level level_idc;
  char seq_parameter_set_id;
  StdVideoH264ChromaFormatIdc chroma_format_idc;
  char bit_depth_luma_minus8;
  char bit_depth_chroma_minus8;
  char log2_max_frame_num_minus4;
  StdVideoH264PocType pic_order_cnt_type;
  char log2_max_pic_order_cnt_lsb_minus4;
  int offset_for_non_ref_pic;
  int offset_for_top_to_bottom_field;
  char num_ref_frames_in_pic_order_cnt_cycle;
  char max_num_ref_frames;
  uint pic_width_in_mbs_minus1;
  uint pic_height_in_map_units_minus1;
  uint frame_crop_left_offset;
  uint frame_crop_right_offset;
  uint frame_crop_top_offset;
  uint frame_crop_bottom_offset;
  StdVideoH264SpsFlags flags;
  int * pOffsetForRefFrame;
  StdVideoH264ScalingLists * pScalingLists;
  StdVideoH264SequenceParameterSetVui * pSequenceParameterSetVui;
}

struct StdVideoH264PpsFlags {
  bitstruct : ushort {
    uint transform_8x8_mode_flag : 0..0;
    uint redundant_pic_cnt_present_flag : 1..1;
    uint constrained_intra_pred_flag : 2..2;
    uint deblocking_filter_control_present_flag : 3..3;
    uint weighted_bipred_idc_flag : 4..4;
    uint weighted_pred_flag : 5..5;
    uint pic_order_present_flag : 6..6;
    uint entropy_coding_mode_flag : 7..7;
    uint pic_scaling_matrix_present_flag : 8..8;
  }
}

struct StdVideoH264PictureParameterSet {
  char seq_parameter_set_id;
  char pic_parameter_set_id;
  char num_ref_idx_l0_default_active_minus1;
  char num_ref_idx_l1_default_active_minus1;
  StdVideoH264WeightedBipredIdc weighted_bipred_idc;
  ichar pic_init_qp_minus26;
  ichar pic_init_qs_minus26;
  ichar chroma_qp_index_offset;
  ichar second_chroma_qp_index_offset;
  StdVideoH264PpsFlags flags;
  StdVideoH264ScalingLists * pScalingLists;
}

struct StdVideoEncodeH264SliceHeaderFlags {
  bitstruct : char {
    uint idr_flag : 0..0;
    uint is_reference_flag : 1..1;
    uint num_ref_idx_active_override_flag : 2..2;
    uint no_output_of_prior_pics_flag : 3..3;
    uint long_term_reference_flag : 4..4;
    uint adaptive_ref_pic_marking_mode_flag : 5..5;
    uint no_prior_references_available_flag : 6..6;
  }
}

struct StdVideoEncodeH264PictureInfoFlags {
  bitstruct : char {
    uint idr_flag : 0..0;
    uint is_reference_flag : 1..1;
    uint long_term_reference_flag : 2..2;
  }
}

struct StdVideoEncodeH264RefMgmtFlags {
  bitstruct : char {
    uint ref_pic_list_modification_l0_flag : 0..0;
    uint ref_pic_list_modification_l1_flag : 1..1;
  }
}

struct StdVideoEncodeH264RefListModEntry {
  StdVideoH264ModificationOfPicNumsIdc modification_of_pic_nums_idc;
  ushort abs_diff_pic_num_minus1;
  ushort long_term_pic_num;
}

struct StdVideoEncodeH264RefPicMarkingEntry {
  StdVideoH264MemMgmtControlOp operation;
  ushort difference_of_pic_nums_minus1;
  ushort long_term_pic_num;
  ushort long_term_frame_idx;
  ushort max_long_term_frame_idx_plus1;
}

struct StdVideoEncodeH264RefMemMgmtCtrlOperations {
  StdVideoEncodeH264RefMgmtFlags flags;
  char refList0ModOpCount;
  StdVideoEncodeH264RefListModEntry * pRefList0ModOperations;
  char refList1ModOpCount;
  StdVideoEncodeH264RefListModEntry * pRefList1ModOperations;
  char refPicMarkingOpCount;
  StdVideoEncodeH264RefPicMarkingEntry * pRefPicMarkingOperations;
}

struct StdVideoEncodeH264PictureInfo {
  StdVideoEncodeH264PictureInfoFlags flags;
  StdVideoH264PictureType pictureType;
  uint frameNum;
  uint pictureOrderCount;
  ushort long_term_pic_num;
  ushort long_term_frame_idx;
}

struct StdVideoEncodeH264SliceHeader {
  StdVideoEncodeH264SliceHeaderFlags flags;
  StdVideoH264SliceType slice_type;
  char seq_parameter_set_id;
  char pic_parameter_set_id;
  ushort idr_pic_id;
  char num_ref_idx_l0_active_minus1;
  char num_ref_idx_l1_active_minus1;
  StdVideoH264CabacInitIdc cabac_init_idc;
  StdVideoH264DisableDeblockingFilterIdc disable_deblocking_filter_idc;
  ichar slice_alpha_c0_offset_div2;
  ichar slice_beta_offset_div2;
  StdVideoEncodeH264RefMemMgmtCtrlOperations * pMemMgmtCtrlOperations;
}

typedef VkVideoEncodeH264CapabilityFlagBitsEXT = inline CUInt;
const VkVideoEncodeH264CapabilityFlagBitsEXT VIDEO_ENCODE_H264_CAPABILITY_CABAC_BIT_EXT = 0x00000001;
const VkVideoEncodeH264CapabilityFlagBitsEXT VIDEO_ENCODE_H264_CAPABILITY_CAVLC_BIT_EXT = 0x00000002;
const VkVideoEncodeH264CapabilityFlagBitsEXT VIDEO_ENCODE_H264_CAPABILITY_WEIGHTED_BI_PRED_IMPLICIT_BIT_EXT = 0x00000004;
const VkVideoEncodeH264CapabilityFlagBitsEXT VIDEO_ENCODE_H264_CAPABILITY_TRANSFORM_8X8_BIT_EXT = 0x00000008;
const VkVideoEncodeH264CapabilityFlagBitsEXT VIDEO_ENCODE_H264_CAPABILITY_CHROMA_QP_OFFSET_BIT_EXT = 0x00000010;
const VkVideoEncodeH264CapabilityFlagBitsEXT VIDEO_ENCODE_H264_CAPABILITY_SECOND_CHROMA_QP_OFFSET_BIT_EXT = 0x00000020;
const VkVideoEncodeH264CapabilityFlagBitsEXT VIDEO_ENCODE_H264_CAPABILITY_DEBLOCKING_FILTER_DISABLED_BIT_EXT = 0x00000040;
const VkVideoEncodeH264CapabilityFlagBitsEXT VIDEO_ENCODE_H264_CAPABILITY_DEBLOCKING_FILTER_ENABLED_BIT_EXT = 0x00000080;
const VkVideoEncodeH264CapabilityFlagBitsEXT VIDEO_ENCODE_H264_CAPABILITY_DEBLOCKING_FILTER_PARTIAL_BIT_EXT = 0x00000100;
const VkVideoEncodeH264CapabilityFlagBitsEXT VIDEO_ENCODE_H264_CAPABILITY_MULTIPLE_SLICE_PER_FRAME_BIT_EXT = 0x00000200;
const VkVideoEncodeH264CapabilityFlagBitsEXT VIDEO_ENCODE_H264_CAPABILITY_EVENLY_DISTRIBUTED_SLICE_SIZE_BIT_EXT = 0x00000400;
const VkVideoEncodeH264CapabilityFlagBitsEXT VIDEO_ENCODE_H264_CAPABILITY_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF;

alias VkVideoEncodeH264CapabilityFlagsEXT = VkFlags;

typedef VkVideoEncodeH264InputModeFlagBitsEXT = inline CUInt;
const VkVideoEncodeH264InputModeFlagBitsEXT VIDEO_ENCODE_H264_INPUT_MODE_FRAME_BIT_EXT = 0x00000001;
const VkVideoEncodeH264InputModeFlagBitsEXT VIDEO_ENCODE_H264_INPUT_MODE_SLICE_BIT_EXT = 0x00000002;
const VkVideoEncodeH264InputModeFlagBitsEXT VIDEO_ENCODE_H264_INPUT_MODE_NON_VCL_BIT_EXT = 0x00000004;
const VkVideoEncodeH264InputModeFlagBitsEXT VIDEO_ENCODE_H264_INPUT_MODE_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF;

alias VkVideoEncodeH264InputModeFlagsEXT = VkFlags;

typedef VkVideoEncodeH264OutputModeFlagBitsEXT = inline CUInt;
const VkVideoEncodeH264OutputModeFlagBitsEXT VIDEO_ENCODE_H264_OUTPUT_MODE_FRAME_BIT_EXT = 0x00000001;
const VkVideoEncodeH264OutputModeFlagBitsEXT VIDEO_ENCODE_H264_OUTPUT_MODE_SLICE_BIT_EXT = 0x00000002;
const VkVideoEncodeH264OutputModeFlagBitsEXT VIDEO_ENCODE_H264_OUTPUT_MODE_NON_VCL_BIT_EXT = 0x00000004;
const VkVideoEncodeH264OutputModeFlagBitsEXT VIDEO_ENCODE_H264_OUTPUT_MODE_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF;

alias VkVideoEncodeH264OutputModeFlagsEXT = VkFlags;

typedef VkVideoEncodeH264CreateFlagBitsEXT = inline CUInt;
const VkVideoEncodeH264CreateFlagBitsEXT VIDEO_ENCODE_H264_CREATE_DEFAULT_EXT = 0;
const VkVideoEncodeH264CreateFlagBitsEXT VIDEO_ENCODE_H264_CREATE_RESERVED_0_BIT_EXT = 0x00000001;
const VkVideoEncodeH264CreateFlagBitsEXT VIDEO_ENCODE_H264_CREATE_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF;

alias VkVideoEncodeH264CreateFlagsEXT = VkFlags;

typedef VkVideoEncodeH264RateControlStructureFlagBitsEXT = inline CUInt;
const VkVideoEncodeH264RateControlStructureFlagBitsEXT VIDEO_ENCODE_H264_RATE_CONTROL_STRUCTURE_UNKNOWN_EXT = 0;
const VkVideoEncodeH264RateControlStructureFlagBitsEXT VIDEO_ENCODE_H264_RATE_CONTROL_STRUCTURE_FLAT_BIT_EXT = 0x00000001;
const VkVideoEncodeH264RateControlStructureFlagBitsEXT VIDEO_ENCODE_H264_RATE_CONTROL_STRUCTURE_DYADIC_BIT_EXT = 0x00000002;
const VkVideoEncodeH264RateControlStructureFlagBitsEXT VIDEO_ENCODE_H264_RATE_CONTROL_STRUCTURE_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF;

alias VkVideoEncodeH264RateControlStructureFlagsEXT = VkFlags;

struct VkVideoEncodeH264CapabilitiesEXT {
  VkStructureType sType;
  void * pNext;
  VkVideoEncodeH264CapabilityFlagsEXT flags;
  VkVideoEncodeH264InputModeFlagsEXT inputModeFlags;
  VkVideoEncodeH264OutputModeFlagsEXT outputModeFlags;
  VkExtent2D minPictureSizeInMbs;
  VkExtent2D maxPictureSizeInMbs;
  VkExtent2D inputImageDataAlignment;
  char maxNumL0ReferenceForP;
  char maxNumL0ReferenceForB;
  char maxNumL1Reference;
  char qualityLevelCount;
  VkExtensionProperties stdExtensionVersion;
}

struct VkVideoEncodeH264SessionCreateInfoEXT {
  VkStructureType sType;
  void * pNext;
  VkVideoEncodeH264CreateFlagsEXT flags;
  VkExtent2D maxPictureSizeInMbs;
  VkExtensionProperties * pStdExtensionVersion;
}

struct VkVideoEncodeH264SessionParametersAddInfoEXT {
  VkStructureType sType;
  void * pNext;
  uint spsStdCount;
  StdVideoH264SequenceParameterSet * pSpsStd;
  uint ppsStdCount;
  StdVideoH264PictureParameterSet * pPpsStd;
}

struct VkVideoEncodeH264SessionParametersCreateInfoEXT {
  VkStructureType sType;
  void * pNext;
  uint maxSpsStdCount;
  uint maxPpsStdCount;
  VkVideoEncodeH264SessionParametersAddInfoEXT * pParametersAddInfo;
}

struct VkVideoEncodeH264DpbSlotInfoEXT {
  VkStructureType sType;
  void * pNext;
  ichar slotIndex;
  StdVideoEncodeH264PictureInfo * pStdPictureInfo;
}

struct VkVideoEncodeH264NaluSliceEXT {
  VkStructureType sType;
  void * pNext;
  StdVideoEncodeH264SliceHeader * pSliceHeaderStd;
  uint mbCount;
  char refFinalList0EntryCount;
  VkVideoEncodeH264DpbSlotInfoEXT * pRefFinalList0Entries;
  char refFinalList1EntryCount;
  VkVideoEncodeH264DpbSlotInfoEXT * pRefFinalList1Entries;
}

struct VkVideoEncodeH264VclFrameInfoEXT {
  VkStructureType sType;
  void * pNext;
  char refDefaultFinalList0EntryCount;
  VkVideoEncodeH264DpbSlotInfoEXT * pRefDefaultFinalList0Entries;
  char refDefaultFinalList1EntryCount;
  VkVideoEncodeH264DpbSlotInfoEXT * pRefDefaultFinalList1Entries;
  uint naluSliceEntryCount;
  VkVideoEncodeH264NaluSliceEXT * pNaluSliceEntries;
  VkVideoEncodeH264DpbSlotInfoEXT * pCurrentPictureInfo;
}

struct VkVideoEncodeH264EmitPictureParametersEXT {
  VkStructureType sType;
  void * pNext;
  char spsId;
  VkBool32 emitSpsEnable;
  uint ppsIdEntryCount;
  char * ppsIdEntries;
}

struct VkVideoEncodeH264ProfileEXT {
  VkStructureType sType;
  void * pNext;
  StdVideoH264ProfileIdc stdProfileIdc;
}

struct VkVideoEncodeH264RateControlInfoEXT {
  VkStructureType sType;
  void * pNext;
  uint gopFrameCount;
  uint idrPeriod;
  uint consecutiveBFrameCount;
  VkVideoEncodeH264RateControlStructureFlagBitsEXT rateControlStructure;
  char temporalLayerCount;
}

struct VkVideoEncodeH264QpEXT {
  int qpI;
  int qpP;
  int qpB;
}

struct VkVideoEncodeH264FrameSizeEXT {
  uint frameISize;
  uint framePSize;
  uint frameBSize;
}

struct VkVideoEncodeH264RateControlLayerInfoEXT {
  VkStructureType sType;
  void * pNext;
  char temporalLayerId;
  VkBool32 useInitialRcQp;
  VkVideoEncodeH264QpEXT initialRcQp;
  VkBool32 useMinQp;
  VkVideoEncodeH264QpEXT minQp;
  VkBool32 useMaxQp;
  VkVideoEncodeH264QpEXT maxQp;
  VkBool32 useMaxFrameSize;
  VkVideoEncodeH264FrameSizeEXT maxFrameSize;
}

typedef StdVideoH265ChromaFormatIdc = inline CUInt;
const StdVideoH265ChromaFormatIdc STD_VIDEO_H265_CHROMA_FORMAT_IDC_MONOCHROME = 0;
const StdVideoH265ChromaFormatIdc STD_VIDEO_H265_CHROMA_FORMAT_IDC_420 = 1;
const StdVideoH265ChromaFormatIdc STD_VIDEO_H265_CHROMA_FORMAT_IDC_422 = 2;
const StdVideoH265ChromaFormatIdc STD_VIDEO_H265_CHROMA_FORMAT_IDC_444 = 3;
const StdVideoH265ChromaFormatIdc STD_VIDEO_H265_CHROMA_FORMAT_IDC_INVALID = 0x7FFFFFFF;
const StdVideoH265ChromaFormatIdc STD_VIDEO_H265_CHROMA_FORMAT_IDC_MAX_ENUM = 0x7FFFFFFF;

typedef StdVideoH265ProfileIdc = inline CUInt;
const StdVideoH265ProfileIdc STD_VIDEO_H265_PROFILE_IDC_MAIN = 1;
const StdVideoH265ProfileIdc STD_VIDEO_H265_PROFILE_IDC_MAIN_10 = 2;
const StdVideoH265ProfileIdc STD_VIDEO_H265_PROFILE_IDC_MAIN_STILL_PICTURE = 3;
const StdVideoH265ProfileIdc STD_VIDEO_H265_PROFILE_IDC_FORMAT_RANGE_EXTENSIONS = 4;
const StdVideoH265ProfileIdc STD_VIDEO_H265_PROFILE_IDC_SCC_EXTENSIONS = 9;
const StdVideoH265ProfileIdc STD_VIDEO_H265_PROFILE_IDC_INVALID = 0x7FFFFFFF;
const StdVideoH265ProfileIdc STD_VIDEO_H265_PROFILE_IDC_MAX_ENUM = 0x7FFFFFFF;

typedef StdVideoH265Level = inline CUInt;
const StdVideoH265Level STD_VIDEO_H265_LEVEL_1_0 = 0;
const StdVideoH265Level STD_VIDEO_H265_LEVEL_2_0 = 1;
const StdVideoH265Level STD_VIDEO_H265_LEVEL_2_1 = 2;
const StdVideoH265Level STD_VIDEO_H265_LEVEL_3_0 = 3;
const StdVideoH265Level STD_VIDEO_H265_LEVEL_3_1 = 4;
const StdVideoH265Level STD_VIDEO_H265_LEVEL_4_0 = 5;
const StdVideoH265Level STD_VIDEO_H265_LEVEL_4_1 = 6;
const StdVideoH265Level STD_VIDEO_H265_LEVEL_5_0 = 7;
const StdVideoH265Level STD_VIDEO_H265_LEVEL_5_1 = 8;
const StdVideoH265Level STD_VIDEO_H265_LEVEL_5_2 = 9;
const StdVideoH265Level STD_VIDEO_H265_LEVEL_6_0 = 10;
const StdVideoH265Level STD_VIDEO_H265_LEVEL_6_1 = 11;
const StdVideoH265Level STD_VIDEO_H265_LEVEL_6_2 = 12;
const StdVideoH265Level STD_VIDEO_H265_LEVEL_INVALID = 0x7FFFFFFF;
const StdVideoH265Level STD_VIDEO_H265_LEVEL_MAX_ENUM = 0x7FFFFFFF;

typedef StdVideoH265SliceType = inline CUInt;
const StdVideoH265SliceType STD_VIDEO_H265_SLICE_TYPE_B = 0;
const StdVideoH265SliceType STD_VIDEO_H265_SLICE_TYPE_P = 1;
const StdVideoH265SliceType STD_VIDEO_H265_SLICE_TYPE_I = 2;
const StdVideoH265SliceType STD_VIDEO_H265_SLICE_TYPE_INVALID = 0x7FFFFFFF;
const StdVideoH265SliceType STD_VIDEO_H265_SLICE_TYPE_MAX_ENUM = 0x7FFFFFFF;

typedef StdVideoH265PictureType = inline CUInt;
const StdVideoH265PictureType STD_VIDEO_H265_PICTURE_TYPE_P = 0;
const StdVideoH265PictureType STD_VIDEO_H265_PICTURE_TYPE_B = 1;
const StdVideoH265PictureType STD_VIDEO_H265_PICTURE_TYPE_I = 2;
const StdVideoH265PictureType STD_VIDEO_H265_PICTURE_TYPE_IDR = 3;
const StdVideoH265PictureType STD_VIDEO_H265_PICTURE_TYPE_INVALID = 0x7FFFFFFF;
const StdVideoH265PictureType STD_VIDEO_H265_PICTURE_TYPE_MAX_ENUM = 0x7FFFFFFF;

struct StdVideoH265DecPicBufMgr {
  uint[7] max_latency_increase_plus1;
  char[7] max_dec_pic_buffering_minus1;
  char[7] max_num_reorder_pics;
}

struct StdVideoH265SubLayerHrdParameters {
  uint[32] bit_rate_value_minus1;
  uint[32] cpb_size_value_minus1;
  uint[32] cpb_size_du_value_minus1;
  uint[32] bit_rate_du_value_minus1;
  uint cbr_flag;
}

struct StdVideoH265HrdFlags {
  bitstruct : uint {
    uint nal_hrd_parameters_present_flag : 0..0;
    uint vcl_hrd_parameters_present_flag : 1..1;
    uint sub_pic_hrd_params_present_flag : 2..2;
    uint sub_pic_cpb_params_in_pic_timing_sei_flag : 3..3;
    uint fixed_pic_rate_general_flag : 4..11;
    uint fixed_pic_rate_within_cvs_flag : 12..19;
    uint low_delay_hrd_flag : 20..27;
  }
}

struct StdVideoH265HrdParameters {
  char tick_divisor_minus2;
  char du_cpb_removal_delay_increment_length_minus1;
  char dpb_output_delay_du_length_minus1;
  char bit_rate_scale;
  char cpb_size_scale;
  char cpb_size_du_scale;
  char initial_cpb_removal_delay_length_minus1;
  char au_cpb_removal_delay_length_minus1;
  char dpb_output_delay_length_minus1;
  char[7] cpb_cnt_minus1;
  ushort[7] elemental_duration_in_tc_minus1;
  StdVideoH265SubLayerHrdParameters *[7] pSubLayerHrdParametersNal;
  StdVideoH265SubLayerHrdParameters *[7] pSubLayerHrdParametersVcl;
  StdVideoH265HrdFlags flags;
}

struct StdVideoH265VpsFlags {
  bitstruct : char {
    uint vps_temporal_id_nesting_flag : 0..0;
    uint vps_sub_layer_ordering_info_present_flag : 1..1;
    uint vps_timing_info_present_flag : 2..2;
    uint vps_poc_proportional_to_timing_flag : 3..3;
  }
}

struct StdVideoH265VideoParameterSet {
  char vps_video_parameter_set_id;
  char vps_max_sub_layers_minus1;
  uint vps_num_units_in_tick;
  uint vps_time_scale;
  uint vps_num_ticks_poc_diff_one_minus1;
  StdVideoH265DecPicBufMgr * pDecPicBufMgr;
  StdVideoH265HrdParameters * pHrdParameters;
  StdVideoH265VpsFlags flags;
}

struct StdVideoH265ScalingLists {
  char[6][16] scalingList4x4;
  char[6][64] scalingList8x8;
  char[6][64] scalingList16x16;
  char[2][64] scalingList32x32;
  char[6] scalingListDCCoef16x16;
  char[2] scalingListDCCoef32x32;
}

struct StdVideoH265SpsVuiFlags {
  bitstruct : uint {
    uint aspect_ratio_info_present_flag : 0..0;
    uint overscan_info_present_flag : 1..1;
    uint overscan_appropriate_flag : 2..2;
    uint video_signal_type_present_flag : 3..3;
    uint video_full_range_flag : 4..4;
    uint colour_description_present_flag : 5..5;
    uint chroma_loc_info_present_flag : 6..6;
    uint neutral_chroma_indication_flag : 7..7;
    uint field_seq_flag : 8..8;
    uint frame_field_info_present_flag : 9..9;
    uint default_display_window_flag : 10..10;
    uint vui_timing_info_present_flag : 11..11;
    uint vui_poc_proportional_to_timing_flag : 12..12;
    uint vui_hrd_parameters_present_flag : 13..13;
    uint bitstream_restriction_flag : 14..14;
    uint tiles_fixed_structure_flag : 15..15;
    uint motion_vectors_over_pic_boundaries_flag : 16..16;
    uint restricted_ref_pic_lists_flag : 17..17;
  }
}

struct StdVideoH265SequenceParameterSetVui {
  char aspect_ratio_idc;
  ushort sar_width;
  ushort sar_height;
  char video_format;
  char colour_primaries;
  char transfer_characteristics;
  char matrix_coeffs;
  char chroma_sample_loc_type_top_field;
  char chroma_sample_loc_type_bottom_field;
  ushort def_disp_win_left_offset;
  ushort def_disp_win_right_offset;
  ushort def_disp_win_top_offset;
  ushort def_disp_win_bottom_offset;
  uint vui_num_units_in_tick;
  uint vui_time_scale;
  uint vui_num_ticks_poc_diff_one_minus1;
  StdVideoH265HrdParameters * pHrdParameters;
  ushort min_spatial_segmentation_idc;
  char max_bytes_per_pic_denom;
  char max_bits_per_min_cu_denom;
  char log2_max_mv_length_horizontal;
  char log2_max_mv_length_vertical;
  StdVideoH265SpsVuiFlags flags;
}

struct StdVideoH265PredictorPaletteEntries {
  ushort[3][128] predictorPaletteEntries;
}

struct StdVideoH265SpsFlags {
  bitstruct : uint {
    uint sps_temporal_id_nesting_flag : 0..0;
    uint separate_colour_plane_flag : 1..1;
    uint scaling_list_enabled_flag : 2..2;
    uint sps_scaling_list_data_present_flag : 3..3;
    uint amp_enabled_flag : 4..4;
    uint sample_adaptive_offset_enabled_flag : 5..5;
    uint pcm_enabled_flag : 6..6;
    uint pcm_loop_filter_disabled_flag : 7..7;
    uint long_term_ref_pics_present_flag : 8..8;
    uint sps_temporal_mvp_enabled_flag : 9..9;
    uint strong_intra_smoothing_enabled_flag : 10..10;
    uint vui_parameters_present_flag : 11..11;
    uint sps_extension_present_flag : 12..12;
    uint sps_range_extension_flag : 13..13;
    uint transform_skip_rotation_enabled_flag : 14..14;
    uint transform_skip_context_enabled_flag : 15..15;
    uint implicit_rdpcm_enabled_flag : 16..16;
    uint explicit_rdpcm_enabled_flag : 17..17;
    uint extended_precision_processing_flag : 18..18;
    uint intra_smoothing_disabled_flag : 19..19;
    uint high_precision_offsets_enabled_flag : 20..20;
    uint persistent_rice_adaptation_enabled_flag : 21..21;
    uint cabac_bypass_alignment_enabled_flag : 22..22;
    uint sps_curr_pic_ref_enabled_flag : 23..23;
    uint palette_mode_enabled_flag : 24..24;
    uint sps_palette_predictor_initializer_present_flag : 25..25;
    uint intra_boundary_filtering_disabled_flag : 26..26;
  }
}

struct StdVideoH265SequenceParameterSet {
  StdVideoH265ProfileIdc profile_idc;
  StdVideoH265Level level_idc;
  uint pic_width_in_luma_samples;
  uint pic_height_in_luma_samples;
  char sps_video_parameter_set_id;
  char sps_max_sub_layers_minus1;
  char sps_seq_parameter_set_id;
  char chroma_format_idc;
  char bit_depth_luma_minus8;
  char bit_depth_chroma_minus8;
  char log2_max_pic_order_cnt_lsb_minus4;
  char sps_max_dec_pic_buffering_minus1;
  char log2_min_luma_coding_block_size_minus3;
  char log2_diff_max_min_luma_coding_block_size;
  char log2_min_luma_transform_block_size_minus2;
  char log2_diff_max_min_luma_transform_block_size;
  char max_transform_hierarchy_depth_inter;
  char max_transform_hierarchy_depth_intra;
  char num_short_term_ref_pic_sets;
  char num_long_term_ref_pics_sps;
  char pcm_sample_bit_depth_luma_minus1;
  char pcm_sample_bit_depth_chroma_minus1;
  char log2_min_pcm_luma_coding_block_size_minus3;
  char log2_diff_max_min_pcm_luma_coding_block_size;
  uint conf_win_left_offset;
  uint conf_win_right_offset;
  uint conf_win_top_offset;
  uint conf_win_bottom_offset;
  StdVideoH265DecPicBufMgr * pDecPicBufMgr;
  StdVideoH265SpsFlags flags;
  StdVideoH265ScalingLists * pScalingLists;
  StdVideoH265SequenceParameterSetVui * pSequenceParameterSetVui;
  char palette_max_size;
  char delta_palette_max_predictor_size;
  char motion_vector_resolution_control_idc;
  char sps_num_palette_predictor_initializer_minus1;
  StdVideoH265PredictorPaletteEntries * pPredictorPaletteEntries;
}

struct StdVideoH265PpsFlags {
  bitstruct : uint {
    uint dependent_slice_segments_enabled_flag : 0..0;
    uint output_flag_present_flag : 1..1;
    uint sign_data_hiding_enabled_flag : 2..2;
    uint cabac_init_present_flag : 3..3;
    uint constrained_intra_pred_flag : 4..4;
    uint transform_skip_enabled_flag : 5..5;
    uint cu_qp_delta_enabled_flag : 6..6;
    uint pps_slice_chroma_qp_offsets_present_flag : 7..7;
    uint weighted_pred_flag : 8..8;
    uint weighted_bipred_flag : 9..9;
    uint transquant_bypass_enabled_flag : 10..10;
    uint tiles_enabled_flag : 11..11;
    uint entropy_coding_sync_enabled_flag : 12..12;
    uint uniform_spacing_flag : 13..13;
    uint loop_filter_across_tiles_enabled_flag : 14..14;
    uint pps_loop_filter_across_slices_enabled_flag : 15..15;
    uint deblocking_filter_control_present_flag : 16..16;
    uint deblocking_filter_override_enabled_flag : 17..17;
    uint pps_deblocking_filter_disabled_flag : 18..18;
    uint pps_scaling_list_data_present_flag : 19..19;
    uint lists_modification_present_flag : 20..20;
    uint slice_segment_header_extension_present_flag : 21..21;
    uint pps_extension_present_flag : 22..22;
    uint cross_component_prediction_enabled_flag : 23..23;
    uint chroma_qp_offset_list_enabled_flag : 24..24;
    uint pps_curr_pic_ref_enabled_flag : 25..25;
    uint residual_adaptive_colour_transform_enabled_flag : 26..26;
    uint pps_slice_act_qp_offsets_present_flag : 27..27;
    uint pps_palette_predictor_initializer_present_flag : 28..28;
    uint monochrome_palette_flag : 29..29;
    uint pps_range_extension_flag : 30..30;
  }
}

struct StdVideoH265PictureParameterSet {
  char pps_pic_parameter_set_id;
  char pps_seq_parameter_set_id;
  char num_extra_slice_header_bits;
  char num_ref_idx_l0_default_active_minus1;
  char num_ref_idx_l1_default_active_minus1;
  ichar init_qp_minus26;
  char diff_cu_qp_delta_depth;
  ichar pps_cb_qp_offset;
  ichar pps_cr_qp_offset;
  char num_tile_columns_minus1;
  char num_tile_rows_minus1;
  ushort[19] column_width_minus1;
  ushort[21] row_height_minus1;
  ichar pps_beta_offset_div2;
  ichar pps_tc_offset_div2;
  char log2_parallel_merge_level_minus2;
  StdVideoH265PpsFlags flags;
  StdVideoH265ScalingLists * pScalingLists;
  char log2_max_transform_skip_block_size_minus2;
  char diff_cu_chroma_qp_offset_depth;
  char chroma_qp_offset_list_len_minus1;
  ichar[6] cb_qp_offset_list;
  ichar[6] cr_qp_offset_list;
  char log2_sao_offset_scale_luma;
  char log2_sao_offset_scale_chroma;
  ichar pps_act_y_qp_offset_plus5;
  ichar pps_act_cb_qp_offset_plus5;
  ichar pps_act_cr_qp_offset_plus5;
  char pps_num_palette_predictor_initializer;
  char luma_bit_depth_entry_minus8;
  char chroma_bit_depth_entry_minus8;
  StdVideoH265PredictorPaletteEntries * pPredictorPaletteEntries;
}

struct StdVideoEncodeH265SliceHeaderFlags {
  bitstruct : uint {
    uint first_slice_segment_in_pic_flag : 0..0;
    uint no_output_of_prior_pics_flag : 1..1;
    uint dependent_slice_segment_flag : 2..2;
    uint short_term_ref_pic_set_sps_flag : 3..3;
    uint slice_temporal_mvp_enable_flag : 4..4;
    uint slice_sao_luma_flag : 5..5;
    uint slice_sao_chroma_flag : 6..6;
    uint num_ref_idx_active_override_flag : 7..7;
    uint mvd_l1_zero_flag : 8..8;
    uint cabac_init_flag : 9..9;
    uint slice_deblocking_filter_disable_flag : 10..10;
    uint collocated_from_l0_flag : 11..11;
    uint slice_loop_filter_across_slices_enabled_flag : 12..12;
    uint bLastSliceInPic : 13..13;
    uint reservedBits : 14..31;
  }
  ushort luma_weight_l0_flag;
  ushort chroma_weight_l0_flag;
  ushort luma_weight_l1_flag;
  ushort chroma_weight_l1_flag;
}

struct StdVideoEncodeH265SliceHeader {
  StdVideoH265SliceType slice_type;
  char slice_pic_parameter_set_id;
  char num_short_term_ref_pic_sets;
  uint slice_segment_address;
  char short_term_ref_pic_set_idx;
  char num_long_term_sps;
  char num_long_term_pics;
  char collocated_ref_idx;
  char num_ref_idx_l0_active_minus1;
  char num_ref_idx_l1_active_minus1;
  char luma_log2_weight_denom;
  ichar delta_chroma_log2_weight_denom;
  ichar[15] delta_luma_weight_l0;
  ichar[15] luma_offset_l0;
  ichar[15][2] delta_chroma_weight_l0;
  ichar[15][2] delta_chroma_offset_l0;
  ichar[15] delta_luma_weight_l1;
  ichar[15] luma_offset_l1;
  ichar[15][2] delta_chroma_weight_l1;
  ichar[15][2] delta_chroma_offset_l1;
  char maxNumMergeCand;
  ichar slice_qp_delta;
  ichar slice_cb_qp_offset;
  ichar slice_cr_qp_offset;
  ichar slice_beta_offset_div2;
  ichar slice_tc_offset_div2;
  ichar slice_act_y_qp_offset;
  ichar slice_act_cb_qp_offset;
  ichar slice_act_cr_qp_offset;
  StdVideoEncodeH265SliceHeaderFlags flags;
}

struct StdVideoEncodeH265ReferenceModificationFlags {
  bitstruct : char {
    uint ref_pic_list_modification_flag_l0 : 0..0;
    uint ref_pic_list_modification_flag_l1 : 1..1;
  }
}

struct StdVideoEncodeH265ReferenceModifications {
  StdVideoEncodeH265ReferenceModificationFlags flags;
  char referenceList0ModificationsCount;
  char * pReferenceList0Modifications;
  char referenceList1ModificationsCount;
  char * pReferenceList1Modifications;
}

struct StdVideoEncodeH265PictureInfoFlags {
  bitstruct : char {
    uint is_reference_flag : 0..0;
    uint irapPicFlag : 1..1;
    uint long_term_flag : 2..2;
  }
}

struct StdVideoEncodeH265PictureInfo {
  StdVideoH265PictureType pictureType;
  char sps_video_parameter_set_id;
  char pps_seq_parameter_set_id;
  int picOrderCntVal;
  char temporalId;
  StdVideoEncodeH265PictureInfoFlags flags;
}

struct StdVideoEncodeH265ReferenceInfoFlags {
  bitstruct : char {
    uint is_long_term : 0..0;
    uint isUsedFlag : 1..1;
  }
}

struct StdVideoEncodeH265ReferenceInfo {
  int picOrderCntVal;
  char temporalId;
  StdVideoEncodeH265ReferenceInfoFlags flags;
}

alias VkVideoEncodeH265CapabilityFlagsEXT = VkFlags;

typedef VkVideoEncodeH265InputModeFlagBitsEXT = inline CUInt;
const VkVideoEncodeH265InputModeFlagBitsEXT VIDEO_ENCODE_H265_INPUT_MODE_FRAME_BIT_EXT = 0x00000001;
const VkVideoEncodeH265InputModeFlagBitsEXT VIDEO_ENCODE_H265_INPUT_MODE_SLICE_BIT_EXT = 0x00000002;
const VkVideoEncodeH265InputModeFlagBitsEXT VIDEO_ENCODE_H265_INPUT_MODE_NON_VCL_BIT_EXT = 0x00000004;
const VkVideoEncodeH265InputModeFlagBitsEXT VIDEO_ENCODE_H265_INPUT_MODE_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF;

alias VkVideoEncodeH265InputModeFlagsEXT = VkFlags;

typedef VkVideoEncodeH265OutputModeFlagBitsEXT = inline CUInt;
const VkVideoEncodeH265OutputModeFlagBitsEXT VIDEO_ENCODE_H265_OUTPUT_MODE_FRAME_BIT_EXT = 0x00000001;
const VkVideoEncodeH265OutputModeFlagBitsEXT VIDEO_ENCODE_H265_OUTPUT_MODE_SLICE_BIT_EXT = 0x00000002;
const VkVideoEncodeH265OutputModeFlagBitsEXT VIDEO_ENCODE_H265_OUTPUT_MODE_NON_VCL_BIT_EXT = 0x00000004;
const VkVideoEncodeH265OutputModeFlagBitsEXT VIDEO_ENCODE_H265_OUTPUT_MODE_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF;

alias VkVideoEncodeH265OutputModeFlagsEXT = VkFlags;

alias VkVideoEncodeH265CreateFlagsEXT = VkFlags;

typedef VkVideoEncodeH265CtbSizeFlagBitsEXT = inline CUInt;
const VkVideoEncodeH265CtbSizeFlagBitsEXT VIDEO_ENCODE_H265_CTB_SIZE_8_BIT_EXT = 0x00000001;
const VkVideoEncodeH265CtbSizeFlagBitsEXT VIDEO_ENCODE_H265_CTB_SIZE_16_BIT_EXT = 0x00000002;
const VkVideoEncodeH265CtbSizeFlagBitsEXT VIDEO_ENCODE_H265_CTB_SIZE_32_BIT_EXT = 0x00000004;
const VkVideoEncodeH265CtbSizeFlagBitsEXT VIDEO_ENCODE_H265_CTB_SIZE_64_BIT_EXT = 0x00000008;
const VkVideoEncodeH265CtbSizeFlagBitsEXT VIDEO_ENCODE_H265_CTB_SIZE_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF;

alias VkVideoEncodeH265CtbSizeFlagsEXT = VkFlags;

typedef VkVideoEncodeH265RateControlStructureFlagBitsEXT = inline CUInt;
const VkVideoEncodeH265RateControlStructureFlagBitsEXT VIDEO_ENCODE_H265_RATE_CONTROL_STRUCTURE_UNKNOWN_EXT = 0;
const VkVideoEncodeH265RateControlStructureFlagBitsEXT VIDEO_ENCODE_H265_RATE_CONTROL_STRUCTURE_FLAT_BIT_EXT = 0x00000001;
const VkVideoEncodeH265RateControlStructureFlagBitsEXT VIDEO_ENCODE_H265_RATE_CONTROL_STRUCTURE_DYADIC_BIT_EXT = 0x00000002;
const VkVideoEncodeH265RateControlStructureFlagBitsEXT VIDEO_ENCODE_H265_RATE_CONTROL_STRUCTURE_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF;

alias VkVideoEncodeH265RateControlStructureFlagsEXT = VkFlags;

struct VkVideoEncodeH265CapabilitiesEXT {
  VkStructureType sType;
  void * pNext;
  VkVideoEncodeH265CapabilityFlagsEXT flags;
  VkVideoEncodeH265InputModeFlagsEXT inputModeFlags;
  VkVideoEncodeH265OutputModeFlagsEXT outputModeFlags;
  VkVideoEncodeH265CtbSizeFlagsEXT ctbSizes;
  VkExtent2D inputImageDataAlignment;
  char maxNumL0ReferenceForP;
  char maxNumL0ReferenceForB;
  char maxNumL1Reference;
  char maxNumSubLayers;
  char qualityLevelCount;
  VkExtensionProperties stdExtensionVersion;
}

struct VkVideoEncodeH265SessionCreateInfoEXT {
  VkStructureType sType;
  void * pNext;
  VkVideoEncodeH265CreateFlagsEXT flags;
  VkExtensionProperties * pStdExtensionVersion;
}

struct VkVideoEncodeH265SessionParametersAddInfoEXT {
  VkStructureType sType;
  void * pNext;
  uint vpsStdCount;
  StdVideoH265VideoParameterSet * pVpsStd;
  uint spsStdCount;
  StdVideoH265SequenceParameterSet * pSpsStd;
  uint ppsStdCount;
  StdVideoH265PictureParameterSet * pPpsStd;
}

struct VkVideoEncodeH265SessionParametersCreateInfoEXT {
  VkStructureType sType;
  void * pNext;
  uint maxVpsStdCount;
  uint maxSpsStdCount;
  uint maxPpsStdCount;
  VkVideoEncodeH265SessionParametersAddInfoEXT * pParametersAddInfo;
}

struct VkVideoEncodeH265DpbSlotInfoEXT {
  VkStructureType sType;
  void * pNext;
  ichar slotIndex;
  StdVideoEncodeH265ReferenceInfo * pStdReferenceInfo;
}

struct VkVideoEncodeH265ReferenceListsEXT {
  VkStructureType sType;
  void * pNext;
  char referenceList0EntryCount;
  VkVideoEncodeH265DpbSlotInfoEXT * pReferenceList0Entries;
  char referenceList1EntryCount;
  VkVideoEncodeH265DpbSlotInfoEXT * pReferenceList1Entries;
  StdVideoEncodeH265ReferenceModifications * pReferenceModifications;
}

struct VkVideoEncodeH265NaluSliceEXT {
  VkStructureType sType;
  void * pNext;
  uint ctbCount;
  VkVideoEncodeH265ReferenceListsEXT * pReferenceFinalLists;
  StdVideoEncodeH265SliceHeader * pSliceHeaderStd;
}

struct VkVideoEncodeH265VclFrameInfoEXT {
  VkStructureType sType;
  void * pNext;
  VkVideoEncodeH265ReferenceListsEXT * pReferenceFinalLists;
  uint naluSliceEntryCount;
  VkVideoEncodeH265NaluSliceEXT * pNaluSliceEntries;
  StdVideoEncodeH265PictureInfo * pCurrentPictureInfo;
}

struct VkVideoEncodeH265EmitPictureParametersEXT {
  VkStructureType sType;
  void * pNext;
  char vpsId;
  char spsId;
  VkBool32 emitVpsEnable;
  VkBool32 emitSpsEnable;
  uint ppsIdEntryCount;
  char * ppsIdEntries;
}

struct VkVideoEncodeH265ProfileEXT {
  VkStructureType sType;
  void * pNext;
  StdVideoH265ProfileIdc stdProfileIdc;
}

struct VkVideoEncodeH265RateControlInfoEXT {
  VkStructureType sType;
  void * pNext;
  uint gopFrameCount;
  uint idrPeriod;
  uint consecutiveBFrameCount;
  VkVideoEncodeH265RateControlStructureFlagBitsEXT rateControlStructure;
  char subLayerCount;
}

struct VkVideoEncodeH265QpEXT {
  int qpI;
  int qpP;
  int qpB;
}

struct VkVideoEncodeH265FrameSizeEXT {
  uint frameISize;
  uint framePSize;
  uint frameBSize;
}

struct VkVideoEncodeH265RateControlLayerInfoEXT {
  VkStructureType sType;
  void * pNext;
  char temporalId;
  VkBool32 useInitialRcQp;
  VkVideoEncodeH265QpEXT initialRcQp;
  VkBool32 useMinQp;
  VkVideoEncodeH265QpEXT minQp;
  VkBool32 useMaxQp;
  VkVideoEncodeH265QpEXT maxQp;
  VkBool32 useMaxFrameSize;
  VkVideoEncodeH265FrameSizeEXT maxFrameSize;
}

typedef StdVideoDecodeH264FieldOrderCount = inline CUInt;
const StdVideoDecodeH264FieldOrderCount STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_TOP = 0;
const StdVideoDecodeH264FieldOrderCount STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_BOTTOM = 1;
const StdVideoDecodeH264FieldOrderCount STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_INVALID = 0x7FFFFFFF;
const StdVideoDecodeH264FieldOrderCount STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_MAX_ENUM = 0x7FFFFFFF;

struct StdVideoDecodeH264PictureInfoFlags {
  bitstruct : char {
    uint field_pic_flag : 0..0;
    uint is_intra : 1..1;
    uint idrPicFlag : 2..2;
    uint bottom_field_flag : 3..3;
    uint is_reference : 4..4;
    uint complementary_field_pair : 5..5;
  }
}

struct StdVideoDecodeH264PictureInfo {
  char seq_parameter_set_id;
  char pic_parameter_set_id;
  ushort reserved;
  ushort frame_num;
  ushort idr_pic_id;
  int[2] picOrderCnt;
  StdVideoDecodeH264PictureInfoFlags flags;
}

struct StdVideoDecodeH264ReferenceInfoFlags {
  bitstruct : char {
    uint top_field_flag : 0..0;
    uint bottom_field_flag : 1..1;
    uint is_long_term : 2..2;
    uint is_non_existing : 3..3;
  }
}

struct StdVideoDecodeH264ReferenceInfo {
  ushort frameNum;
  ushort reserved;
  int[2] picOrderCnt;
  StdVideoDecodeH264ReferenceInfoFlags flags;
}

struct StdVideoDecodeH264MvcElementFlags {
  bitstruct : char {
    uint non_idr : 0..0;
    uint anchor_pic : 1..1;
    uint inter_view : 2..2;
  }
}

struct StdVideoDecodeH264MvcElement {
  StdVideoDecodeH264MvcElementFlags flags;
  ushort viewOrderIndex;
  ushort viewId;
  ushort temporalId;
  ushort priorityId;
  ushort numOfAnchorRefsInL0;
  ushort[15] viewIdOfAnchorRefsInL0;
  ushort numOfAnchorRefsInL1;
  ushort[15] viewIdOfAnchorRefsInL1;
  ushort numOfNonAnchorRefsInL0;
  ushort[15] viewIdOfNonAnchorRefsInL0;
  ushort numOfNonAnchorRefsInL1;
  ushort[15] viewIdOfNonAnchorRefsInL1;
}

struct StdVideoDecodeH264Mvc {
  uint viewId0;
  uint mvcElementCount;
  StdVideoDecodeH264MvcElement * pMvcElements;
}

typedef VkVideoDecodeH264PictureLayoutFlagBitsEXT = inline CUInt;
const VkVideoDecodeH264PictureLayoutFlagBitsEXT VIDEO_DECODE_H264_PICTURE_LAYOUT_PROGRESSIVE_EXT = 0;
const VkVideoDecodeH264PictureLayoutFlagBitsEXT VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_INTERLEAVED_LINES_BIT_EXT = 0x00000001;
const VkVideoDecodeH264PictureLayoutFlagBitsEXT VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_SEPARATE_PLANES_BIT_EXT = 0x00000002;
const VkVideoDecodeH264PictureLayoutFlagBitsEXT VIDEO_DECODE_H264_PICTURE_LAYOUT_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF;

alias VkVideoDecodeH264PictureLayoutFlagsEXT = VkFlags;

alias VkVideoDecodeH264CreateFlagsEXT = VkFlags;

struct VkVideoDecodeH264ProfileEXT {
  VkStructureType sType;
  void * pNext;
  StdVideoH264ProfileIdc stdProfileIdc;
  VkVideoDecodeH264PictureLayoutFlagsEXT pictureLayout;
}

struct VkVideoDecodeH264CapabilitiesEXT {
  VkStructureType sType;
  void * pNext;
  uint maxLevel;
  VkOffset2D fieldOffsetGranularity;
  VkExtensionProperties stdExtensionVersion;
}

struct VkVideoDecodeH264SessionCreateInfoEXT {
  VkStructureType sType;
  void * pNext;
  VkVideoDecodeH264CreateFlagsEXT flags;
  VkExtensionProperties * pStdExtensionVersion;
}

struct VkVideoDecodeH264SessionParametersAddInfoEXT {
  VkStructureType sType;
  void * pNext;
  uint spsStdCount;
  StdVideoH264SequenceParameterSet * pSpsStd;
  uint ppsStdCount;
  StdVideoH264PictureParameterSet * pPpsStd;
}

struct VkVideoDecodeH264SessionParametersCreateInfoEXT {
  VkStructureType sType;
  void * pNext;
  uint maxSpsStdCount;
  uint maxPpsStdCount;
  VkVideoDecodeH264SessionParametersAddInfoEXT * pParametersAddInfo;
}

struct VkVideoDecodeH264PictureInfoEXT {
  VkStructureType sType;
  void * pNext;
  StdVideoDecodeH264PictureInfo * pStdPictureInfo;
  uint slicesCount;
  uint * pSlicesDataOffsets;
}

struct VkVideoDecodeH264MvcEXT {
  VkStructureType sType;
  void * pNext;
  StdVideoDecodeH264Mvc * pStdMvc;
}

struct VkVideoDecodeH264DpbSlotInfoEXT {
  VkStructureType sType;
  void * pNext;
  StdVideoDecodeH264ReferenceInfo * pStdReferenceInfo;
}

struct StdVideoDecodeH265PictureInfoFlags {
  bitstruct : char {
    uint irapPicFlag : 0..0;
    uint idrPicFlag : 1..1;
    uint isReference : 2..2;
    uint short_term_ref_pic_set_sps_flag : 3..3;
  }
}

struct StdVideoDecodeH265PictureInfo {
  char vps_video_parameter_set_id;
  char sps_seq_parameter_set_id;
  char pps_pic_parameter_set_id;
  char num_short_term_ref_pic_sets;
  int picOrderCntVal;
  ushort numBitsForSTRefPicSetInSlice;
  char numDeltaPocsOfRefRpsIdx;
  char[8] refPicSetStCurrBefore;
  char[8] refPicSetStCurrAfter;
  char[8] refPicSetLtCurr;
  StdVideoDecodeH265PictureInfoFlags flags;
}

struct StdVideoDecodeH265ReferenceInfoFlags {
  bitstruct : char {
    uint is_long_term : 0..0;
    uint is_non_existing : 1..1;
  }
}

struct StdVideoDecodeH265ReferenceInfo {
  int picOrderCntVal;
  StdVideoDecodeH265ReferenceInfoFlags flags;
}

alias VkVideoDecodeH265CreateFlagsEXT = VkFlags;

struct VkVideoDecodeH265ProfileEXT {
  VkStructureType sType;
  void * pNext;
  StdVideoH265ProfileIdc stdProfileIdc;
}

struct VkVideoDecodeH265CapabilitiesEXT {
  VkStructureType sType;
  void * pNext;
  uint maxLevel;
  VkExtensionProperties stdExtensionVersion;
}

struct VkVideoDecodeH265SessionCreateInfoEXT {
  VkStructureType sType;
  void * pNext;
  VkVideoDecodeH265CreateFlagsEXT flags;
  VkExtensionProperties * pStdExtensionVersion;
}

struct VkVideoDecodeH265SessionParametersAddInfoEXT {
  VkStructureType sType;
  void * pNext;
  uint spsStdCount;
  StdVideoH265SequenceParameterSet * pSpsStd;
  uint ppsStdCount;
  StdVideoH265PictureParameterSet * pPpsStd;
}

struct VkVideoDecodeH265SessionParametersCreateInfoEXT {
  VkStructureType sType;
  void * pNext;
  uint maxSpsStdCount;
  uint maxPpsStdCount;
  VkVideoDecodeH265SessionParametersAddInfoEXT * pParametersAddInfo;
}

struct VkVideoDecodeH265PictureInfoEXT {
  VkStructureType sType;
  void * pNext;
  StdVideoDecodeH265PictureInfo * pStdPictureInfo;
  uint slicesCount;
  uint * pSlicesDataOffsets;
}

struct VkVideoDecodeH265DpbSlotInfoEXT {
  VkStructureType sType;
  void * pNext;
  StdVideoDecodeH265ReferenceInfo * pStdReferenceInfo;
}
