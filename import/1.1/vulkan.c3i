
module vulkan::vk;

const VULKAN_H_ = 1;

const VULKAN_CORE_H_ = 1;

const VERSION_1_0 = 1;

macro @make_version(#major, #minor, #patch) {
  return ((#major) << 22) | ((#minor) << 12) | (#patch);
}

const API_VERSION_1_0 = @make_version(1,0,0);

macro @version_major(#version) {
  return (uint)(#version) >> 22;
}

macro @version_minor(#version) {
  return ((uint)(#version) >> 12) & 0x3ff;
}

macro @version_patch(#version) {
  return (uint)(#version) & 0xfff;
}

const HEADER_VERSION = 130;

const NULL_HANDLE = 0;

const LOD_CLAMP_NONE = 1000.0f;

const REMAINING_MIP_LEVELS = (~0U);

const REMAINING_ARRAY_LAYERS = (~0U);

const WHOLE_SIZE = (~0UL);

const ATTACHMENT_UNUSED = (~0U);

const TRUE = 1;

const FALSE = 0;

const QUEUE_FAMILY_IGNORED = (~0U);

const SUBPASS_EXTERNAL = (~0U);

const MAX_PHYSICAL_DEVICE_NAME_SIZE = 256;

const UUID_SIZE = 16;

const MAX_MEMORY_TYPES = 32;

const MAX_MEMORY_HEAPS = 16;

const MAX_EXTENSION_NAME_SIZE = 256;

const MAX_DESCRIPTION_SIZE = 256;

const VERSION_1_1 = 1;

const API_VERSION_1_1 = @make_version(1,1,0);

const MAX_DEVICE_GROUP_SIZE = 32;

const LUID_SIZE = 8;

const QUEUE_FAMILY_EXTERNAL = (~0U-1);

const KHR_SURFACE = 1;

const KHR_SURFACE_SPEC_VERSION = 25;

const KHR_SURFACE_EXTENSION_NAME = "VK_KHR_surface";

const KHR_SWAPCHAIN = 1;

const KHR_SWAPCHAIN_SPEC_VERSION = 70;

const KHR_SWAPCHAIN_EXTENSION_NAME = "VK_KHR_swapchain";

const KHR_DISPLAY = 1;

const KHR_DISPLAY_SPEC_VERSION = 23;

const KHR_DISPLAY_EXTENSION_NAME = "VK_KHR_display";

const KHR_DISPLAY_SWAPCHAIN = 1;

const KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION = 10;

const KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME = "VK_KHR_display_swapchain";

const KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE = 1;

const KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_SPEC_VERSION = 3;

const KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME = "VK_KHR_sampler_mirror_clamp_to_edge";

const KHR_MULTIVIEW = 1;

const KHR_MULTIVIEW_SPEC_VERSION = 1;

const KHR_MULTIVIEW_EXTENSION_NAME = "VK_KHR_multiview";

const KHR_GET_PHYSICAL_DEVICE_PROPERTIES2 = 1;

const KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_SPEC_VERSION = 2;

const KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME = "VK_KHR_get_physical_device_properties2";

const KHR_DEVICE_GROUP = 1;

const KHR_DEVICE_GROUP_SPEC_VERSION = 4;

const KHR_DEVICE_GROUP_EXTENSION_NAME = "VK_KHR_device_group";

const KHR_SHADER_DRAW_PARAMETERS = 1;

const KHR_SHADER_DRAW_PARAMETERS_SPEC_VERSION = 1;

const KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME = "VK_KHR_shader_draw_parameters";

const KHR_MAINTENANCE1 = 1;

const KHR_MAINTENANCE1_SPEC_VERSION = 2;

const KHR_MAINTENANCE1_EXTENSION_NAME = "VK_KHR_maintenance1";

const KHR_DEVICE_GROUP_CREATION = 1;

const KHR_DEVICE_GROUP_CREATION_SPEC_VERSION = 1;

const KHR_DEVICE_GROUP_CREATION_EXTENSION_NAME = "VK_KHR_device_group_creation";

const MAX_DEVICE_GROUP_SIZE_KHR = MAX_DEVICE_GROUP_SIZE;

const KHR_EXTERNAL_MEMORY_CAPABILITIES = 1;

const KHR_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION = 1;

const KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME = "VK_KHR_external_memory_capabilities";

const LUID_SIZE_KHR = LUID_SIZE;

const KHR_EXTERNAL_MEMORY = 1;

const KHR_EXTERNAL_MEMORY_SPEC_VERSION = 1;

const KHR_EXTERNAL_MEMORY_EXTENSION_NAME = "VK_KHR_external_memory";

const QUEUE_FAMILY_EXTERNAL_KHR = QUEUE_FAMILY_EXTERNAL;

const KHR_EXTERNAL_MEMORY_FD = 1;

const KHR_EXTERNAL_MEMORY_FD_SPEC_VERSION = 1;

const KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME = "VK_KHR_external_memory_fd";

const KHR_EXTERNAL_SEMAPHORE_CAPABILITIES = 1;

const KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_SPEC_VERSION = 1;

const KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME = "VK_KHR_external_semaphore_capabilities";

const KHR_EXTERNAL_SEMAPHORE = 1;

const KHR_EXTERNAL_SEMAPHORE_SPEC_VERSION = 1;

const KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME = "VK_KHR_external_semaphore";

const KHR_EXTERNAL_SEMAPHORE_FD = 1;

const KHR_EXTERNAL_SEMAPHORE_FD_SPEC_VERSION = 1;

const KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME = "VK_KHR_external_semaphore_fd";

const KHR_PUSH_DESCRIPTOR = 1;

const KHR_PUSH_DESCRIPTOR_SPEC_VERSION = 2;

const KHR_PUSH_DESCRIPTOR_EXTENSION_NAME = "VK_KHR_push_descriptor";

const KHR_SHADER_FLOAT16_INT8 = 1;

const KHR_SHADER_FLOAT16_INT8_SPEC_VERSION = 1;

const KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME = "VK_KHR_shader_float16_int8";

const KHR_16BIT_STORAGE = 1;

const KHR_16BIT_STORAGE_SPEC_VERSION = 1;

const KHR_16BIT_STORAGE_EXTENSION_NAME = "VK_KHR_16bit_storage";

const KHR_INCREMENTAL_PRESENT = 1;

const KHR_INCREMENTAL_PRESENT_SPEC_VERSION = 1;

const KHR_INCREMENTAL_PRESENT_EXTENSION_NAME = "VK_KHR_incremental_present";

const KHR_DESCRIPTOR_UPDATE_TEMPLATE = 1;

const KHR_DESCRIPTOR_UPDATE_TEMPLATE_SPEC_VERSION = 1;

const KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME = "VK_KHR_descriptor_update_template";

const KHR_IMAGELESS_FRAMEBUFFER = 1;

const KHR_IMAGELESS_FRAMEBUFFER_SPEC_VERSION = 1;

const KHR_IMAGELESS_FRAMEBUFFER_EXTENSION_NAME = "VK_KHR_imageless_framebuffer";

const KHR_CREATE_RENDERPASS2 = 1;

const KHR_CREATE_RENDERPASS_2_SPEC_VERSION = 1;

const KHR_CREATE_RENDERPASS_2_EXTENSION_NAME = "VK_KHR_create_renderpass2";

const KHR_SHARED_PRESENTABLE_IMAGE = 1;

const KHR_SHARED_PRESENTABLE_IMAGE_SPEC_VERSION = 1;

const KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME = "VK_KHR_shared_presentable_image";

const KHR_EXTERNAL_FENCE_CAPABILITIES = 1;

const KHR_EXTERNAL_FENCE_CAPABILITIES_SPEC_VERSION = 1;

const KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME = "VK_KHR_external_fence_capabilities";

const KHR_EXTERNAL_FENCE = 1;

const KHR_EXTERNAL_FENCE_SPEC_VERSION = 1;

const KHR_EXTERNAL_FENCE_EXTENSION_NAME = "VK_KHR_external_fence";

const KHR_EXTERNAL_FENCE_FD = 1;

const KHR_EXTERNAL_FENCE_FD_SPEC_VERSION = 1;

const KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME = "VK_KHR_external_fence_fd";

const KHR_PERFORMANCE_QUERY = 1;

const KHR_PERFORMANCE_QUERY_SPEC_VERSION = 1;

const KHR_PERFORMANCE_QUERY_EXTENSION_NAME = "VK_KHR_performance_query";

const KHR_MAINTENANCE2 = 1;

const KHR_MAINTENANCE2_SPEC_VERSION = 1;

const KHR_MAINTENANCE2_EXTENSION_NAME = "VK_KHR_maintenance2";

const KHR_GET_SURFACE_CAPABILITIES2 = 1;

const KHR_GET_SURFACE_CAPABILITIES_2_SPEC_VERSION = 1;

const KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME = "VK_KHR_get_surface_capabilities2";

const KHR_VARIABLE_POINTERS = 1;

const KHR_VARIABLE_POINTERS_SPEC_VERSION = 1;

const KHR_VARIABLE_POINTERS_EXTENSION_NAME = "VK_KHR_variable_pointers";

const KHR_GET_DISPLAY_PROPERTIES2 = 1;

const KHR_GET_DISPLAY_PROPERTIES_2_SPEC_VERSION = 1;

const KHR_GET_DISPLAY_PROPERTIES_2_EXTENSION_NAME = "VK_KHR_get_display_properties2";

const KHR_DEDICATED_ALLOCATION = 1;

const KHR_DEDICATED_ALLOCATION_SPEC_VERSION = 3;

const KHR_DEDICATED_ALLOCATION_EXTENSION_NAME = "VK_KHR_dedicated_allocation";

const KHR_STORAGE_BUFFER_STORAGE_CLASS = 1;

const KHR_STORAGE_BUFFER_STORAGE_CLASS_SPEC_VERSION = 1;

const KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME = "VK_KHR_storage_buffer_storage_class";

const KHR_RELAXED_BLOCK_LAYOUT = 1;

const KHR_RELAXED_BLOCK_LAYOUT_SPEC_VERSION = 1;

const KHR_RELAXED_BLOCK_LAYOUT_EXTENSION_NAME = "VK_KHR_relaxed_block_layout";

const KHR_GET_MEMORY_REQUIREMENTS2 = 1;

const KHR_GET_MEMORY_REQUIREMENTS_2_SPEC_VERSION = 1;

const KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME = "VK_KHR_get_memory_requirements2";

const KHR_IMAGE_FORMAT_LIST = 1;

const KHR_IMAGE_FORMAT_LIST_SPEC_VERSION = 1;

const KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME = "VK_KHR_image_format_list";

const KHR_SAMPLER_YCBCR_CONVERSION = 1;

const KHR_SAMPLER_YCBCR_CONVERSION_SPEC_VERSION = 14;

const KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME = "VK_KHR_sampler_ycbcr_conversion";

const KHR_BIND_MEMORY2 = 1;

const KHR_BIND_MEMORY_2_SPEC_VERSION = 1;

const KHR_BIND_MEMORY_2_EXTENSION_NAME = "VK_KHR_bind_memory2";

const KHR_MAINTENANCE3 = 1;

const KHR_MAINTENANCE3_SPEC_VERSION = 1;

const KHR_MAINTENANCE3_EXTENSION_NAME = "VK_KHR_maintenance3";

const KHR_DRAW_INDIRECT_COUNT = 1;

const KHR_DRAW_INDIRECT_COUNT_SPEC_VERSION = 1;

const KHR_DRAW_INDIRECT_COUNT_EXTENSION_NAME = "VK_KHR_draw_indirect_count";

const KHR_SHADER_SUBGROUP_EXTENDED_TYPES = 1;

const KHR_SHADER_SUBGROUP_EXTENDED_TYPES_SPEC_VERSION = 1;

const KHR_SHADER_SUBGROUP_EXTENDED_TYPES_EXTENSION_NAME = "VK_KHR_shader_subgroup_extended_types";

const KHR_8BIT_STORAGE = 1;

const KHR_8BIT_STORAGE_SPEC_VERSION = 1;

const KHR_8BIT_STORAGE_EXTENSION_NAME = "VK_KHR_8bit_storage";

const KHR_SHADER_ATOMIC_INT64 = 1;

const KHR_SHADER_ATOMIC_INT64_SPEC_VERSION = 1;

const KHR_SHADER_ATOMIC_INT64_EXTENSION_NAME = "VK_KHR_shader_atomic_int64";

const KHR_SHADER_CLOCK = 1;

const KHR_SHADER_CLOCK_SPEC_VERSION = 1;

const KHR_SHADER_CLOCK_EXTENSION_NAME = "VK_KHR_shader_clock";

const KHR_DRIVER_PROPERTIES = 1;

const MAX_DRIVER_NAME_SIZE_KHR = 256;

const MAX_DRIVER_INFO_SIZE_KHR = 256;

const KHR_DRIVER_PROPERTIES_SPEC_VERSION = 1;

const KHR_DRIVER_PROPERTIES_EXTENSION_NAME = "VK_KHR_driver_properties";

const KHR_SHADER_FLOAT_CONTROLS = 1;

const KHR_SHADER_FLOAT_CONTROLS_SPEC_VERSION = 4;

const KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME = "VK_KHR_shader_float_controls";

const KHR_DEPTH_STENCIL_RESOLVE = 1;

const KHR_DEPTH_STENCIL_RESOLVE_SPEC_VERSION = 1;

const KHR_DEPTH_STENCIL_RESOLVE_EXTENSION_NAME = "VK_KHR_depth_stencil_resolve";

const KHR_SWAPCHAIN_MUTABLE_FORMAT = 1;

const KHR_SWAPCHAIN_MUTABLE_FORMAT_SPEC_VERSION = 1;

const KHR_SWAPCHAIN_MUTABLE_FORMAT_EXTENSION_NAME = "VK_KHR_swapchain_mutable_format";

const KHR_TIMELINE_SEMAPHORE = 1;

const KHR_TIMELINE_SEMAPHORE_SPEC_VERSION = 2;

const KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME = "VK_KHR_timeline_semaphore";

const KHR_VULKAN_MEMORY_MODEL = 1;

const KHR_VULKAN_MEMORY_MODEL_SPEC_VERSION = 3;

const KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME = "VK_KHR_vulkan_memory_model";

const KHR_SPIRV_1_4 = 1;

const KHR_SPIRV_1_4_SPEC_VERSION = 1;

const KHR_SPIRV_1_4_EXTENSION_NAME = "VK_KHR_spirv_1_4";

const KHR_SURFACE_PROTECTED_CAPABILITIES = 1;

const KHR_SURFACE_PROTECTED_CAPABILITIES_SPEC_VERSION = 1;

const KHR_SURFACE_PROTECTED_CAPABILITIES_EXTENSION_NAME = "VK_KHR_surface_protected_capabilities";

const KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS = 1;

const KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_SPEC_VERSION = 1;

const KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_EXTENSION_NAME = "VK_KHR_separate_depth_stencil_layouts";

const KHR_UNIFORM_BUFFER_STANDARD_LAYOUT = 1;

const KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_SPEC_VERSION = 1;

const KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_EXTENSION_NAME = "VK_KHR_uniform_buffer_standard_layout";

const KHR_BUFFER_DEVICE_ADDRESS = 1;

const KHR_BUFFER_DEVICE_ADDRESS_SPEC_VERSION = 1;

const KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME = "VK_KHR_buffer_device_address";

const KHR_PIPELINE_EXECUTABLE_PROPERTIES = 1;

const KHR_PIPELINE_EXECUTABLE_PROPERTIES_SPEC_VERSION = 1;

const KHR_PIPELINE_EXECUTABLE_PROPERTIES_EXTENSION_NAME = "VK_KHR_pipeline_executable_properties";

const EXT_DEBUG_REPORT = 1;

const EXT_DEBUG_REPORT_SPEC_VERSION = 9;

const EXT_DEBUG_REPORT_EXTENSION_NAME = "VK_EXT_debug_report";

const NV_GLSL_SHADER = 1;

const NV_GLSL_SHADER_SPEC_VERSION = 1;

const NV_GLSL_SHADER_EXTENSION_NAME = "VK_NV_glsl_shader";

const EXT_DEPTH_RANGE_UNRESTRICTED = 1;

const EXT_DEPTH_RANGE_UNRESTRICTED_SPEC_VERSION = 1;

const EXT_DEPTH_RANGE_UNRESTRICTED_EXTENSION_NAME = "VK_EXT_depth_range_unrestricted";

const IMG_FILTER_CUBIC = 1;

const IMG_FILTER_CUBIC_SPEC_VERSION = 1;

const IMG_FILTER_CUBIC_EXTENSION_NAME = "VK_IMG_filter_cubic";

const AMD_RASTERIZATION_ORDER = 1;

const AMD_RASTERIZATION_ORDER_SPEC_VERSION = 1;

const AMD_RASTERIZATION_ORDER_EXTENSION_NAME = "VK_AMD_rasterization_order";

const AMD_SHADER_TRINARY_MINMAX = 1;

const AMD_SHADER_TRINARY_MINMAX_SPEC_VERSION = 1;

const AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME = "VK_AMD_shader_trinary_minmax";

const AMD_SHADER_EXPLICIT_VERTEX_PARAMETER = 1;

const AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_SPEC_VERSION = 1;

const AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME = "VK_AMD_shader_explicit_vertex_parameter";

const EXT_DEBUG_MARKER = 1;

const EXT_DEBUG_MARKER_SPEC_VERSION = 4;

const EXT_DEBUG_MARKER_EXTENSION_NAME = "VK_EXT_debug_marker";

const AMD_GCN_SHADER = 1;

const AMD_GCN_SHADER_SPEC_VERSION = 1;

const AMD_GCN_SHADER_EXTENSION_NAME = "VK_AMD_gcn_shader";

const NV_DEDICATED_ALLOCATION = 1;

const NV_DEDICATED_ALLOCATION_SPEC_VERSION = 1;

const NV_DEDICATED_ALLOCATION_EXTENSION_NAME = "VK_NV_dedicated_allocation";

const EXT_TRANSFORM_FEEDBACK = 1;

const EXT_TRANSFORM_FEEDBACK_SPEC_VERSION = 1;

const EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME = "VK_EXT_transform_feedback";

const NVX_IMAGE_VIEW_HANDLE = 1;

const NVX_IMAGE_VIEW_HANDLE_SPEC_VERSION = 1;

const NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME = "VK_NVX_image_view_handle";

const AMD_DRAW_INDIRECT_COUNT = 1;

const AMD_DRAW_INDIRECT_COUNT_SPEC_VERSION = 2;

const AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME = "VK_AMD_draw_indirect_count";

const AMD_NEGATIVE_VIEWPORT_HEIGHT = 1;

const AMD_NEGATIVE_VIEWPORT_HEIGHT_SPEC_VERSION = 1;

const AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME = "VK_AMD_negative_viewport_height";

const AMD_GPU_SHADER_HALF_FLOAT = 1;

const AMD_GPU_SHADER_HALF_FLOAT_SPEC_VERSION = 2;

const AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME = "VK_AMD_gpu_shader_half_float";

const AMD_SHADER_BALLOT = 1;

const AMD_SHADER_BALLOT_SPEC_VERSION = 1;

const AMD_SHADER_BALLOT_EXTENSION_NAME = "VK_AMD_shader_ballot";

const AMD_TEXTURE_GATHER_BIAS_LOD = 1;

const AMD_TEXTURE_GATHER_BIAS_LOD_SPEC_VERSION = 1;

const AMD_TEXTURE_GATHER_BIAS_LOD_EXTENSION_NAME = "VK_AMD_texture_gather_bias_lod";

const AMD_SHADER_INFO = 1;

const AMD_SHADER_INFO_SPEC_VERSION = 1;

const AMD_SHADER_INFO_EXTENSION_NAME = "VK_AMD_shader_info";

const AMD_SHADER_IMAGE_LOAD_STORE_LOD = 1;

const AMD_SHADER_IMAGE_LOAD_STORE_LOD_SPEC_VERSION = 1;

const AMD_SHADER_IMAGE_LOAD_STORE_LOD_EXTENSION_NAME = "VK_AMD_shader_image_load_store_lod";

const NV_CORNER_SAMPLED_IMAGE = 1;

const NV_CORNER_SAMPLED_IMAGE_SPEC_VERSION = 2;

const NV_CORNER_SAMPLED_IMAGE_EXTENSION_NAME = "VK_NV_corner_sampled_image";

const IMG_FORMAT_PVRTC = 1;

const IMG_FORMAT_PVRTC_SPEC_VERSION = 1;

const IMG_FORMAT_PVRTC_EXTENSION_NAME = "VK_IMG_format_pvrtc";

const NV_EXTERNAL_MEMORY_CAPABILITIES = 1;

const NV_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION = 1;

const NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME = "VK_NV_external_memory_capabilities";

const NV_EXTERNAL_MEMORY = 1;

const NV_EXTERNAL_MEMORY_SPEC_VERSION = 1;

const NV_EXTERNAL_MEMORY_EXTENSION_NAME = "VK_NV_external_memory";

const EXT_VALIDATION_FLAGS = 1;

const EXT_VALIDATION_FLAGS_SPEC_VERSION = 2;

const EXT_VALIDATION_FLAGS_EXTENSION_NAME = "VK_EXT_validation_flags";

const EXT_SHADER_SUBGROUP_BALLOT = 1;

const EXT_SHADER_SUBGROUP_BALLOT_SPEC_VERSION = 1;

const EXT_SHADER_SUBGROUP_BALLOT_EXTENSION_NAME = "VK_EXT_shader_subgroup_ballot";

const EXT_SHADER_SUBGROUP_VOTE = 1;

const EXT_SHADER_SUBGROUP_VOTE_SPEC_VERSION = 1;

const EXT_SHADER_SUBGROUP_VOTE_EXTENSION_NAME = "VK_EXT_shader_subgroup_vote";

const EXT_TEXTURE_COMPRESSION_ASTC_HDR = 1;

const EXT_TEXTURE_COMPRESSION_ASTC_HDR_SPEC_VERSION = 1;

const EXT_TEXTURE_COMPRESSION_ASTC_HDR_EXTENSION_NAME = "VK_EXT_texture_compression_astc_hdr";

const EXT_ASTC_DECODE_MODE = 1;

const EXT_ASTC_DECODE_MODE_SPEC_VERSION = 1;

const EXT_ASTC_DECODE_MODE_EXTENSION_NAME = "VK_EXT_astc_decode_mode";

const EXT_CONDITIONAL_RENDERING = 1;

const EXT_CONDITIONAL_RENDERING_SPEC_VERSION = 2;

const EXT_CONDITIONAL_RENDERING_EXTENSION_NAME = "VK_EXT_conditional_rendering";

const NVX_DEVICE_GENERATED_COMMANDS = 1;

const NVX_DEVICE_GENERATED_COMMANDS_SPEC_VERSION = 3;

const NVX_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME = "VK_NVX_device_generated_commands";

const NV_CLIP_SPACE_W_SCALING = 1;

const NV_CLIP_SPACE_W_SCALING_SPEC_VERSION = 1;

const NV_CLIP_SPACE_W_SCALING_EXTENSION_NAME = "VK_NV_clip_space_w_scaling";

const EXT_DIRECT_MODE_DISPLAY = 1;

const EXT_DIRECT_MODE_DISPLAY_SPEC_VERSION = 1;

const EXT_DIRECT_MODE_DISPLAY_EXTENSION_NAME = "VK_EXT_direct_mode_display";

const EXT_DISPLAY_SURFACE_COUNTER = 1;

const EXT_DISPLAY_SURFACE_COUNTER_SPEC_VERSION = 1;

const EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME = "VK_EXT_display_surface_counter";

const EXT_DISPLAY_CONTROL = 1;

const EXT_DISPLAY_CONTROL_SPEC_VERSION = 1;

const EXT_DISPLAY_CONTROL_EXTENSION_NAME = "VK_EXT_display_control";

const GOOGLE_DISPLAY_TIMING = 1;

const GOOGLE_DISPLAY_TIMING_SPEC_VERSION = 1;

const GOOGLE_DISPLAY_TIMING_EXTENSION_NAME = "VK_GOOGLE_display_timing";

const NV_SAMPLE_MASK_OVERRIDE_COVERAGE = 1;

const NV_SAMPLE_MASK_OVERRIDE_COVERAGE_SPEC_VERSION = 1;

const NV_SAMPLE_MASK_OVERRIDE_COVERAGE_EXTENSION_NAME = "VK_NV_sample_mask_override_coverage";

const NV_GEOMETRY_SHADER_PASSTHROUGH = 1;

const NV_GEOMETRY_SHADER_PASSTHROUGH_SPEC_VERSION = 1;

const NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME = "VK_NV_geometry_shader_passthrough";

const NV_VIEWPORT_ARRAY2 = 1;

const NV_VIEWPORT_ARRAY2_SPEC_VERSION = 1;

const NV_VIEWPORT_ARRAY2_EXTENSION_NAME = "VK_NV_viewport_array2";

const NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES = 1;

const NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_SPEC_VERSION = 1;

const NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_EXTENSION_NAME = "VK_NVX_multiview_per_view_attributes";

const NV_VIEWPORT_SWIZZLE = 1;

const NV_VIEWPORT_SWIZZLE_SPEC_VERSION = 1;

const NV_VIEWPORT_SWIZZLE_EXTENSION_NAME = "VK_NV_viewport_swizzle";

const EXT_DISCARD_RECTANGLES = 1;

const EXT_DISCARD_RECTANGLES_SPEC_VERSION = 1;

const EXT_DISCARD_RECTANGLES_EXTENSION_NAME = "VK_EXT_discard_rectangles";

const EXT_CONSERVATIVE_RASTERIZATION = 1;

const EXT_CONSERVATIVE_RASTERIZATION_SPEC_VERSION = 1;

const EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME = "VK_EXT_conservative_rasterization";

const EXT_DEPTH_CLIP_ENABLE = 1;

const EXT_DEPTH_CLIP_ENABLE_SPEC_VERSION = 1;

const EXT_DEPTH_CLIP_ENABLE_EXTENSION_NAME = "VK_EXT_depth_clip_enable";

const EXT_SWAPCHAIN_COLORSPACE = 1;

const EXT_SWAPCHAIN_COLOR_SPACE_SPEC_VERSION = 4;

const EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME = "VK_EXT_swapchain_colorspace";

const EXT_HDR_METADATA = 1;

const EXT_HDR_METADATA_SPEC_VERSION = 2;

const EXT_HDR_METADATA_EXTENSION_NAME = "VK_EXT_hdr_metadata";

const EXT_EXTERNAL_MEMORY_DMA_BUF = 1;

const EXT_EXTERNAL_MEMORY_DMA_BUF_SPEC_VERSION = 1;

const EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME = "VK_EXT_external_memory_dma_buf";

const EXT_QUEUE_FAMILY_FOREIGN = 1;

const EXT_QUEUE_FAMILY_FOREIGN_SPEC_VERSION = 1;

const EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME = "VK_EXT_queue_family_foreign";

const QUEUE_FAMILY_FOREIGN_EXT = (~0U-2);

const EXT_DEBUG_UTILS = 1;

const EXT_DEBUG_UTILS_SPEC_VERSION = 1;

const EXT_DEBUG_UTILS_EXTENSION_NAME = "VK_EXT_debug_utils";

const EXT_SAMPLER_FILTER_MINMAX = 1;

const EXT_SAMPLER_FILTER_MINMAX_SPEC_VERSION = 2;

const EXT_SAMPLER_FILTER_MINMAX_EXTENSION_NAME = "VK_EXT_sampler_filter_minmax";

const AMD_GPU_SHADER_INT16 = 1;

const AMD_GPU_SHADER_INT16_SPEC_VERSION = 2;

const AMD_GPU_SHADER_INT16_EXTENSION_NAME = "VK_AMD_gpu_shader_int16";

const AMD_MIXED_ATTACHMENT_SAMPLES = 1;

const AMD_MIXED_ATTACHMENT_SAMPLES_SPEC_VERSION = 1;

const AMD_MIXED_ATTACHMENT_SAMPLES_EXTENSION_NAME = "VK_AMD_mixed_attachment_samples";

const AMD_SHADER_FRAGMENT_MASK = 1;

const AMD_SHADER_FRAGMENT_MASK_SPEC_VERSION = 1;

const AMD_SHADER_FRAGMENT_MASK_EXTENSION_NAME = "VK_AMD_shader_fragment_mask";

const EXT_INLINE_UNIFORM_BLOCK = 1;

const EXT_INLINE_UNIFORM_BLOCK_SPEC_VERSION = 1;

const EXT_INLINE_UNIFORM_BLOCK_EXTENSION_NAME = "VK_EXT_inline_uniform_block";

const EXT_SHADER_STENCIL_EXPORT = 1;

const EXT_SHADER_STENCIL_EXPORT_SPEC_VERSION = 1;

const EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME = "VK_EXT_shader_stencil_export";

const EXT_SAMPLE_LOCATIONS = 1;

const EXT_SAMPLE_LOCATIONS_SPEC_VERSION = 1;

const EXT_SAMPLE_LOCATIONS_EXTENSION_NAME = "VK_EXT_sample_locations";

const EXT_BLEND_OPERATION_ADVANCED = 1;

const EXT_BLEND_OPERATION_ADVANCED_SPEC_VERSION = 2;

const EXT_BLEND_OPERATION_ADVANCED_EXTENSION_NAME = "VK_EXT_blend_operation_advanced";

const NV_FRAGMENT_COVERAGE_TO_COLOR = 1;

const NV_FRAGMENT_COVERAGE_TO_COLOR_SPEC_VERSION = 1;

const NV_FRAGMENT_COVERAGE_TO_COLOR_EXTENSION_NAME = "VK_NV_fragment_coverage_to_color";

const NV_FRAMEBUFFER_MIXED_SAMPLES = 1;

const NV_FRAMEBUFFER_MIXED_SAMPLES_SPEC_VERSION = 1;

const NV_FRAMEBUFFER_MIXED_SAMPLES_EXTENSION_NAME = "VK_NV_framebuffer_mixed_samples";

const NV_FILL_RECTANGLE = 1;

const NV_FILL_RECTANGLE_SPEC_VERSION = 1;

const NV_FILL_RECTANGLE_EXTENSION_NAME = "VK_NV_fill_rectangle";

const NV_SHADER_SM_BUILTINS = 1;

const NV_SHADER_SM_BUILTINS_SPEC_VERSION = 1;

const NV_SHADER_SM_BUILTINS_EXTENSION_NAME = "VK_NV_shader_sm_builtins";

const EXT_POST_DEPTH_COVERAGE = 1;

const EXT_POST_DEPTH_COVERAGE_SPEC_VERSION = 1;

const EXT_POST_DEPTH_COVERAGE_EXTENSION_NAME = "VK_EXT_post_depth_coverage";

const EXT_IMAGE_DRM_FORMAT_MODIFIER = 1;

const EXT_IMAGE_DRM_FORMAT_MODIFIER_SPEC_VERSION = 1;

const EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION_NAME = "VK_EXT_image_drm_format_modifier";

const EXT_VALIDATION_CACHE = 1;

const EXT_VALIDATION_CACHE_SPEC_VERSION = 1;

const EXT_VALIDATION_CACHE_EXTENSION_NAME = "VK_EXT_validation_cache";

const EXT_DESCRIPTOR_INDEXING = 1;

const EXT_DESCRIPTOR_INDEXING_SPEC_VERSION = 2;

const EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME = "VK_EXT_descriptor_indexing";

const EXT_SHADER_VIEWPORT_INDEX_LAYER = 1;

const EXT_SHADER_VIEWPORT_INDEX_LAYER_SPEC_VERSION = 1;

const EXT_SHADER_VIEWPORT_INDEX_LAYER_EXTENSION_NAME = "VK_EXT_shader_viewport_index_layer";

const NV_SHADING_RATE_IMAGE = 1;

const NV_SHADING_RATE_IMAGE_SPEC_VERSION = 3;

const NV_SHADING_RATE_IMAGE_EXTENSION_NAME = "VK_NV_shading_rate_image";

const NV_RAY_TRACING = 1;

const NV_RAY_TRACING_SPEC_VERSION = 3;

const NV_RAY_TRACING_EXTENSION_NAME = "VK_NV_ray_tracing";

const SHADER_UNUSED_NV = (~0U);

const NV_REPRESENTATIVE_FRAGMENT_TEST = 1;

const NV_REPRESENTATIVE_FRAGMENT_TEST_SPEC_VERSION = 2;

const NV_REPRESENTATIVE_FRAGMENT_TEST_EXTENSION_NAME = "VK_NV_representative_fragment_test";

const EXT_FILTER_CUBIC = 1;

const EXT_FILTER_CUBIC_SPEC_VERSION = 2;

const EXT_FILTER_CUBIC_EXTENSION_NAME = "VK_EXT_filter_cubic";

const EXT_GLOBAL_PRIORITY = 1;

const EXT_GLOBAL_PRIORITY_SPEC_VERSION = 2;

const EXT_GLOBAL_PRIORITY_EXTENSION_NAME = "VK_EXT_global_priority";

const EXT_EXTERNAL_MEMORY_HOST = 1;

const EXT_EXTERNAL_MEMORY_HOST_SPEC_VERSION = 1;

const EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME = "VK_EXT_external_memory_host";

const AMD_BUFFER_MARKER = 1;

const AMD_BUFFER_MARKER_SPEC_VERSION = 1;

const AMD_BUFFER_MARKER_EXTENSION_NAME = "VK_AMD_buffer_marker";

const AMD_PIPELINE_COMPILER_CONTROL = 1;

const AMD_PIPELINE_COMPILER_CONTROL_SPEC_VERSION = 1;

const AMD_PIPELINE_COMPILER_CONTROL_EXTENSION_NAME = "VK_AMD_pipeline_compiler_control";

const EXT_CALIBRATED_TIMESTAMPS = 1;

const EXT_CALIBRATED_TIMESTAMPS_SPEC_VERSION = 1;

const EXT_CALIBRATED_TIMESTAMPS_EXTENSION_NAME = "VK_EXT_calibrated_timestamps";

const AMD_SHADER_CORE_PROPERTIES = 1;

const AMD_SHADER_CORE_PROPERTIES_SPEC_VERSION = 2;

const AMD_SHADER_CORE_PROPERTIES_EXTENSION_NAME = "VK_AMD_shader_core_properties";

const AMD_MEMORY_OVERALLOCATION_BEHAVIOR = 1;

const AMD_MEMORY_OVERALLOCATION_BEHAVIOR_SPEC_VERSION = 1;

const AMD_MEMORY_OVERALLOCATION_BEHAVIOR_EXTENSION_NAME = "VK_AMD_memory_overallocation_behavior";

const EXT_VERTEX_ATTRIBUTE_DIVISOR = 1;

const EXT_VERTEX_ATTRIBUTE_DIVISOR_SPEC_VERSION = 3;

const EXT_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME = "VK_EXT_vertex_attribute_divisor";

const EXT_PIPELINE_CREATION_FEEDBACK = 1;

const EXT_PIPELINE_CREATION_FEEDBACK_SPEC_VERSION = 1;

const EXT_PIPELINE_CREATION_FEEDBACK_EXTENSION_NAME = "VK_EXT_pipeline_creation_feedback";

const NV_SHADER_SUBGROUP_PARTITIONED = 1;

const NV_SHADER_SUBGROUP_PARTITIONED_SPEC_VERSION = 1;

const NV_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME = "VK_NV_shader_subgroup_partitioned";

const NV_COMPUTE_SHADER_DERIVATIVES = 1;

const NV_COMPUTE_SHADER_DERIVATIVES_SPEC_VERSION = 1;

const NV_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME = "VK_NV_compute_shader_derivatives";

const NV_MESH_SHADER = 1;

const NV_MESH_SHADER_SPEC_VERSION = 1;

const NV_MESH_SHADER_EXTENSION_NAME = "VK_NV_mesh_shader";

const NV_FRAGMENT_SHADER_BARYCENTRIC = 1;

const NV_FRAGMENT_SHADER_BARYCENTRIC_SPEC_VERSION = 1;

const NV_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME = "VK_NV_fragment_shader_barycentric";

const NV_SHADER_IMAGE_FOOTPRINT = 1;

const NV_SHADER_IMAGE_FOOTPRINT_SPEC_VERSION = 2;

const NV_SHADER_IMAGE_FOOTPRINT_EXTENSION_NAME = "VK_NV_shader_image_footprint";

const NV_SCISSOR_EXCLUSIVE = 1;

const NV_SCISSOR_EXCLUSIVE_SPEC_VERSION = 1;

const NV_SCISSOR_EXCLUSIVE_EXTENSION_NAME = "VK_NV_scissor_exclusive";

const NV_DEVICE_DIAGNOSTIC_CHECKPOINTS = 1;

const NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_SPEC_VERSION = 2;

const NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_EXTENSION_NAME = "VK_NV_device_diagnostic_checkpoints";

const INTEL_SHADER_INTEGER_FUNCTIONS2 = 1;

const INTEL_SHADER_INTEGER_FUNCTIONS_2_SPEC_VERSION = 1;

const INTEL_SHADER_INTEGER_FUNCTIONS_2_EXTENSION_NAME = "VK_INTEL_shader_integer_functions2";

const INTEL_PERFORMANCE_QUERY = 1;

const INTEL_PERFORMANCE_QUERY_SPEC_VERSION = 1;

const INTEL_PERFORMANCE_QUERY_EXTENSION_NAME = "VK_INTEL_performance_query";

const EXT_PCI_BUS_INFO = 1;

const EXT_PCI_BUS_INFO_SPEC_VERSION = 2;

const EXT_PCI_BUS_INFO_EXTENSION_NAME = "VK_EXT_pci_bus_info";

const AMD_DISPLAY_NATIVE_HDR = 1;

const AMD_DISPLAY_NATIVE_HDR_SPEC_VERSION = 1;

const AMD_DISPLAY_NATIVE_HDR_EXTENSION_NAME = "VK_AMD_display_native_hdr";

const EXT_FRAGMENT_DENSITY_MAP = 1;

const EXT_FRAGMENT_DENSITY_MAP_SPEC_VERSION = 1;

const EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME = "VK_EXT_fragment_density_map";

const EXT_SCALAR_BLOCK_LAYOUT = 1;

const EXT_SCALAR_BLOCK_LAYOUT_SPEC_VERSION = 1;

const EXT_SCALAR_BLOCK_LAYOUT_EXTENSION_NAME = "VK_EXT_scalar_block_layout";

const GOOGLE_HLSL_FUNCTIONALITY1 = 1;

const GOOGLE_HLSL_FUNCTIONALITY1_SPEC_VERSION = 1;

const GOOGLE_HLSL_FUNCTIONALITY1_EXTENSION_NAME = "VK_GOOGLE_hlsl_functionality1";

const GOOGLE_DECORATE_STRING = 1;

const GOOGLE_DECORATE_STRING_SPEC_VERSION = 1;

const GOOGLE_DECORATE_STRING_EXTENSION_NAME = "VK_GOOGLE_decorate_string";

const EXT_SUBGROUP_SIZE_CONTROL = 1;

const EXT_SUBGROUP_SIZE_CONTROL_SPEC_VERSION = 2;

const EXT_SUBGROUP_SIZE_CONTROL_EXTENSION_NAME = "VK_EXT_subgroup_size_control";

const AMD_SHADER_CORE_PROPERTIES2 = 1;

const AMD_SHADER_CORE_PROPERTIES_2_SPEC_VERSION = 1;

const AMD_SHADER_CORE_PROPERTIES_2_EXTENSION_NAME = "VK_AMD_shader_core_properties2";

const AMD_DEVICE_COHERENT_MEMORY = 1;

const AMD_DEVICE_COHERENT_MEMORY_SPEC_VERSION = 1;

const AMD_DEVICE_COHERENT_MEMORY_EXTENSION_NAME = "VK_AMD_device_coherent_memory";

const EXT_MEMORY_BUDGET = 1;

const EXT_MEMORY_BUDGET_SPEC_VERSION = 1;

const EXT_MEMORY_BUDGET_EXTENSION_NAME = "VK_EXT_memory_budget";

const EXT_MEMORY_PRIORITY = 1;

const EXT_MEMORY_PRIORITY_SPEC_VERSION = 1;

const EXT_MEMORY_PRIORITY_EXTENSION_NAME = "VK_EXT_memory_priority";

const NV_DEDICATED_ALLOCATION_IMAGE_ALIASING = 1;

const NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_SPEC_VERSION = 1;

const NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_EXTENSION_NAME = "VK_NV_dedicated_allocation_image_aliasing";

const EXT_BUFFER_DEVICE_ADDRESS = 1;

const EXT_BUFFER_DEVICE_ADDRESS_SPEC_VERSION = 2;

const EXT_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME = "VK_EXT_buffer_device_address";

const EXT_TOOLING_INFO = 1;

const EXT_TOOLING_INFO_SPEC_VERSION = 1;

const EXT_TOOLING_INFO_EXTENSION_NAME = "VK_EXT_tooling_info";

const EXT_SEPARATE_STENCIL_USAGE = 1;

const EXT_SEPARATE_STENCIL_USAGE_SPEC_VERSION = 1;

const EXT_SEPARATE_STENCIL_USAGE_EXTENSION_NAME = "VK_EXT_separate_stencil_usage";

const EXT_VALIDATION_FEATURES = 1;

const EXT_VALIDATION_FEATURES_SPEC_VERSION = 2;

const EXT_VALIDATION_FEATURES_EXTENSION_NAME = "VK_EXT_validation_features";

const NV_COOPERATIVE_MATRIX = 1;

const NV_COOPERATIVE_MATRIX_SPEC_VERSION = 1;

const NV_COOPERATIVE_MATRIX_EXTENSION_NAME = "VK_NV_cooperative_matrix";

const NV_COVERAGE_REDUCTION_MODE = 1;

const NV_COVERAGE_REDUCTION_MODE_SPEC_VERSION = 1;

const NV_COVERAGE_REDUCTION_MODE_EXTENSION_NAME = "VK_NV_coverage_reduction_mode";

const EXT_FRAGMENT_SHADER_INTERLOCK = 1;

const EXT_FRAGMENT_SHADER_INTERLOCK_SPEC_VERSION = 1;

const EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME = "VK_EXT_fragment_shader_interlock";

const EXT_YCBCR_IMAGE_ARRAYS = 1;

const EXT_YCBCR_IMAGE_ARRAYS_SPEC_VERSION = 1;

const EXT_YCBCR_IMAGE_ARRAYS_EXTENSION_NAME = "VK_EXT_ycbcr_image_arrays";

const EXT_HEADLESS_SURFACE = 1;

const EXT_HEADLESS_SURFACE_SPEC_VERSION = 1;

const EXT_HEADLESS_SURFACE_EXTENSION_NAME = "VK_EXT_headless_surface";

const EXT_LINE_RASTERIZATION = 1;

const EXT_LINE_RASTERIZATION_SPEC_VERSION = 1;

const EXT_LINE_RASTERIZATION_EXTENSION_NAME = "VK_EXT_line_rasterization";

const EXT_HOST_QUERY_RESET = 1;

const EXT_HOST_QUERY_RESET_SPEC_VERSION = 1;

const EXT_HOST_QUERY_RESET_EXTENSION_NAME = "VK_EXT_host_query_reset";

const EXT_INDEX_TYPE_UINT8 = 1;

const EXT_INDEX_TYPE_UINT8_SPEC_VERSION = 1;

const EXT_INDEX_TYPE_UINT8_EXTENSION_NAME = "VK_EXT_index_type_uint8";

const EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION = 1;

const EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_SPEC_VERSION = 1;

const EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_EXTENSION_NAME = "VK_EXT_shader_demote_to_helper_invocation";

const EXT_TEXEL_BUFFER_ALIGNMENT = 1;

const EXT_TEXEL_BUFFER_ALIGNMENT_SPEC_VERSION = 1;

const EXT_TEXEL_BUFFER_ALIGNMENT_EXTENSION_NAME = "VK_EXT_texel_buffer_alignment";

const GOOGLE_USER_TYPE = 1;

const GOOGLE_USER_TYPE_SPEC_VERSION = 1;

const GOOGLE_USER_TYPE_EXTENSION_NAME = "VK_GOOGLE_user_type";

alias VkFlags = uint;

alias VkBool32 = uint;

alias VkDeviceSize = ulong;

alias VkSampleMask = uint;

typedef VkInstance_T = void;

alias VkInstance = VkInstance_T *;

typedef VkPhysicalDevice_T = void;

alias VkPhysicalDevice = VkPhysicalDevice_T *;

typedef VkDevice_T = void;

alias VkDevice = VkDevice_T *;

typedef VkQueue_T = void;

alias VkQueue = VkQueue_T *;

typedef VkSemaphore_T = void;

alias VkSemaphore = VkSemaphore_T *;

typedef VkCommandBuffer_T = void;

alias VkCommandBuffer = VkCommandBuffer_T *;

typedef VkFence_T = void;

alias VkFence = VkFence_T *;

typedef VkDeviceMemory_T = void;

alias VkDeviceMemory = VkDeviceMemory_T *;

typedef VkBuffer_T = void;

alias VkBuffer = VkBuffer_T *;

typedef VkImage_T = void;

alias VkImage = VkImage_T *;

typedef VkEvent_T = void;

alias VkEvent = VkEvent_T *;

typedef VkQueryPool_T = void;

alias VkQueryPool = VkQueryPool_T *;

typedef VkBufferView_T = void;

alias VkBufferView = VkBufferView_T *;

typedef VkImageView_T = void;

alias VkImageView = VkImageView_T *;

typedef VkShaderModule_T = void;

alias VkShaderModule = VkShaderModule_T *;

typedef VkPipelineCache_T = void;

alias VkPipelineCache = VkPipelineCache_T *;

typedef VkPipelineLayout_T = void;

alias VkPipelineLayout = VkPipelineLayout_T *;

typedef VkRenderPass_T = void;

alias VkRenderPass = VkRenderPass_T *;

typedef VkPipeline_T = void;

alias VkPipeline = VkPipeline_T *;

typedef VkDescriptorSetLayout_T = void;

alias VkDescriptorSetLayout = VkDescriptorSetLayout_T *;

typedef VkSampler_T = void;

alias VkSampler = VkSampler_T *;

typedef VkDescriptorPool_T = void;

alias VkDescriptorPool = VkDescriptorPool_T *;

typedef VkDescriptorSet_T = void;

alias VkDescriptorSet = VkDescriptorSet_T *;

typedef VkFramebuffer_T = void;

alias VkFramebuffer = VkFramebuffer_T *;

typedef VkCommandPool_T = void;

alias VkCommandPool = VkCommandPool_T *;

typedef VkPipelineCacheHeaderVersion = inline CUInt;
const VkPipelineCacheHeaderVersion PIPELINE_CACHE_HEADER_VERSION_ONE = 1;
const VkPipelineCacheHeaderVersion PIPELINE_CACHE_HEADER_VERSION_BEGIN_RANGE = PIPELINE_CACHE_HEADER_VERSION_ONE;
const VkPipelineCacheHeaderVersion PIPELINE_CACHE_HEADER_VERSION_END_RANGE = PIPELINE_CACHE_HEADER_VERSION_ONE;
const VkPipelineCacheHeaderVersion PIPELINE_CACHE_HEADER_VERSION_RANGE_SIZE = (PIPELINE_CACHE_HEADER_VERSION_ONE-PIPELINE_CACHE_HEADER_VERSION_ONE+1);
const VkPipelineCacheHeaderVersion PIPELINE_CACHE_HEADER_VERSION_MAX_ENUM = 0x7FFFFFFF;

typedef VkResult = inline CInt;
const VkResult SUCCESS = 0;
const VkResult NOT_READY = 1;
const VkResult TIMEOUT = 2;
const VkResult EVENT_SET = 3;
const VkResult EVENT_RESET = 4;
const VkResult INCOMPLETE = 5;
const VkResult ERROR_OUT_OF_HOST_MEMORY = -1;
const VkResult ERROR_OUT_OF_DEVICE_MEMORY = -2;
const VkResult ERROR_INITIALIZATION_FAILED = -3;
const VkResult ERROR_DEVICE_LOST = -4;
const VkResult ERROR_MEMORY_MAP_FAILED = -5;
const VkResult ERROR_LAYER_NOT_PRESENT = -6;
const VkResult ERROR_EXTENSION_NOT_PRESENT = -7;
const VkResult ERROR_FEATURE_NOT_PRESENT = -8;
const VkResult ERROR_INCOMPATIBLE_DRIVER = -9;
const VkResult ERROR_TOO_MANY_OBJECTS = -10;
const VkResult ERROR_FORMAT_NOT_SUPPORTED = -11;
const VkResult ERROR_FRAGMENTED_POOL = -12;
const VkResult ERROR_OUT_OF_POOL_MEMORY = -1000069000;
const VkResult ERROR_INVALID_EXTERNAL_HANDLE = -1000072003;
const VkResult ERROR_SURFACE_LOST_KHR = -1000000000;
const VkResult ERROR_NATIVE_WINDOW_IN_USE_KHR = -1000000001;
const VkResult SUBOPTIMAL_KHR = 1000001003;
const VkResult ERROR_OUT_OF_DATE_KHR = -1000001004;
const VkResult ERROR_INCOMPATIBLE_DISPLAY_KHR = -1000003001;
const VkResult ERROR_VALIDATION_FAILED_EXT = -1000011001;
const VkResult ERROR_INVALID_SHADER_NV = -1000012000;
const VkResult ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT = -1000158000;
const VkResult ERROR_FRAGMENTATION_EXT = -1000161000;
const VkResult ERROR_NOT_PERMITTED_EXT = -1000174001;
const VkResult ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT = -1000255000;
const VkResult ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR = -1000244000;
const VkResult ERROR_OUT_OF_POOL_MEMORY_KHR = ERROR_OUT_OF_POOL_MEMORY;
const VkResult ERROR_INVALID_EXTERNAL_HANDLE_KHR = ERROR_INVALID_EXTERNAL_HANDLE;
const VkResult ERROR_INVALID_DEVICE_ADDRESS_EXT = ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR;
const VkResult RESULT_BEGIN_RANGE = ERROR_FRAGMENTED_POOL;
const VkResult RESULT_END_RANGE = INCOMPLETE;
const VkResult RESULT_RANGE_SIZE = (INCOMPLETE-ERROR_FRAGMENTED_POOL+1);
const VkResult RESULT_MAX_ENUM = 0x7FFFFFFF;

typedef VkStructureType = inline CUInt;
const VkStructureType STRUCTURE_TYPE_APPLICATION_INFO = 0;
const VkStructureType STRUCTURE_TYPE_INSTANCE_CREATE_INFO = 1;
const VkStructureType STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO = 2;
const VkStructureType STRUCTURE_TYPE_DEVICE_CREATE_INFO = 3;
const VkStructureType STRUCTURE_TYPE_SUBMIT_INFO = 4;
const VkStructureType STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO = 5;
const VkStructureType STRUCTURE_TYPE_MAPPED_MEMORY_RANGE = 6;
const VkStructureType STRUCTURE_TYPE_BIND_SPARSE_INFO = 7;
const VkStructureType STRUCTURE_TYPE_FENCE_CREATE_INFO = 8;
const VkStructureType STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO = 9;
const VkStructureType STRUCTURE_TYPE_EVENT_CREATE_INFO = 10;
const VkStructureType STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO = 11;
const VkStructureType STRUCTURE_TYPE_BUFFER_CREATE_INFO = 12;
const VkStructureType STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO = 13;
const VkStructureType STRUCTURE_TYPE_IMAGE_CREATE_INFO = 14;
const VkStructureType STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO = 15;
const VkStructureType STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO = 16;
const VkStructureType STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO = 17;
const VkStructureType STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO = 18;
const VkStructureType STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = 19;
const VkStructureType STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20;
const VkStructureType STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO = 21;
const VkStructureType STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO = 22;
const VkStructureType STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO = 23;
const VkStructureType STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = 24;
const VkStructureType STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = 25;
const VkStructureType STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = 26;
const VkStructureType STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO = 27;
const VkStructureType STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO = 28;
const VkStructureType STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO = 29;
const VkStructureType STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO = 30;
const VkStructureType STRUCTURE_TYPE_SAMPLER_CREATE_INFO = 31;
const VkStructureType STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO = 32;
const VkStructureType STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO = 33;
const VkStructureType STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO = 34;
const VkStructureType STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET = 35;
const VkStructureType STRUCTURE_TYPE_COPY_DESCRIPTOR_SET = 36;
const VkStructureType STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO = 37;
const VkStructureType STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO = 38;
const VkStructureType STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO = 39;
const VkStructureType STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO = 40;
const VkStructureType STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO = 41;
const VkStructureType STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO = 42;
const VkStructureType STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO = 43;
const VkStructureType STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER = 44;
const VkStructureType STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER = 45;
const VkStructureType STRUCTURE_TYPE_MEMORY_BARRIER = 46;
const VkStructureType STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO = 47;
const VkStructureType STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO = 48;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES = 1000094000;
const VkStructureType STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO = 1000157000;
const VkStructureType STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO = 1000157001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES = 1000083000;
const VkStructureType STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS = 1000127000;
const VkStructureType STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO = 1000127001;
const VkStructureType STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO = 1000060000;
const VkStructureType STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO = 1000060003;
const VkStructureType STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO = 1000060004;
const VkStructureType STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO = 1000060005;
const VkStructureType STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO = 1000060006;
const VkStructureType STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO = 1000060013;
const VkStructureType STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO = 1000060014;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES = 1000070000;
const VkStructureType STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO = 1000070001;
const VkStructureType STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2 = 1000146000;
const VkStructureType STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2 = 1000146001;
const VkStructureType STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2 = 1000146002;
const VkStructureType STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2 = 1000146003;
const VkStructureType STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2 = 1000146004;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 = 1000059000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 = 1000059001;
const VkStructureType STRUCTURE_TYPE_FORMAT_PROPERTIES_2 = 1000059002;
const VkStructureType STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2 = 1000059003;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2 = 1000059004;
const VkStructureType STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2 = 1000059005;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2 = 1000059006;
const VkStructureType STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2 = 1000059007;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2 = 1000059008;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES = 1000117000;
const VkStructureType STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO = 1000117001;
const VkStructureType STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO = 1000117002;
const VkStructureType STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO = 1000117003;
const VkStructureType STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO = 1000053000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES = 1000053001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES = 1000053002;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES = 1000120000;
const VkStructureType STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO = 1000145000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES = 1000145001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES = 1000145002;
const VkStructureType STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2 = 1000145003;
const VkStructureType STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO = 1000156000;
const VkStructureType STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO = 1000156001;
const VkStructureType STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO = 1000156002;
const VkStructureType STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO = 1000156003;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES = 1000156004;
const VkStructureType STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES = 1000156005;
const VkStructureType STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO = 1000085000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO = 1000071000;
const VkStructureType STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES = 1000071001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO = 1000071002;
const VkStructureType STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES = 1000071003;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES = 1000071004;
const VkStructureType STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO = 1000072000;
const VkStructureType STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO = 1000072001;
const VkStructureType STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO = 1000072002;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO = 1000112000;
const VkStructureType STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES = 1000112001;
const VkStructureType STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO = 1000113000;
const VkStructureType STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO = 1000077000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO = 1000076000;
const VkStructureType STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES = 1000076001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES = 1000168000;
const VkStructureType STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT = 1000168001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES = 1000063000;
const VkStructureType STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR = 1000001000;
const VkStructureType STRUCTURE_TYPE_PRESENT_INFO_KHR = 1000001001;
const VkStructureType STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR = 1000060007;
const VkStructureType STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR = 1000060008;
const VkStructureType STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR = 1000060009;
const VkStructureType STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR = 1000060010;
const VkStructureType STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR = 1000060011;
const VkStructureType STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR = 1000060012;
const VkStructureType STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR = 1000002000;
const VkStructureType STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR = 1000002001;
const VkStructureType STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR = 1000003000;
const VkStructureType STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR = 1000004000;
const VkStructureType STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR = 1000005000;
const VkStructureType STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR = 1000006000;
const VkStructureType STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR = 1000008000;
const VkStructureType STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR = 1000009000;
const VkStructureType STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT = 1000011000;
const VkStructureType STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD = 1000018000;
const VkStructureType STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT = 1000022000;
const VkStructureType STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT = 1000022001;
const VkStructureType STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT = 1000022002;
const VkStructureType STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV = 1000026000;
const VkStructureType STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV = 1000026001;
const VkStructureType STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV = 1000026002;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT = 1000028000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT = 1000028001;
const VkStructureType STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT = 1000028002;
const VkStructureType STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX = 1000030000;
const VkStructureType STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD = 1000041000;
const VkStructureType STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP = 1000049000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV = 1000050000;
const VkStructureType STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV = 1000056000;
const VkStructureType STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV = 1000056001;
const VkStructureType STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057000;
const VkStructureType STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057001;
const VkStructureType STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV = 1000058000;
const VkStructureType STRUCTURE_TYPE_VALIDATION_FLAGS_EXT = 1000061000;
const VkStructureType STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN = 1000062000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT = 1000066000;
const VkStructureType STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT = 1000067000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT = 1000067001;
const VkStructureType STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073000;
const VkStructureType STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073001;
const VkStructureType STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR = 1000073002;
const VkStructureType STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR = 1000073003;
const VkStructureType STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR = 1000074000;
const VkStructureType STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR = 1000074001;
const VkStructureType STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR = 1000074002;
const VkStructureType STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR = 1000075000;
const VkStructureType STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078000;
const VkStructureType STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078001;
const VkStructureType STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR = 1000078002;
const VkStructureType STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR = 1000078003;
const VkStructureType STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR = 1000079000;
const VkStructureType STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR = 1000079001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR = 1000080000;
const VkStructureType STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT = 1000081000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT = 1000081001;
const VkStructureType STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT = 1000081002;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR = 1000082000;
const VkStructureType STRUCTURE_TYPE_PRESENT_REGIONS_KHR = 1000084000;
const VkStructureType STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX = 1000086000;
const VkStructureType STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX = 1000086001;
const VkStructureType STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX = 1000086002;
const VkStructureType STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX = 1000086003;
const VkStructureType STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX = 1000086004;
const VkStructureType STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX = 1000086005;
const VkStructureType STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV = 1000087000;
const VkStructureType STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT = 1000090000;
const VkStructureType STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT = 1000091000;
const VkStructureType STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT = 1000091001;
const VkStructureType STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT = 1000091002;
const VkStructureType STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT = 1000091003;
const VkStructureType STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE = 1000092000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX = 1000097000;
const VkStructureType STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV = 1000098000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT = 1000099000;
const VkStructureType STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT = 1000099001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT = 1000101000;
const VkStructureType STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT = 1000101001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT = 1000102000;
const VkStructureType STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT = 1000102001;
const VkStructureType STRUCTURE_TYPE_HDR_METADATA_EXT = 1000105000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR = 1000108000;
const VkStructureType STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR = 1000108001;
const VkStructureType STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR = 1000108002;
const VkStructureType STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR = 1000108003;
const VkStructureType STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR = 1000109000;
const VkStructureType STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR = 1000109001;
const VkStructureType STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR = 1000109002;
const VkStructureType STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR = 1000109003;
const VkStructureType STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR = 1000109004;
const VkStructureType STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR = 1000109005;
const VkStructureType STRUCTURE_TYPE_SUBPASS_END_INFO_KHR = 1000109006;
const VkStructureType STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR = 1000111000;
const VkStructureType STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114000;
const VkStructureType STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114001;
const VkStructureType STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR = 1000114002;
const VkStructureType STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR = 1000115000;
const VkStructureType STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR = 1000115001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR = 1000116000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR = 1000116001;
const VkStructureType STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR = 1000116002;
const VkStructureType STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR = 1000116003;
const VkStructureType STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR = 1000116004;
const VkStructureType STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR = 1000116005;
const VkStructureType STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR = 1000116006;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR = 1000119000;
const VkStructureType STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR = 1000119001;
const VkStructureType STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR = 1000119002;
const VkStructureType STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR = 1000121000;
const VkStructureType STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR = 1000121001;
const VkStructureType STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR = 1000121002;
const VkStructureType STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR = 1000121003;
const VkStructureType STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR = 1000121004;
const VkStructureType STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK = 1000122000;
const VkStructureType STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK = 1000123000;
const VkStructureType STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT = 1000128000;
const VkStructureType STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT = 1000128001;
const VkStructureType STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT = 1000128002;
const VkStructureType STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT = 1000128003;
const VkStructureType STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT = 1000128004;
const VkStructureType STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID = 1000129000;
const VkStructureType STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID = 1000129001;
const VkStructureType STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID = 1000129002;
const VkStructureType STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129003;
const VkStructureType STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129004;
const VkStructureType STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID = 1000129005;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT = 1000130000;
const VkStructureType STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT = 1000130001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT = 1000138000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT = 1000138001;
const VkStructureType STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT = 1000138002;
const VkStructureType STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT = 1000138003;
const VkStructureType STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT = 1000143000;
const VkStructureType STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT = 1000143001;
const VkStructureType STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT = 1000143002;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT = 1000143003;
const VkStructureType STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT = 1000143004;
const VkStructureType STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR = 1000147000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT = 1000148000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT = 1000148001;
const VkStructureType STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT = 1000148002;
const VkStructureType STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV = 1000149000;
const VkStructureType STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV = 1000152000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV = 1000154000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV = 1000154001;
const VkStructureType STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT = 1000158000;
const VkStructureType STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT = 1000158001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT = 1000158002;
const VkStructureType STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT = 1000158003;
const VkStructureType STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT = 1000158004;
const VkStructureType STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT = 1000158005;
const VkStructureType STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160000;
const VkStructureType STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160001;
const VkStructureType STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT = 1000161000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT = 1000161001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT = 1000161002;
const VkStructureType STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT = 1000161003;
const VkStructureType STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT = 1000161004;
const VkStructureType STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV = 1000164000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV = 1000164001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV = 1000164002;
const VkStructureType STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV = 1000164005;
const VkStructureType STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV = 1000165000;
const VkStructureType STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV = 1000165001;
const VkStructureType STRUCTURE_TYPE_GEOMETRY_NV = 1000165003;
const VkStructureType STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV = 1000165004;
const VkStructureType STRUCTURE_TYPE_GEOMETRY_AABB_NV = 1000165005;
const VkStructureType STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV = 1000165006;
const VkStructureType STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV = 1000165007;
const VkStructureType STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV = 1000165008;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV = 1000165009;
const VkStructureType STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV = 1000165011;
const VkStructureType STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV = 1000165012;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV = 1000166000;
const VkStructureType STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV = 1000166001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT = 1000170000;
const VkStructureType STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT = 1000170001;
const VkStructureType STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT = 1000174000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR = 1000175000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR = 1000177000;
const VkStructureType STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT = 1000178000;
const VkStructureType STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT = 1000178001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT = 1000178002;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR = 1000180000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR = 1000181000;
const VkStructureType STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD = 1000183000;
const VkStructureType STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT = 1000184000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD = 1000185000;
const VkStructureType STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD = 1000189000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT = 1000190000;
const VkStructureType STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT = 1000190001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT = 1000190002;
const VkStructureType STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP = 1000191000;
const VkStructureType STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT = 1000192000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR = 1000196000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR = 1000197000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR = 1000199000;
const VkStructureType STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR = 1000199001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV = 1000201000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV = 1000202000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV = 1000202001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV = 1000203000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV = 1000204000;
const VkStructureType STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV = 1000205000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV = 1000205002;
const VkStructureType STRUCTURE_TYPE_CHECKPOINT_DATA_NV = 1000206000;
const VkStructureType STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV = 1000206001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR = 1000207000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR = 1000207001;
const VkStructureType STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR = 1000207002;
const VkStructureType STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR = 1000207003;
const VkStructureType STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR = 1000207004;
const VkStructureType STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR = 1000207005;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL = 1000209000;
const VkStructureType STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL = 1000210000;
const VkStructureType STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL = 1000210001;
const VkStructureType STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL = 1000210002;
const VkStructureType STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL = 1000210003;
const VkStructureType STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL = 1000210004;
const VkStructureType STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL = 1000210005;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR = 1000211000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT = 1000212000;
const VkStructureType STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD = 1000213000;
const VkStructureType STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD = 1000213001;
const VkStructureType STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA = 1000214000;
const VkStructureType STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT = 1000217000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT = 1000218000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT = 1000218001;
const VkStructureType STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT = 1000218002;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT = 1000221000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT = 1000225000;
const VkStructureType STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT = 1000225001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT = 1000225002;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD = 1000227000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD = 1000229000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT = 1000237000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT = 1000238000;
const VkStructureType STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT = 1000238001;
const VkStructureType STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR = 1000239000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV = 1000240000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR = 1000241000;
const VkStructureType STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR = 1000241001;
const VkStructureType STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR = 1000241002;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT = 1000244000;
const VkStructureType STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT = 1000244002;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT = 1000245000;
const VkStructureType STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT = 1000246000;
const VkStructureType STRUCTURE_TYPE_VALIDATION_FEATURES_EXT = 1000247000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV = 1000249000;
const VkStructureType STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV = 1000249001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV = 1000249002;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV = 1000250000;
const VkStructureType STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV = 1000250001;
const VkStructureType STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV = 1000250002;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT = 1000251000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT = 1000252000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR = 1000253000;
const VkStructureType STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT = 1000255000;
const VkStructureType STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT = 1000255002;
const VkStructureType STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT = 1000255001;
const VkStructureType STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT = 1000256000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR = 1000257000;
const VkStructureType STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR = 1000244001;
const VkStructureType STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR = 1000257002;
const VkStructureType STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR = 1000257003;
const VkStructureType STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR = 1000257004;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT = 1000259000;
const VkStructureType STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT = 1000259001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT = 1000259002;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT = 1000261000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT = 1000265000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR = 1000269000;
const VkStructureType STRUCTURE_TYPE_PIPELINE_INFO_KHR = 1000269001;
const VkStructureType STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR = 1000269002;
const VkStructureType STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR = 1000269003;
const VkStructureType STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR = 1000269004;
const VkStructureType STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR = 1000269005;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT = 1000276000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT = 1000281000;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT = 1000281001;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES = STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES = STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES;
const VkStructureType STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT = STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT;
const VkStructureType STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR = STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2;
const VkStructureType STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR = STRUCTURE_TYPE_FORMAT_PROPERTIES_2;
const VkStructureType STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR = STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2;
const VkStructureType STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR = STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2;
const VkStructureType STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR = STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2;
const VkStructureType STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR = STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO;
const VkStructureType STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR = STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO;
const VkStructureType STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR = STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO;
const VkStructureType STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR = STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO;
const VkStructureType STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR = STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO;
const VkStructureType STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR = STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO;
const VkStructureType STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR = STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES;
const VkStructureType STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR = STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO;
const VkStructureType STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR = STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO;
const VkStructureType STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR = STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES;
const VkStructureType STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR = STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO;
const VkStructureType STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR = STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO;
const VkStructureType STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR = STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO;
const VkStructureType STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR = STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES;
const VkStructureType STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR = STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES;
const VkStructureType STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR = STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO;
const VkStructureType STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT = STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO;
const VkStructureType STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR = STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES;
const VkStructureType STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR = STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES;
const VkStructureType STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR = STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO;
const VkStructureType STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR = STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO;
const VkStructureType STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR = STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES;
const VkStructureType STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR = STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS;
const VkStructureType STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR = STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO;
const VkStructureType STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR = STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2;
const VkStructureType STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR = STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2;
const VkStructureType STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR = STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2;
const VkStructureType STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR = STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2;
const VkStructureType STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR = STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2;
const VkStructureType STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR = STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO;
const VkStructureType STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR = STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO;
const VkStructureType STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR = STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO;
const VkStructureType STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR = STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES;
const VkStructureType STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR = STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES;
const VkStructureType STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR = STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO;
const VkStructureType STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR = STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR = STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES;
const VkStructureType STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR = STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT;
const VkStructureType STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT = STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT;
const VkStructureType STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT = STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR;
const VkStructureType STRUCTURE_TYPE_BEGIN_RANGE = STRUCTURE_TYPE_APPLICATION_INFO;
const VkStructureType STRUCTURE_TYPE_END_RANGE = STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO;
const VkStructureType STRUCTURE_TYPE_RANGE_SIZE = (STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO-STRUCTURE_TYPE_APPLICATION_INFO+1);
const VkStructureType STRUCTURE_TYPE_MAX_ENUM = 0x7FFFFFFF;

typedef VkSystemAllocationScope = inline CUInt;
const VkSystemAllocationScope SYSTEM_ALLOCATION_SCOPE_COMMAND = 0;
const VkSystemAllocationScope SYSTEM_ALLOCATION_SCOPE_OBJECT = 1;
const VkSystemAllocationScope SYSTEM_ALLOCATION_SCOPE_CACHE = 2;
const VkSystemAllocationScope SYSTEM_ALLOCATION_SCOPE_DEVICE = 3;
const VkSystemAllocationScope SYSTEM_ALLOCATION_SCOPE_INSTANCE = 4;
const VkSystemAllocationScope SYSTEM_ALLOCATION_SCOPE_BEGIN_RANGE = SYSTEM_ALLOCATION_SCOPE_COMMAND;
const VkSystemAllocationScope SYSTEM_ALLOCATION_SCOPE_END_RANGE = SYSTEM_ALLOCATION_SCOPE_INSTANCE;
const VkSystemAllocationScope SYSTEM_ALLOCATION_SCOPE_RANGE_SIZE = (SYSTEM_ALLOCATION_SCOPE_INSTANCE-SYSTEM_ALLOCATION_SCOPE_COMMAND+1);
const VkSystemAllocationScope SYSTEM_ALLOCATION_SCOPE_MAX_ENUM = 0x7FFFFFFF;

typedef VkInternalAllocationType = inline CUInt;
const VkInternalAllocationType INTERNAL_ALLOCATION_TYPE_EXECUTABLE = 0;
const VkInternalAllocationType INTERNAL_ALLOCATION_TYPE_BEGIN_RANGE = INTERNAL_ALLOCATION_TYPE_EXECUTABLE;
const VkInternalAllocationType INTERNAL_ALLOCATION_TYPE_END_RANGE = INTERNAL_ALLOCATION_TYPE_EXECUTABLE;
const VkInternalAllocationType INTERNAL_ALLOCATION_TYPE_RANGE_SIZE = (INTERNAL_ALLOCATION_TYPE_EXECUTABLE-INTERNAL_ALLOCATION_TYPE_EXECUTABLE+1);
const VkInternalAllocationType INTERNAL_ALLOCATION_TYPE_MAX_ENUM = 0x7FFFFFFF;

typedef VkFormat = inline CUInt;
const VkFormat FORMAT_UNDEFINED = 0;
const VkFormat FORMAT_R4G4_UNORM_PACK8 = 1;
const VkFormat FORMAT_R4G4B4A4_UNORM_PACK16 = 2;
const VkFormat FORMAT_B4G4R4A4_UNORM_PACK16 = 3;
const VkFormat FORMAT_R5G6B5_UNORM_PACK16 = 4;
const VkFormat FORMAT_B5G6R5_UNORM_PACK16 = 5;
const VkFormat FORMAT_R5G5B5A1_UNORM_PACK16 = 6;
const VkFormat FORMAT_B5G5R5A1_UNORM_PACK16 = 7;
const VkFormat FORMAT_A1R5G5B5_UNORM_PACK16 = 8;
const VkFormat FORMAT_R8_UNORM = 9;
const VkFormat FORMAT_R8_SNORM = 10;
const VkFormat FORMAT_R8_USCALED = 11;
const VkFormat FORMAT_R8_SSCALED = 12;
const VkFormat FORMAT_R8_UINT = 13;
const VkFormat FORMAT_R8_SINT = 14;
const VkFormat FORMAT_R8_SRGB = 15;
const VkFormat FORMAT_R8G8_UNORM = 16;
const VkFormat FORMAT_R8G8_SNORM = 17;
const VkFormat FORMAT_R8G8_USCALED = 18;
const VkFormat FORMAT_R8G8_SSCALED = 19;
const VkFormat FORMAT_R8G8_UINT = 20;
const VkFormat FORMAT_R8G8_SINT = 21;
const VkFormat FORMAT_R8G8_SRGB = 22;
const VkFormat FORMAT_R8G8B8_UNORM = 23;
const VkFormat FORMAT_R8G8B8_SNORM = 24;
const VkFormat FORMAT_R8G8B8_USCALED = 25;
const VkFormat FORMAT_R8G8B8_SSCALED = 26;
const VkFormat FORMAT_R8G8B8_UINT = 27;
const VkFormat FORMAT_R8G8B8_SINT = 28;
const VkFormat FORMAT_R8G8B8_SRGB = 29;
const VkFormat FORMAT_B8G8R8_UNORM = 30;
const VkFormat FORMAT_B8G8R8_SNORM = 31;
const VkFormat FORMAT_B8G8R8_USCALED = 32;
const VkFormat FORMAT_B8G8R8_SSCALED = 33;
const VkFormat FORMAT_B8G8R8_UINT = 34;
const VkFormat FORMAT_B8G8R8_SINT = 35;
const VkFormat FORMAT_B8G8R8_SRGB = 36;
const VkFormat FORMAT_R8G8B8A8_UNORM = 37;
const VkFormat FORMAT_R8G8B8A8_SNORM = 38;
const VkFormat FORMAT_R8G8B8A8_USCALED = 39;
const VkFormat FORMAT_R8G8B8A8_SSCALED = 40;
const VkFormat FORMAT_R8G8B8A8_UINT = 41;
const VkFormat FORMAT_R8G8B8A8_SINT = 42;
const VkFormat FORMAT_R8G8B8A8_SRGB = 43;
const VkFormat FORMAT_B8G8R8A8_UNORM = 44;
const VkFormat FORMAT_B8G8R8A8_SNORM = 45;
const VkFormat FORMAT_B8G8R8A8_USCALED = 46;
const VkFormat FORMAT_B8G8R8A8_SSCALED = 47;
const VkFormat FORMAT_B8G8R8A8_UINT = 48;
const VkFormat FORMAT_B8G8R8A8_SINT = 49;
const VkFormat FORMAT_B8G8R8A8_SRGB = 50;
const VkFormat FORMAT_A8B8G8R8_UNORM_PACK32 = 51;
const VkFormat FORMAT_A8B8G8R8_SNORM_PACK32 = 52;
const VkFormat FORMAT_A8B8G8R8_USCALED_PACK32 = 53;
const VkFormat FORMAT_A8B8G8R8_SSCALED_PACK32 = 54;
const VkFormat FORMAT_A8B8G8R8_UINT_PACK32 = 55;
const VkFormat FORMAT_A8B8G8R8_SINT_PACK32 = 56;
const VkFormat FORMAT_A8B8G8R8_SRGB_PACK32 = 57;
const VkFormat FORMAT_A2R10G10B10_UNORM_PACK32 = 58;
const VkFormat FORMAT_A2R10G10B10_SNORM_PACK32 = 59;
const VkFormat FORMAT_A2R10G10B10_USCALED_PACK32 = 60;
const VkFormat FORMAT_A2R10G10B10_SSCALED_PACK32 = 61;
const VkFormat FORMAT_A2R10G10B10_UINT_PACK32 = 62;
const VkFormat FORMAT_A2R10G10B10_SINT_PACK32 = 63;
const VkFormat FORMAT_A2B10G10R10_UNORM_PACK32 = 64;
const VkFormat FORMAT_A2B10G10R10_SNORM_PACK32 = 65;
const VkFormat FORMAT_A2B10G10R10_USCALED_PACK32 = 66;
const VkFormat FORMAT_A2B10G10R10_SSCALED_PACK32 = 67;
const VkFormat FORMAT_A2B10G10R10_UINT_PACK32 = 68;
const VkFormat FORMAT_A2B10G10R10_SINT_PACK32 = 69;
const VkFormat FORMAT_R16_UNORM = 70;
const VkFormat FORMAT_R16_SNORM = 71;
const VkFormat FORMAT_R16_USCALED = 72;
const VkFormat FORMAT_R16_SSCALED = 73;
const VkFormat FORMAT_R16_UINT = 74;
const VkFormat FORMAT_R16_SINT = 75;
const VkFormat FORMAT_R16_SFLOAT = 76;
const VkFormat FORMAT_R16G16_UNORM = 77;
const VkFormat FORMAT_R16G16_SNORM = 78;
const VkFormat FORMAT_R16G16_USCALED = 79;
const VkFormat FORMAT_R16G16_SSCALED = 80;
const VkFormat FORMAT_R16G16_UINT = 81;
const VkFormat FORMAT_R16G16_SINT = 82;
const VkFormat FORMAT_R16G16_SFLOAT = 83;
const VkFormat FORMAT_R16G16B16_UNORM = 84;
const VkFormat FORMAT_R16G16B16_SNORM = 85;
const VkFormat FORMAT_R16G16B16_USCALED = 86;
const VkFormat FORMAT_R16G16B16_SSCALED = 87;
const VkFormat FORMAT_R16G16B16_UINT = 88;
const VkFormat FORMAT_R16G16B16_SINT = 89;
const VkFormat FORMAT_R16G16B16_SFLOAT = 90;
const VkFormat FORMAT_R16G16B16A16_UNORM = 91;
const VkFormat FORMAT_R16G16B16A16_SNORM = 92;
const VkFormat FORMAT_R16G16B16A16_USCALED = 93;
const VkFormat FORMAT_R16G16B16A16_SSCALED = 94;
const VkFormat FORMAT_R16G16B16A16_UINT = 95;
const VkFormat FORMAT_R16G16B16A16_SINT = 96;
const VkFormat FORMAT_R16G16B16A16_SFLOAT = 97;
const VkFormat FORMAT_R32_UINT = 98;
const VkFormat FORMAT_R32_SINT = 99;
const VkFormat FORMAT_R32_SFLOAT = 100;
const VkFormat FORMAT_R32G32_UINT = 101;
const VkFormat FORMAT_R32G32_SINT = 102;
const VkFormat FORMAT_R32G32_SFLOAT = 103;
const VkFormat FORMAT_R32G32B32_UINT = 104;
const VkFormat FORMAT_R32G32B32_SINT = 105;
const VkFormat FORMAT_R32G32B32_SFLOAT = 106;
const VkFormat FORMAT_R32G32B32A32_UINT = 107;
const VkFormat FORMAT_R32G32B32A32_SINT = 108;
const VkFormat FORMAT_R32G32B32A32_SFLOAT = 109;
const VkFormat FORMAT_R64_UINT = 110;
const VkFormat FORMAT_R64_SINT = 111;
const VkFormat FORMAT_R64_SFLOAT = 112;
const VkFormat FORMAT_R64G64_UINT = 113;
const VkFormat FORMAT_R64G64_SINT = 114;
const VkFormat FORMAT_R64G64_SFLOAT = 115;
const VkFormat FORMAT_R64G64B64_UINT = 116;
const VkFormat FORMAT_R64G64B64_SINT = 117;
const VkFormat FORMAT_R64G64B64_SFLOAT = 118;
const VkFormat FORMAT_R64G64B64A64_UINT = 119;
const VkFormat FORMAT_R64G64B64A64_SINT = 120;
const VkFormat FORMAT_R64G64B64A64_SFLOAT = 121;
const VkFormat FORMAT_B10G11R11_UFLOAT_PACK32 = 122;
const VkFormat FORMAT_E5B9G9R9_UFLOAT_PACK32 = 123;
const VkFormat FORMAT_D16_UNORM = 124;
const VkFormat FORMAT_X8_D24_UNORM_PACK32 = 125;
const VkFormat FORMAT_D32_SFLOAT = 126;
const VkFormat FORMAT_S8_UINT = 127;
const VkFormat FORMAT_D16_UNORM_S8_UINT = 128;
const VkFormat FORMAT_D24_UNORM_S8_UINT = 129;
const VkFormat FORMAT_D32_SFLOAT_S8_UINT = 130;
const VkFormat FORMAT_BC1_RGB_UNORM_BLOCK = 131;
const VkFormat FORMAT_BC1_RGB_SRGB_BLOCK = 132;
const VkFormat FORMAT_BC1_RGBA_UNORM_BLOCK = 133;
const VkFormat FORMAT_BC1_RGBA_SRGB_BLOCK = 134;
const VkFormat FORMAT_BC2_UNORM_BLOCK = 135;
const VkFormat FORMAT_BC2_SRGB_BLOCK = 136;
const VkFormat FORMAT_BC3_UNORM_BLOCK = 137;
const VkFormat FORMAT_BC3_SRGB_BLOCK = 138;
const VkFormat FORMAT_BC4_UNORM_BLOCK = 139;
const VkFormat FORMAT_BC4_SNORM_BLOCK = 140;
const VkFormat FORMAT_BC5_UNORM_BLOCK = 141;
const VkFormat FORMAT_BC5_SNORM_BLOCK = 142;
const VkFormat FORMAT_BC6H_UFLOAT_BLOCK = 143;
const VkFormat FORMAT_BC6H_SFLOAT_BLOCK = 144;
const VkFormat FORMAT_BC7_UNORM_BLOCK = 145;
const VkFormat FORMAT_BC7_SRGB_BLOCK = 146;
const VkFormat FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 147;
const VkFormat FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 148;
const VkFormat FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 149;
const VkFormat FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 150;
const VkFormat FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 151;
const VkFormat FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 152;
const VkFormat FORMAT_EAC_R11_UNORM_BLOCK = 153;
const VkFormat FORMAT_EAC_R11_SNORM_BLOCK = 154;
const VkFormat FORMAT_EAC_R11G11_UNORM_BLOCK = 155;
const VkFormat FORMAT_EAC_R11G11_SNORM_BLOCK = 156;
const VkFormat FORMAT_ASTC_4X4_UNORM_BLOCK = 157;
const VkFormat FORMAT_ASTC_4X4_SRGB_BLOCK = 158;
const VkFormat FORMAT_ASTC_5X4_UNORM_BLOCK = 159;
const VkFormat FORMAT_ASTC_5X4_SRGB_BLOCK = 160;
const VkFormat FORMAT_ASTC_5X5_UNORM_BLOCK = 161;
const VkFormat FORMAT_ASTC_5X5_SRGB_BLOCK = 162;
const VkFormat FORMAT_ASTC_6X5_UNORM_BLOCK = 163;
const VkFormat FORMAT_ASTC_6X5_SRGB_BLOCK = 164;
const VkFormat FORMAT_ASTC_6X6_UNORM_BLOCK = 165;
const VkFormat FORMAT_ASTC_6X6_SRGB_BLOCK = 166;
const VkFormat FORMAT_ASTC_8X5_UNORM_BLOCK = 167;
const VkFormat FORMAT_ASTC_8X5_SRGB_BLOCK = 168;
const VkFormat FORMAT_ASTC_8X6_UNORM_BLOCK = 169;
const VkFormat FORMAT_ASTC_8X6_SRGB_BLOCK = 170;
const VkFormat FORMAT_ASTC_8X8_UNORM_BLOCK = 171;
const VkFormat FORMAT_ASTC_8X8_SRGB_BLOCK = 172;
const VkFormat FORMAT_ASTC_10X5_UNORM_BLOCK = 173;
const VkFormat FORMAT_ASTC_10X5_SRGB_BLOCK = 174;
const VkFormat FORMAT_ASTC_10X6_UNORM_BLOCK = 175;
const VkFormat FORMAT_ASTC_10X6_SRGB_BLOCK = 176;
const VkFormat FORMAT_ASTC_10X8_UNORM_BLOCK = 177;
const VkFormat FORMAT_ASTC_10X8_SRGB_BLOCK = 178;
const VkFormat FORMAT_ASTC_10X10_UNORM_BLOCK = 179;
const VkFormat FORMAT_ASTC_10X10_SRGB_BLOCK = 180;
const VkFormat FORMAT_ASTC_12X10_UNORM_BLOCK = 181;
const VkFormat FORMAT_ASTC_12X10_SRGB_BLOCK = 182;
const VkFormat FORMAT_ASTC_12X12_UNORM_BLOCK = 183;
const VkFormat FORMAT_ASTC_12X12_SRGB_BLOCK = 184;
const VkFormat FORMAT_G8B8G8R8_422_UNORM = 1000156000;
const VkFormat FORMAT_B8G8R8G8_422_UNORM = 1000156001;
const VkFormat FORMAT_G8_B8_R8_3PLANE_420_UNORM = 1000156002;
const VkFormat FORMAT_G8_B8R8_2PLANE_420_UNORM = 1000156003;
const VkFormat FORMAT_G8_B8_R8_3PLANE_422_UNORM = 1000156004;
const VkFormat FORMAT_G8_B8R8_2PLANE_422_UNORM = 1000156005;
const VkFormat FORMAT_G8_B8_R8_3PLANE_444_UNORM = 1000156006;
const VkFormat FORMAT_R10X6_UNORM_PACK16 = 1000156007;
const VkFormat FORMAT_R10X6G10X6_UNORM_2PACK16 = 1000156008;
const VkFormat FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 = 1000156009;
const VkFormat FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 = 1000156010;
const VkFormat FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 = 1000156011;
const VkFormat FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 = 1000156012;
const VkFormat FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 = 1000156013;
const VkFormat FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 = 1000156014;
const VkFormat FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 = 1000156015;
const VkFormat FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 = 1000156016;
const VkFormat FORMAT_R12X4_UNORM_PACK16 = 1000156017;
const VkFormat FORMAT_R12X4G12X4_UNORM_2PACK16 = 1000156018;
const VkFormat FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16 = 1000156019;
const VkFormat FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 = 1000156020;
const VkFormat FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 = 1000156021;
const VkFormat FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 = 1000156022;
const VkFormat FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 = 1000156023;
const VkFormat FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 = 1000156024;
const VkFormat FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 = 1000156025;
const VkFormat FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 = 1000156026;
const VkFormat FORMAT_G16B16G16R16_422_UNORM = 1000156027;
const VkFormat FORMAT_B16G16R16G16_422_UNORM = 1000156028;
const VkFormat FORMAT_G16_B16_R16_3PLANE_420_UNORM = 1000156029;
const VkFormat FORMAT_G16_B16R16_2PLANE_420_UNORM = 1000156030;
const VkFormat FORMAT_G16_B16_R16_3PLANE_422_UNORM = 1000156031;
const VkFormat FORMAT_G16_B16R16_2PLANE_422_UNORM = 1000156032;
const VkFormat FORMAT_G16_B16_R16_3PLANE_444_UNORM = 1000156033;
const VkFormat FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG = 1000054000;
const VkFormat FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG = 1000054001;
const VkFormat FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG = 1000054002;
const VkFormat FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG = 1000054003;
const VkFormat FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG = 1000054004;
const VkFormat FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG = 1000054005;
const VkFormat FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG = 1000054006;
const VkFormat FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG = 1000054007;
const VkFormat FORMAT_ASTC_4X4_SFLOAT_BLOCK_EXT = 1000066000;
const VkFormat FORMAT_ASTC_5X4_SFLOAT_BLOCK_EXT = 1000066001;
const VkFormat FORMAT_ASTC_5X5_SFLOAT_BLOCK_EXT = 1000066002;
const VkFormat FORMAT_ASTC_6X5_SFLOAT_BLOCK_EXT = 1000066003;
const VkFormat FORMAT_ASTC_6X6_SFLOAT_BLOCK_EXT = 1000066004;
const VkFormat FORMAT_ASTC_8X5_SFLOAT_BLOCK_EXT = 1000066005;
const VkFormat FORMAT_ASTC_8X6_SFLOAT_BLOCK_EXT = 1000066006;
const VkFormat FORMAT_ASTC_8X8_SFLOAT_BLOCK_EXT = 1000066007;
const VkFormat FORMAT_ASTC_10X5_SFLOAT_BLOCK_EXT = 1000066008;
const VkFormat FORMAT_ASTC_10X6_SFLOAT_BLOCK_EXT = 1000066009;
const VkFormat FORMAT_ASTC_10X8_SFLOAT_BLOCK_EXT = 1000066010;
const VkFormat FORMAT_ASTC_10X10_SFLOAT_BLOCK_EXT = 1000066011;
const VkFormat FORMAT_ASTC_12X10_SFLOAT_BLOCK_EXT = 1000066012;
const VkFormat FORMAT_ASTC_12X12_SFLOAT_BLOCK_EXT = 1000066013;
const VkFormat FORMAT_G8B8G8R8_422_UNORM_KHR = FORMAT_G8B8G8R8_422_UNORM;
const VkFormat FORMAT_B8G8R8G8_422_UNORM_KHR = FORMAT_B8G8R8G8_422_UNORM;
const VkFormat FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR = FORMAT_G8_B8_R8_3PLANE_420_UNORM;
const VkFormat FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR = FORMAT_G8_B8R8_2PLANE_420_UNORM;
const VkFormat FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR = FORMAT_G8_B8_R8_3PLANE_422_UNORM;
const VkFormat FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR = FORMAT_G8_B8R8_2PLANE_422_UNORM;
const VkFormat FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR = FORMAT_G8_B8_R8_3PLANE_444_UNORM;
const VkFormat FORMAT_R10X6_UNORM_PACK16_KHR = FORMAT_R10X6_UNORM_PACK16;
const VkFormat FORMAT_R10X6G10X6_UNORM_2PACK16_KHR = FORMAT_R10X6G10X6_UNORM_2PACK16;
const VkFormat FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR = FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16;
const VkFormat FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR = FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16;
const VkFormat FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR = FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16;
const VkFormat FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR = FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16;
const VkFormat FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR = FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16;
const VkFormat FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR = FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16;
const VkFormat FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR = FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16;
const VkFormat FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR = FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16;
const VkFormat FORMAT_R12X4_UNORM_PACK16_KHR = FORMAT_R12X4_UNORM_PACK16;
const VkFormat FORMAT_R12X4G12X4_UNORM_2PACK16_KHR = FORMAT_R12X4G12X4_UNORM_2PACK16;
const VkFormat FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR = FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16;
const VkFormat FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR = FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16;
const VkFormat FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR = FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16;
const VkFormat FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR = FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16;
const VkFormat FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR = FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16;
const VkFormat FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR = FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16;
const VkFormat FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR = FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16;
const VkFormat FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR = FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16;
const VkFormat FORMAT_G16B16G16R16_422_UNORM_KHR = FORMAT_G16B16G16R16_422_UNORM;
const VkFormat FORMAT_B16G16R16G16_422_UNORM_KHR = FORMAT_B16G16R16G16_422_UNORM;
const VkFormat FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR = FORMAT_G16_B16_R16_3PLANE_420_UNORM;
const VkFormat FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR = FORMAT_G16_B16R16_2PLANE_420_UNORM;
const VkFormat FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR = FORMAT_G16_B16_R16_3PLANE_422_UNORM;
const VkFormat FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR = FORMAT_G16_B16R16_2PLANE_422_UNORM;
const VkFormat FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR = FORMAT_G16_B16_R16_3PLANE_444_UNORM;
const VkFormat FORMAT_BEGIN_RANGE = FORMAT_UNDEFINED;
const VkFormat FORMAT_END_RANGE = FORMAT_ASTC_12X12_SRGB_BLOCK;
const VkFormat FORMAT_RANGE_SIZE = (FORMAT_ASTC_12X12_SRGB_BLOCK-FORMAT_UNDEFINED+1);
const VkFormat FORMAT_MAX_ENUM = 0x7FFFFFFF;

typedef VkImageType = inline CUInt;
const VkImageType IMAGE_TYPE_1D = 0;
const VkImageType IMAGE_TYPE_2D = 1;
const VkImageType IMAGE_TYPE_3D = 2;
const VkImageType IMAGE_TYPE_BEGIN_RANGE = IMAGE_TYPE_1D;
const VkImageType IMAGE_TYPE_END_RANGE = IMAGE_TYPE_3D;
const VkImageType IMAGE_TYPE_RANGE_SIZE = (IMAGE_TYPE_3D-IMAGE_TYPE_1D+1);
const VkImageType IMAGE_TYPE_MAX_ENUM = 0x7FFFFFFF;

typedef VkImageTiling = inline CUInt;
const VkImageTiling IMAGE_TILING_OPTIMAL = 0;
const VkImageTiling IMAGE_TILING_LINEAR = 1;
const VkImageTiling IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT = 1000158000;
const VkImageTiling IMAGE_TILING_BEGIN_RANGE = IMAGE_TILING_OPTIMAL;
const VkImageTiling IMAGE_TILING_END_RANGE = IMAGE_TILING_LINEAR;
const VkImageTiling IMAGE_TILING_RANGE_SIZE = (IMAGE_TILING_LINEAR-IMAGE_TILING_OPTIMAL+1);
const VkImageTiling IMAGE_TILING_MAX_ENUM = 0x7FFFFFFF;

typedef VkPhysicalDeviceType = inline CUInt;
const VkPhysicalDeviceType PHYSICAL_DEVICE_TYPE_OTHER = 0;
const VkPhysicalDeviceType PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 1;
const VkPhysicalDeviceType PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = 2;
const VkPhysicalDeviceType PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = 3;
const VkPhysicalDeviceType PHYSICAL_DEVICE_TYPE_CPU = 4;
const VkPhysicalDeviceType PHYSICAL_DEVICE_TYPE_BEGIN_RANGE = PHYSICAL_DEVICE_TYPE_OTHER;
const VkPhysicalDeviceType PHYSICAL_DEVICE_TYPE_END_RANGE = PHYSICAL_DEVICE_TYPE_CPU;
const VkPhysicalDeviceType PHYSICAL_DEVICE_TYPE_RANGE_SIZE = (PHYSICAL_DEVICE_TYPE_CPU-PHYSICAL_DEVICE_TYPE_OTHER+1);
const VkPhysicalDeviceType PHYSICAL_DEVICE_TYPE_MAX_ENUM = 0x7FFFFFFF;

typedef VkQueryType = inline CUInt;
const VkQueryType QUERY_TYPE_OCCLUSION = 0;
const VkQueryType QUERY_TYPE_PIPELINE_STATISTICS = 1;
const VkQueryType QUERY_TYPE_TIMESTAMP = 2;
const VkQueryType QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT = 1000028004;
const VkQueryType QUERY_TYPE_PERFORMANCE_QUERY_KHR = 1000116000;
const VkQueryType QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV = 1000165000;
const VkQueryType QUERY_TYPE_PERFORMANCE_QUERY_INTEL = 1000210000;
const VkQueryType QUERY_TYPE_BEGIN_RANGE = QUERY_TYPE_OCCLUSION;
const VkQueryType QUERY_TYPE_END_RANGE = QUERY_TYPE_TIMESTAMP;
const VkQueryType QUERY_TYPE_RANGE_SIZE = (QUERY_TYPE_TIMESTAMP-QUERY_TYPE_OCCLUSION+1);
const VkQueryType QUERY_TYPE_MAX_ENUM = 0x7FFFFFFF;

typedef VkSharingMode = inline CUInt;
const VkSharingMode SHARING_MODE_EXCLUSIVE = 0;
const VkSharingMode SHARING_MODE_CONCURRENT = 1;
const VkSharingMode SHARING_MODE_BEGIN_RANGE = SHARING_MODE_EXCLUSIVE;
const VkSharingMode SHARING_MODE_END_RANGE = SHARING_MODE_CONCURRENT;
const VkSharingMode SHARING_MODE_RANGE_SIZE = (SHARING_MODE_CONCURRENT-SHARING_MODE_EXCLUSIVE+1);
const VkSharingMode SHARING_MODE_MAX_ENUM = 0x7FFFFFFF;

typedef VkImageLayout = inline CUInt;
const VkImageLayout IMAGE_LAYOUT_UNDEFINED = 0;
const VkImageLayout IMAGE_LAYOUT_GENERAL = 1;
const VkImageLayout IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = 2;
const VkImageLayout IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3;
const VkImageLayout IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = 4;
const VkImageLayout IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = 5;
const VkImageLayout IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = 6;
const VkImageLayout IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = 7;
const VkImageLayout IMAGE_LAYOUT_PREINITIALIZED = 8;
const VkImageLayout IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL = 1000117000;
const VkImageLayout IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL = 1000117001;
const VkImageLayout IMAGE_LAYOUT_PRESENT_SRC_KHR = 1000001002;
const VkImageLayout IMAGE_LAYOUT_SHARED_PRESENT_KHR = 1000111000;
const VkImageLayout IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV = 1000164003;
const VkImageLayout IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT = 1000218000;
const VkImageLayout IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR = 1000241000;
const VkImageLayout IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR = 1000241001;
const VkImageLayout IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR = 1000241002;
const VkImageLayout IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR = 1000241003;
const VkImageLayout IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR = IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL;
const VkImageLayout IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR = IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL;
const VkImageLayout IMAGE_LAYOUT_BEGIN_RANGE = IMAGE_LAYOUT_UNDEFINED;
const VkImageLayout IMAGE_LAYOUT_END_RANGE = IMAGE_LAYOUT_PREINITIALIZED;
const VkImageLayout IMAGE_LAYOUT_RANGE_SIZE = (IMAGE_LAYOUT_PREINITIALIZED-IMAGE_LAYOUT_UNDEFINED+1);
const VkImageLayout IMAGE_LAYOUT_MAX_ENUM = 0x7FFFFFFF;

typedef VkImageViewType = inline CUInt;
const VkImageViewType IMAGE_VIEW_TYPE_1D = 0;
const VkImageViewType IMAGE_VIEW_TYPE_2D = 1;
const VkImageViewType IMAGE_VIEW_TYPE_3D = 2;
const VkImageViewType IMAGE_VIEW_TYPE_CUBE = 3;
const VkImageViewType IMAGE_VIEW_TYPE_1D_ARRAY = 4;
const VkImageViewType IMAGE_VIEW_TYPE_2D_ARRAY = 5;
const VkImageViewType IMAGE_VIEW_TYPE_CUBE_ARRAY = 6;
const VkImageViewType IMAGE_VIEW_TYPE_BEGIN_RANGE = IMAGE_VIEW_TYPE_1D;
const VkImageViewType IMAGE_VIEW_TYPE_END_RANGE = IMAGE_VIEW_TYPE_CUBE_ARRAY;
const VkImageViewType IMAGE_VIEW_TYPE_RANGE_SIZE = (IMAGE_VIEW_TYPE_CUBE_ARRAY-IMAGE_VIEW_TYPE_1D+1);
const VkImageViewType IMAGE_VIEW_TYPE_MAX_ENUM = 0x7FFFFFFF;

typedef VkComponentSwizzle = inline CUInt;
const VkComponentSwizzle COMPONENT_SWIZZLE_IDENTITY = 0;
const VkComponentSwizzle COMPONENT_SWIZZLE_ZERO = 1;
const VkComponentSwizzle COMPONENT_SWIZZLE_ONE = 2;
const VkComponentSwizzle COMPONENT_SWIZZLE_R = 3;
const VkComponentSwizzle COMPONENT_SWIZZLE_G = 4;
const VkComponentSwizzle COMPONENT_SWIZZLE_B = 5;
const VkComponentSwizzle COMPONENT_SWIZZLE_A = 6;
const VkComponentSwizzle COMPONENT_SWIZZLE_BEGIN_RANGE = COMPONENT_SWIZZLE_IDENTITY;
const VkComponentSwizzle COMPONENT_SWIZZLE_END_RANGE = COMPONENT_SWIZZLE_A;
const VkComponentSwizzle COMPONENT_SWIZZLE_RANGE_SIZE = (COMPONENT_SWIZZLE_A-COMPONENT_SWIZZLE_IDENTITY+1);
const VkComponentSwizzle COMPONENT_SWIZZLE_MAX_ENUM = 0x7FFFFFFF;

typedef VkVertexInputRate = inline CUInt;
const VkVertexInputRate VERTEX_INPUT_RATE_VERTEX = 0;
const VkVertexInputRate VERTEX_INPUT_RATE_INSTANCE = 1;
const VkVertexInputRate VERTEX_INPUT_RATE_BEGIN_RANGE = VERTEX_INPUT_RATE_VERTEX;
const VkVertexInputRate VERTEX_INPUT_RATE_END_RANGE = VERTEX_INPUT_RATE_INSTANCE;
const VkVertexInputRate VERTEX_INPUT_RATE_RANGE_SIZE = (VERTEX_INPUT_RATE_INSTANCE-VERTEX_INPUT_RATE_VERTEX+1);
const VkVertexInputRate VERTEX_INPUT_RATE_MAX_ENUM = 0x7FFFFFFF;

typedef VkPrimitiveTopology = inline CUInt;
const VkPrimitiveTopology PRIMITIVE_TOPOLOGY_POINT_LIST = 0;
const VkPrimitiveTopology PRIMITIVE_TOPOLOGY_LINE_LIST = 1;
const VkPrimitiveTopology PRIMITIVE_TOPOLOGY_LINE_STRIP = 2;
const VkPrimitiveTopology PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = 3;
const VkPrimitiveTopology PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = 4;
const VkPrimitiveTopology PRIMITIVE_TOPOLOGY_TRIANGLE_FAN = 5;
const VkPrimitiveTopology PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY = 6;
const VkPrimitiveTopology PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY = 7;
const VkPrimitiveTopology PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY = 8;
const VkPrimitiveTopology PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY = 9;
const VkPrimitiveTopology PRIMITIVE_TOPOLOGY_PATCH_LIST = 10;
const VkPrimitiveTopology PRIMITIVE_TOPOLOGY_BEGIN_RANGE = PRIMITIVE_TOPOLOGY_POINT_LIST;
const VkPrimitiveTopology PRIMITIVE_TOPOLOGY_END_RANGE = PRIMITIVE_TOPOLOGY_PATCH_LIST;
const VkPrimitiveTopology PRIMITIVE_TOPOLOGY_RANGE_SIZE = (PRIMITIVE_TOPOLOGY_PATCH_LIST-PRIMITIVE_TOPOLOGY_POINT_LIST+1);
const VkPrimitiveTopology PRIMITIVE_TOPOLOGY_MAX_ENUM = 0x7FFFFFFF;

typedef VkPolygonMode = inline CUInt;
const VkPolygonMode POLYGON_MODE_FILL = 0;
const VkPolygonMode POLYGON_MODE_LINE = 1;
const VkPolygonMode POLYGON_MODE_POINT = 2;
const VkPolygonMode POLYGON_MODE_FILL_RECTANGLE_NV = 1000153000;
const VkPolygonMode POLYGON_MODE_BEGIN_RANGE = POLYGON_MODE_FILL;
const VkPolygonMode POLYGON_MODE_END_RANGE = POLYGON_MODE_POINT;
const VkPolygonMode POLYGON_MODE_RANGE_SIZE = (POLYGON_MODE_POINT-POLYGON_MODE_FILL+1);
const VkPolygonMode POLYGON_MODE_MAX_ENUM = 0x7FFFFFFF;

typedef VkFrontFace = inline CUInt;
const VkFrontFace FRONT_FACE_COUNTER_CLOCKWISE = 0;
const VkFrontFace FRONT_FACE_CLOCKWISE = 1;
const VkFrontFace FRONT_FACE_BEGIN_RANGE = FRONT_FACE_COUNTER_CLOCKWISE;
const VkFrontFace FRONT_FACE_END_RANGE = FRONT_FACE_CLOCKWISE;
const VkFrontFace FRONT_FACE_RANGE_SIZE = (FRONT_FACE_CLOCKWISE-FRONT_FACE_COUNTER_CLOCKWISE+1);
const VkFrontFace FRONT_FACE_MAX_ENUM = 0x7FFFFFFF;

typedef VkCompareOp = inline CUInt;
const VkCompareOp COMPARE_OP_NEVER = 0;
const VkCompareOp COMPARE_OP_LESS = 1;
const VkCompareOp COMPARE_OP_EQUAL = 2;
const VkCompareOp COMPARE_OP_LESS_OR_EQUAL = 3;
const VkCompareOp COMPARE_OP_GREATER = 4;
const VkCompareOp COMPARE_OP_NOT_EQUAL = 5;
const VkCompareOp COMPARE_OP_GREATER_OR_EQUAL = 6;
const VkCompareOp COMPARE_OP_ALWAYS = 7;
const VkCompareOp COMPARE_OP_BEGIN_RANGE = COMPARE_OP_NEVER;
const VkCompareOp COMPARE_OP_END_RANGE = COMPARE_OP_ALWAYS;
const VkCompareOp COMPARE_OP_RANGE_SIZE = (COMPARE_OP_ALWAYS-COMPARE_OP_NEVER+1);
const VkCompareOp COMPARE_OP_MAX_ENUM = 0x7FFFFFFF;

typedef VkStencilOp = inline CUInt;
const VkStencilOp STENCIL_OP_KEEP = 0;
const VkStencilOp STENCIL_OP_ZERO = 1;
const VkStencilOp STENCIL_OP_REPLACE = 2;
const VkStencilOp STENCIL_OP_INCREMENT_AND_CLAMP = 3;
const VkStencilOp STENCIL_OP_DECREMENT_AND_CLAMP = 4;
const VkStencilOp STENCIL_OP_INVERT = 5;
const VkStencilOp STENCIL_OP_INCREMENT_AND_WRAP = 6;
const VkStencilOp STENCIL_OP_DECREMENT_AND_WRAP = 7;
const VkStencilOp STENCIL_OP_BEGIN_RANGE = STENCIL_OP_KEEP;
const VkStencilOp STENCIL_OP_END_RANGE = STENCIL_OP_DECREMENT_AND_WRAP;
const VkStencilOp STENCIL_OP_RANGE_SIZE = (STENCIL_OP_DECREMENT_AND_WRAP-STENCIL_OP_KEEP+1);
const VkStencilOp STENCIL_OP_MAX_ENUM = 0x7FFFFFFF;

typedef VkLogicOp = inline CUInt;
const VkLogicOp LOGIC_OP_CLEAR = 0;
const VkLogicOp LOGIC_OP_AND = 1;
const VkLogicOp LOGIC_OP_AND_REVERSE = 2;
const VkLogicOp LOGIC_OP_COPY = 3;
const VkLogicOp LOGIC_OP_AND_INVERTED = 4;
const VkLogicOp LOGIC_OP_NO_OP = 5;
const VkLogicOp LOGIC_OP_XOR = 6;
const VkLogicOp LOGIC_OP_OR = 7;
const VkLogicOp LOGIC_OP_NOR = 8;
const VkLogicOp LOGIC_OP_EQUIVALENT = 9;
const VkLogicOp LOGIC_OP_INVERT = 10;
const VkLogicOp LOGIC_OP_OR_REVERSE = 11;
const VkLogicOp LOGIC_OP_COPY_INVERTED = 12;
const VkLogicOp LOGIC_OP_OR_INVERTED = 13;
const VkLogicOp LOGIC_OP_NAND = 14;
const VkLogicOp LOGIC_OP_SET = 15;
const VkLogicOp LOGIC_OP_BEGIN_RANGE = LOGIC_OP_CLEAR;
const VkLogicOp LOGIC_OP_END_RANGE = LOGIC_OP_SET;
const VkLogicOp LOGIC_OP_RANGE_SIZE = (LOGIC_OP_SET-LOGIC_OP_CLEAR+1);
const VkLogicOp LOGIC_OP_MAX_ENUM = 0x7FFFFFFF;

typedef VkBlendFactor = inline CUInt;
const VkBlendFactor BLEND_FACTOR_ZERO = 0;
const VkBlendFactor BLEND_FACTOR_ONE = 1;
const VkBlendFactor BLEND_FACTOR_SRC_COLOR = 2;
const VkBlendFactor BLEND_FACTOR_ONE_MINUS_SRC_COLOR = 3;
const VkBlendFactor BLEND_FACTOR_DST_COLOR = 4;
const VkBlendFactor BLEND_FACTOR_ONE_MINUS_DST_COLOR = 5;
const VkBlendFactor BLEND_FACTOR_SRC_ALPHA = 6;
const VkBlendFactor BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = 7;
const VkBlendFactor BLEND_FACTOR_DST_ALPHA = 8;
const VkBlendFactor BLEND_FACTOR_ONE_MINUS_DST_ALPHA = 9;
const VkBlendFactor BLEND_FACTOR_CONSTANT_COLOR = 10;
const VkBlendFactor BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = 11;
const VkBlendFactor BLEND_FACTOR_CONSTANT_ALPHA = 12;
const VkBlendFactor BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = 13;
const VkBlendFactor BLEND_FACTOR_SRC_ALPHA_SATURATE = 14;
const VkBlendFactor BLEND_FACTOR_SRC1_COLOR = 15;
const VkBlendFactor BLEND_FACTOR_ONE_MINUS_SRC1_COLOR = 16;
const VkBlendFactor BLEND_FACTOR_SRC1_ALPHA = 17;
const VkBlendFactor BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA = 18;
const VkBlendFactor BLEND_FACTOR_BEGIN_RANGE = BLEND_FACTOR_ZERO;
const VkBlendFactor BLEND_FACTOR_END_RANGE = BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA;
const VkBlendFactor BLEND_FACTOR_RANGE_SIZE = (BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA-BLEND_FACTOR_ZERO+1);
const VkBlendFactor BLEND_FACTOR_MAX_ENUM = 0x7FFFFFFF;

typedef VkBlendOp = inline CUInt;
const VkBlendOp BLEND_OP_ADD = 0;
const VkBlendOp BLEND_OP_SUBTRACT = 1;
const VkBlendOp BLEND_OP_REVERSE_SUBTRACT = 2;
const VkBlendOp BLEND_OP_MIN = 3;
const VkBlendOp BLEND_OP_MAX = 4;
const VkBlendOp BLEND_OP_ZERO_EXT = 1000148000;
const VkBlendOp BLEND_OP_SRC_EXT = 1000148001;
const VkBlendOp BLEND_OP_DST_EXT = 1000148002;
const VkBlendOp BLEND_OP_SRC_OVER_EXT = 1000148003;
const VkBlendOp BLEND_OP_DST_OVER_EXT = 1000148004;
const VkBlendOp BLEND_OP_SRC_IN_EXT = 1000148005;
const VkBlendOp BLEND_OP_DST_IN_EXT = 1000148006;
const VkBlendOp BLEND_OP_SRC_OUT_EXT = 1000148007;
const VkBlendOp BLEND_OP_DST_OUT_EXT = 1000148008;
const VkBlendOp BLEND_OP_SRC_ATOP_EXT = 1000148009;
const VkBlendOp BLEND_OP_DST_ATOP_EXT = 1000148010;
const VkBlendOp BLEND_OP_XOR_EXT = 1000148011;
const VkBlendOp BLEND_OP_MULTIPLY_EXT = 1000148012;
const VkBlendOp BLEND_OP_SCREEN_EXT = 1000148013;
const VkBlendOp BLEND_OP_OVERLAY_EXT = 1000148014;
const VkBlendOp BLEND_OP_DARKEN_EXT = 1000148015;
const VkBlendOp BLEND_OP_LIGHTEN_EXT = 1000148016;
const VkBlendOp BLEND_OP_COLORDODGE_EXT = 1000148017;
const VkBlendOp BLEND_OP_COLORBURN_EXT = 1000148018;
const VkBlendOp BLEND_OP_HARDLIGHT_EXT = 1000148019;
const VkBlendOp BLEND_OP_SOFTLIGHT_EXT = 1000148020;
const VkBlendOp BLEND_OP_DIFFERENCE_EXT = 1000148021;
const VkBlendOp BLEND_OP_EXCLUSION_EXT = 1000148022;
const VkBlendOp BLEND_OP_INVERT_EXT = 1000148023;
const VkBlendOp BLEND_OP_INVERT_RGB_EXT = 1000148024;
const VkBlendOp BLEND_OP_LINEARDODGE_EXT = 1000148025;
const VkBlendOp BLEND_OP_LINEARBURN_EXT = 1000148026;
const VkBlendOp BLEND_OP_VIVIDLIGHT_EXT = 1000148027;
const VkBlendOp BLEND_OP_LINEARLIGHT_EXT = 1000148028;
const VkBlendOp BLEND_OP_PINLIGHT_EXT = 1000148029;
const VkBlendOp BLEND_OP_HARDMIX_EXT = 1000148030;
const VkBlendOp BLEND_OP_HSL_HUE_EXT = 1000148031;
const VkBlendOp BLEND_OP_HSL_SATURATION_EXT = 1000148032;
const VkBlendOp BLEND_OP_HSL_COLOR_EXT = 1000148033;
const VkBlendOp BLEND_OP_HSL_LUMINOSITY_EXT = 1000148034;
const VkBlendOp BLEND_OP_PLUS_EXT = 1000148035;
const VkBlendOp BLEND_OP_PLUS_CLAMPED_EXT = 1000148036;
const VkBlendOp BLEND_OP_PLUS_CLAMPED_ALPHA_EXT = 1000148037;
const VkBlendOp BLEND_OP_PLUS_DARKER_EXT = 1000148038;
const VkBlendOp BLEND_OP_MINUS_EXT = 1000148039;
const VkBlendOp BLEND_OP_MINUS_CLAMPED_EXT = 1000148040;
const VkBlendOp BLEND_OP_CONTRAST_EXT = 1000148041;
const VkBlendOp BLEND_OP_INVERT_OVG_EXT = 1000148042;
const VkBlendOp BLEND_OP_RED_EXT = 1000148043;
const VkBlendOp BLEND_OP_GREEN_EXT = 1000148044;
const VkBlendOp BLEND_OP_BLUE_EXT = 1000148045;
const VkBlendOp BLEND_OP_BEGIN_RANGE = BLEND_OP_ADD;
const VkBlendOp BLEND_OP_END_RANGE = BLEND_OP_MAX;
const VkBlendOp BLEND_OP_RANGE_SIZE = (BLEND_OP_MAX-BLEND_OP_ADD+1);
const VkBlendOp BLEND_OP_MAX_ENUM = 0x7FFFFFFF;

typedef VkDynamicState = inline CUInt;
const VkDynamicState DYNAMIC_STATE_VIEWPORT = 0;
const VkDynamicState DYNAMIC_STATE_SCISSOR = 1;
const VkDynamicState DYNAMIC_STATE_LINE_WIDTH = 2;
const VkDynamicState DYNAMIC_STATE_DEPTH_BIAS = 3;
const VkDynamicState DYNAMIC_STATE_BLEND_CONSTANTS = 4;
const VkDynamicState DYNAMIC_STATE_DEPTH_BOUNDS = 5;
const VkDynamicState DYNAMIC_STATE_STENCIL_COMPARE_MASK = 6;
const VkDynamicState DYNAMIC_STATE_STENCIL_WRITE_MASK = 7;
const VkDynamicState DYNAMIC_STATE_STENCIL_REFERENCE = 8;
const VkDynamicState DYNAMIC_STATE_VIEWPORT_W_SCALING_NV = 1000087000;
const VkDynamicState DYNAMIC_STATE_DISCARD_RECTANGLE_EXT = 1000099000;
const VkDynamicState DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT = 1000143000;
const VkDynamicState DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV = 1000164004;
const VkDynamicState DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV = 1000164006;
const VkDynamicState DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV = 1000205001;
const VkDynamicState DYNAMIC_STATE_LINE_STIPPLE_EXT = 1000259000;
const VkDynamicState DYNAMIC_STATE_BEGIN_RANGE = DYNAMIC_STATE_VIEWPORT;
const VkDynamicState DYNAMIC_STATE_END_RANGE = DYNAMIC_STATE_STENCIL_REFERENCE;
const VkDynamicState DYNAMIC_STATE_RANGE_SIZE = (DYNAMIC_STATE_STENCIL_REFERENCE-DYNAMIC_STATE_VIEWPORT+1);
const VkDynamicState DYNAMIC_STATE_MAX_ENUM = 0x7FFFFFFF;

typedef VkFilter = inline CUInt;
const VkFilter FILTER_NEAREST = 0;
const VkFilter FILTER_LINEAR = 1;
const VkFilter FILTER_CUBIC_IMG = 1000015000;
const VkFilter FILTER_CUBIC_EXT = FILTER_CUBIC_IMG;
const VkFilter FILTER_BEGIN_RANGE = FILTER_NEAREST;
const VkFilter FILTER_END_RANGE = FILTER_LINEAR;
const VkFilter FILTER_RANGE_SIZE = (FILTER_LINEAR-FILTER_NEAREST+1);
const VkFilter FILTER_MAX_ENUM = 0x7FFFFFFF;

typedef VkSamplerMipmapMode = inline CUInt;
const VkSamplerMipmapMode SAMPLER_MIPMAP_MODE_NEAREST = 0;
const VkSamplerMipmapMode SAMPLER_MIPMAP_MODE_LINEAR = 1;
const VkSamplerMipmapMode SAMPLER_MIPMAP_MODE_BEGIN_RANGE = SAMPLER_MIPMAP_MODE_NEAREST;
const VkSamplerMipmapMode SAMPLER_MIPMAP_MODE_END_RANGE = SAMPLER_MIPMAP_MODE_LINEAR;
const VkSamplerMipmapMode SAMPLER_MIPMAP_MODE_RANGE_SIZE = (SAMPLER_MIPMAP_MODE_LINEAR-SAMPLER_MIPMAP_MODE_NEAREST+1);
const VkSamplerMipmapMode SAMPLER_MIPMAP_MODE_MAX_ENUM = 0x7FFFFFFF;

typedef VkSamplerAddressMode = inline CUInt;
const VkSamplerAddressMode SAMPLER_ADDRESS_MODE_REPEAT = 0;
const VkSamplerAddressMode SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT = 1;
const VkSamplerAddressMode SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE = 2;
const VkSamplerAddressMode SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER = 3;
const VkSamplerAddressMode SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE = 4;
const VkSamplerAddressMode SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE_KHR = SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE;
const VkSamplerAddressMode SAMPLER_ADDRESS_MODE_BEGIN_RANGE = SAMPLER_ADDRESS_MODE_REPEAT;
const VkSamplerAddressMode SAMPLER_ADDRESS_MODE_END_RANGE = SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER;
const VkSamplerAddressMode SAMPLER_ADDRESS_MODE_RANGE_SIZE = (SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER-SAMPLER_ADDRESS_MODE_REPEAT+1);
const VkSamplerAddressMode SAMPLER_ADDRESS_MODE_MAX_ENUM = 0x7FFFFFFF;

typedef VkBorderColor = inline CUInt;
const VkBorderColor BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = 0;
const VkBorderColor BORDER_COLOR_INT_TRANSPARENT_BLACK = 1;
const VkBorderColor BORDER_COLOR_FLOAT_OPAQUE_BLACK = 2;
const VkBorderColor BORDER_COLOR_INT_OPAQUE_BLACK = 3;
const VkBorderColor BORDER_COLOR_FLOAT_OPAQUE_WHITE = 4;
const VkBorderColor BORDER_COLOR_INT_OPAQUE_WHITE = 5;
const VkBorderColor BORDER_COLOR_BEGIN_RANGE = BORDER_COLOR_FLOAT_TRANSPARENT_BLACK;
const VkBorderColor BORDER_COLOR_END_RANGE = BORDER_COLOR_INT_OPAQUE_WHITE;
const VkBorderColor BORDER_COLOR_RANGE_SIZE = (BORDER_COLOR_INT_OPAQUE_WHITE-BORDER_COLOR_FLOAT_TRANSPARENT_BLACK+1);
const VkBorderColor BORDER_COLOR_MAX_ENUM = 0x7FFFFFFF;

typedef VkDescriptorType = inline CUInt;
const VkDescriptorType DESCRIPTOR_TYPE_SAMPLER = 0;
const VkDescriptorType DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = 1;
const VkDescriptorType DESCRIPTOR_TYPE_SAMPLED_IMAGE = 2;
const VkDescriptorType DESCRIPTOR_TYPE_STORAGE_IMAGE = 3;
const VkDescriptorType DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = 4;
const VkDescriptorType DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = 5;
const VkDescriptorType DESCRIPTOR_TYPE_UNIFORM_BUFFER = 6;
const VkDescriptorType DESCRIPTOR_TYPE_STORAGE_BUFFER = 7;
const VkDescriptorType DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = 8;
const VkDescriptorType DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = 9;
const VkDescriptorType DESCRIPTOR_TYPE_INPUT_ATTACHMENT = 10;
const VkDescriptorType DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT = 1000138000;
const VkDescriptorType DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV = 1000165000;
const VkDescriptorType DESCRIPTOR_TYPE_BEGIN_RANGE = DESCRIPTOR_TYPE_SAMPLER;
const VkDescriptorType DESCRIPTOR_TYPE_END_RANGE = DESCRIPTOR_TYPE_INPUT_ATTACHMENT;
const VkDescriptorType DESCRIPTOR_TYPE_RANGE_SIZE = (DESCRIPTOR_TYPE_INPUT_ATTACHMENT-DESCRIPTOR_TYPE_SAMPLER+1);
const VkDescriptorType DESCRIPTOR_TYPE_MAX_ENUM = 0x7FFFFFFF;

typedef VkAttachmentLoadOp = inline CUInt;
const VkAttachmentLoadOp ATTACHMENT_LOAD_OP_LOAD = 0;
const VkAttachmentLoadOp ATTACHMENT_LOAD_OP_CLEAR = 1;
const VkAttachmentLoadOp ATTACHMENT_LOAD_OP_DONT_CARE = 2;
const VkAttachmentLoadOp ATTACHMENT_LOAD_OP_BEGIN_RANGE = ATTACHMENT_LOAD_OP_LOAD;
const VkAttachmentLoadOp ATTACHMENT_LOAD_OP_END_RANGE = ATTACHMENT_LOAD_OP_DONT_CARE;
const VkAttachmentLoadOp ATTACHMENT_LOAD_OP_RANGE_SIZE = (ATTACHMENT_LOAD_OP_DONT_CARE-ATTACHMENT_LOAD_OP_LOAD+1);
const VkAttachmentLoadOp ATTACHMENT_LOAD_OP_MAX_ENUM = 0x7FFFFFFF;

typedef VkAttachmentStoreOp = inline CUInt;
const VkAttachmentStoreOp ATTACHMENT_STORE_OP_STORE = 0;
const VkAttachmentStoreOp ATTACHMENT_STORE_OP_DONT_CARE = 1;
const VkAttachmentStoreOp ATTACHMENT_STORE_OP_BEGIN_RANGE = ATTACHMENT_STORE_OP_STORE;
const VkAttachmentStoreOp ATTACHMENT_STORE_OP_END_RANGE = ATTACHMENT_STORE_OP_DONT_CARE;
const VkAttachmentStoreOp ATTACHMENT_STORE_OP_RANGE_SIZE = (ATTACHMENT_STORE_OP_DONT_CARE-ATTACHMENT_STORE_OP_STORE+1);
const VkAttachmentStoreOp ATTACHMENT_STORE_OP_MAX_ENUM = 0x7FFFFFFF;

typedef VkPipelineBindPoint = inline CUInt;
const VkPipelineBindPoint PIPELINE_BIND_POINT_GRAPHICS = 0;
const VkPipelineBindPoint PIPELINE_BIND_POINT_COMPUTE = 1;
const VkPipelineBindPoint PIPELINE_BIND_POINT_RAY_TRACING_NV = 1000165000;
const VkPipelineBindPoint PIPELINE_BIND_POINT_BEGIN_RANGE = PIPELINE_BIND_POINT_GRAPHICS;
const VkPipelineBindPoint PIPELINE_BIND_POINT_END_RANGE = PIPELINE_BIND_POINT_COMPUTE;
const VkPipelineBindPoint PIPELINE_BIND_POINT_RANGE_SIZE = (PIPELINE_BIND_POINT_COMPUTE-PIPELINE_BIND_POINT_GRAPHICS+1);
const VkPipelineBindPoint PIPELINE_BIND_POINT_MAX_ENUM = 0x7FFFFFFF;

typedef VkCommandBufferLevel = inline CUInt;
const VkCommandBufferLevel COMMAND_BUFFER_LEVEL_PRIMARY = 0;
const VkCommandBufferLevel COMMAND_BUFFER_LEVEL_SECONDARY = 1;
const VkCommandBufferLevel COMMAND_BUFFER_LEVEL_BEGIN_RANGE = COMMAND_BUFFER_LEVEL_PRIMARY;
const VkCommandBufferLevel COMMAND_BUFFER_LEVEL_END_RANGE = COMMAND_BUFFER_LEVEL_SECONDARY;
const VkCommandBufferLevel COMMAND_BUFFER_LEVEL_RANGE_SIZE = (COMMAND_BUFFER_LEVEL_SECONDARY-COMMAND_BUFFER_LEVEL_PRIMARY+1);
const VkCommandBufferLevel COMMAND_BUFFER_LEVEL_MAX_ENUM = 0x7FFFFFFF;

typedef VkIndexType = inline CUInt;
const VkIndexType INDEX_TYPE_UINT16 = 0;
const VkIndexType INDEX_TYPE_UINT32 = 1;
const VkIndexType INDEX_TYPE_NONE_NV = 1000165000;
const VkIndexType INDEX_TYPE_UINT8_EXT = 1000265000;
const VkIndexType INDEX_TYPE_BEGIN_RANGE = INDEX_TYPE_UINT16;
const VkIndexType INDEX_TYPE_END_RANGE = INDEX_TYPE_UINT32;
const VkIndexType INDEX_TYPE_RANGE_SIZE = (INDEX_TYPE_UINT32-INDEX_TYPE_UINT16+1);
const VkIndexType INDEX_TYPE_MAX_ENUM = 0x7FFFFFFF;

typedef VkSubpassContents = inline CUInt;
const VkSubpassContents SUBPASS_CONTENTS_INLINE = 0;
const VkSubpassContents SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = 1;
const VkSubpassContents SUBPASS_CONTENTS_BEGIN_RANGE = SUBPASS_CONTENTS_INLINE;
const VkSubpassContents SUBPASS_CONTENTS_END_RANGE = SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS;
const VkSubpassContents SUBPASS_CONTENTS_RANGE_SIZE = (SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS-SUBPASS_CONTENTS_INLINE+1);
const VkSubpassContents SUBPASS_CONTENTS_MAX_ENUM = 0x7FFFFFFF;

typedef VkObjectType = inline CUInt;
const VkObjectType OBJECT_TYPE_UNKNOWN = 0;
const VkObjectType OBJECT_TYPE_INSTANCE = 1;
const VkObjectType OBJECT_TYPE_PHYSICAL_DEVICE = 2;
const VkObjectType OBJECT_TYPE_DEVICE = 3;
const VkObjectType OBJECT_TYPE_QUEUE = 4;
const VkObjectType OBJECT_TYPE_SEMAPHORE = 5;
const VkObjectType OBJECT_TYPE_COMMAND_BUFFER = 6;
const VkObjectType OBJECT_TYPE_FENCE = 7;
const VkObjectType OBJECT_TYPE_DEVICE_MEMORY = 8;
const VkObjectType OBJECT_TYPE_BUFFER = 9;
const VkObjectType OBJECT_TYPE_IMAGE = 10;
const VkObjectType OBJECT_TYPE_EVENT = 11;
const VkObjectType OBJECT_TYPE_QUERY_POOL = 12;
const VkObjectType OBJECT_TYPE_BUFFER_VIEW = 13;
const VkObjectType OBJECT_TYPE_IMAGE_VIEW = 14;
const VkObjectType OBJECT_TYPE_SHADER_MODULE = 15;
const VkObjectType OBJECT_TYPE_PIPELINE_CACHE = 16;
const VkObjectType OBJECT_TYPE_PIPELINE_LAYOUT = 17;
const VkObjectType OBJECT_TYPE_RENDER_PASS = 18;
const VkObjectType OBJECT_TYPE_PIPELINE = 19;
const VkObjectType OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT = 20;
const VkObjectType OBJECT_TYPE_SAMPLER = 21;
const VkObjectType OBJECT_TYPE_DESCRIPTOR_POOL = 22;
const VkObjectType OBJECT_TYPE_DESCRIPTOR_SET = 23;
const VkObjectType OBJECT_TYPE_FRAMEBUFFER = 24;
const VkObjectType OBJECT_TYPE_COMMAND_POOL = 25;
const VkObjectType OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION = 1000156000;
const VkObjectType OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE = 1000085000;
const VkObjectType OBJECT_TYPE_SURFACE_KHR = 1000000000;
const VkObjectType OBJECT_TYPE_SWAPCHAIN_KHR = 1000001000;
const VkObjectType OBJECT_TYPE_DISPLAY_KHR = 1000002000;
const VkObjectType OBJECT_TYPE_DISPLAY_MODE_KHR = 1000002001;
const VkObjectType OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT = 1000011000;
const VkObjectType OBJECT_TYPE_OBJECT_TABLE_NVX = 1000086000;
const VkObjectType OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX = 1000086001;
const VkObjectType OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT = 1000128000;
const VkObjectType OBJECT_TYPE_VALIDATION_CACHE_EXT = 1000160000;
const VkObjectType OBJECT_TYPE_ACCELERATION_STRUCTURE_NV = 1000165000;
const VkObjectType OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL = 1000210000;
const VkObjectType OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR = OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE;
const VkObjectType OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR = OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION;
const VkObjectType OBJECT_TYPE_BEGIN_RANGE = OBJECT_TYPE_UNKNOWN;
const VkObjectType OBJECT_TYPE_END_RANGE = OBJECT_TYPE_COMMAND_POOL;
const VkObjectType OBJECT_TYPE_RANGE_SIZE = (OBJECT_TYPE_COMMAND_POOL-OBJECT_TYPE_UNKNOWN+1);
const VkObjectType OBJECT_TYPE_MAX_ENUM = 0x7FFFFFFF;

typedef VkVendorId = inline CUInt;
const VkVendorId VENDOR_ID_VIV = 0x10001;
const VkVendorId VENDOR_ID_VSI = 0x10002;
const VkVendorId VENDOR_ID_KAZAN = 0x10003;
const VkVendorId VENDOR_ID_BEGIN_RANGE = VENDOR_ID_VIV;
const VkVendorId VENDOR_ID_END_RANGE = VENDOR_ID_KAZAN;
const VkVendorId VENDOR_ID_RANGE_SIZE = (VENDOR_ID_KAZAN-VENDOR_ID_VIV+1);
const VkVendorId VENDOR_ID_MAX_ENUM = 0x7FFFFFFF;

alias VkInstanceCreateFlags = VkFlags;

typedef VkFormatFeatureFlagBits = inline CUInt;
const VkFormatFeatureFlagBits FORMAT_FEATURE_SAMPLED_IMAGE_BIT = 0x00000001;
const VkFormatFeatureFlagBits FORMAT_FEATURE_STORAGE_IMAGE_BIT = 0x00000002;
const VkFormatFeatureFlagBits FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT = 0x00000004;
const VkFormatFeatureFlagBits FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000008;
const VkFormatFeatureFlagBits FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT = 0x00000010;
const VkFormatFeatureFlagBits FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = 0x00000020;
const VkFormatFeatureFlagBits FORMAT_FEATURE_VERTEX_BUFFER_BIT = 0x00000040;
const VkFormatFeatureFlagBits FORMAT_FEATURE_COLOR_ATTACHMENT_BIT = 0x00000080;
const VkFormatFeatureFlagBits FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT = 0x00000100;
const VkFormatFeatureFlagBits FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000200;
const VkFormatFeatureFlagBits FORMAT_FEATURE_BLIT_SRC_BIT = 0x00000400;
const VkFormatFeatureFlagBits FORMAT_FEATURE_BLIT_DST_BIT = 0x00000800;
const VkFormatFeatureFlagBits FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT = 0x00001000;
const VkFormatFeatureFlagBits FORMAT_FEATURE_TRANSFER_SRC_BIT = 0x00004000;
const VkFormatFeatureFlagBits FORMAT_FEATURE_TRANSFER_DST_BIT = 0x00008000;
const VkFormatFeatureFlagBits FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT = 0x00020000;
const VkFormatFeatureFlagBits FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT = 0x00040000;
const VkFormatFeatureFlagBits FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT = 0x00080000;
const VkFormatFeatureFlagBits FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT = 0x00100000;
const VkFormatFeatureFlagBits FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT = 0x00200000;
const VkFormatFeatureFlagBits FORMAT_FEATURE_DISJOINT_BIT = 0x00400000;
const VkFormatFeatureFlagBits FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT = 0x00800000;
const VkFormatFeatureFlagBits FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG = 0x00002000;
const VkFormatFeatureFlagBits FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT = 0x00010000;
const VkFormatFeatureFlagBits FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT = 0x01000000;
const VkFormatFeatureFlagBits FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR = FORMAT_FEATURE_TRANSFER_SRC_BIT;
const VkFormatFeatureFlagBits FORMAT_FEATURE_TRANSFER_DST_BIT_KHR = FORMAT_FEATURE_TRANSFER_DST_BIT;
const VkFormatFeatureFlagBits FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR = FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT;
const VkFormatFeatureFlagBits FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR = FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT;
const VkFormatFeatureFlagBits FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR = FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT;
const VkFormatFeatureFlagBits FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR = FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT;
const VkFormatFeatureFlagBits FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR = FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT;
const VkFormatFeatureFlagBits FORMAT_FEATURE_DISJOINT_BIT_KHR = FORMAT_FEATURE_DISJOINT_BIT;
const VkFormatFeatureFlagBits FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR = FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT;
const VkFormatFeatureFlagBits FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT = FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG;
const VkFormatFeatureFlagBits FORMAT_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkFormatFeatureFlags = VkFlags;

typedef VkImageUsageFlagBits = inline CUInt;
const VkImageUsageFlagBits IMAGE_USAGE_TRANSFER_SRC_BIT = 0x00000001;
const VkImageUsageFlagBits IMAGE_USAGE_TRANSFER_DST_BIT = 0x00000002;
const VkImageUsageFlagBits IMAGE_USAGE_SAMPLED_BIT = 0x00000004;
const VkImageUsageFlagBits IMAGE_USAGE_STORAGE_BIT = 0x00000008;
const VkImageUsageFlagBits IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 0x00000010;
const VkImageUsageFlagBits IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000020;
const VkImageUsageFlagBits IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 0x00000040;
const VkImageUsageFlagBits IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 0x00000080;
const VkImageUsageFlagBits IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV = 0x00000100;
const VkImageUsageFlagBits IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT = 0x00000200;
const VkImageUsageFlagBits IMAGE_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkImageUsageFlags = VkFlags;

typedef VkImageCreateFlagBits = inline CUInt;
const VkImageCreateFlagBits IMAGE_CREATE_SPARSE_BINDING_BIT = 0x00000001;
const VkImageCreateFlagBits IMAGE_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002;
const VkImageCreateFlagBits IMAGE_CREATE_SPARSE_ALIASED_BIT = 0x00000004;
const VkImageCreateFlagBits IMAGE_CREATE_MUTABLE_FORMAT_BIT = 0x00000008;
const VkImageCreateFlagBits IMAGE_CREATE_CUBE_COMPATIBLE_BIT = 0x00000010;
const VkImageCreateFlagBits IMAGE_CREATE_ALIAS_BIT = 0x00000400;
const VkImageCreateFlagBits IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT = 0x00000040;
const VkImageCreateFlagBits IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT = 0x00000020;
const VkImageCreateFlagBits IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT = 0x00000080;
const VkImageCreateFlagBits IMAGE_CREATE_EXTENDED_USAGE_BIT = 0x00000100;
const VkImageCreateFlagBits IMAGE_CREATE_PROTECTED_BIT = 0x00000800;
const VkImageCreateFlagBits IMAGE_CREATE_DISJOINT_BIT = 0x00000200;
const VkImageCreateFlagBits IMAGE_CREATE_CORNER_SAMPLED_BIT_NV = 0x00002000;
const VkImageCreateFlagBits IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT = 0x00001000;
const VkImageCreateFlagBits IMAGE_CREATE_SUBSAMPLED_BIT_EXT = 0x00004000;
const VkImageCreateFlagBits IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT;
const VkImageCreateFlagBits IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR = IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT;
const VkImageCreateFlagBits IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR = IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT;
const VkImageCreateFlagBits IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR = IMAGE_CREATE_EXTENDED_USAGE_BIT;
const VkImageCreateFlagBits IMAGE_CREATE_DISJOINT_BIT_KHR = IMAGE_CREATE_DISJOINT_BIT;
const VkImageCreateFlagBits IMAGE_CREATE_ALIAS_BIT_KHR = IMAGE_CREATE_ALIAS_BIT;
const VkImageCreateFlagBits IMAGE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkImageCreateFlags = VkFlags;

typedef VkSampleCountFlagBits = inline CUInt;
const VkSampleCountFlagBits SAMPLE_COUNT_1_BIT = 0x00000001;
const VkSampleCountFlagBits SAMPLE_COUNT_2_BIT = 0x00000002;
const VkSampleCountFlagBits SAMPLE_COUNT_4_BIT = 0x00000004;
const VkSampleCountFlagBits SAMPLE_COUNT_8_BIT = 0x00000008;
const VkSampleCountFlagBits SAMPLE_COUNT_16_BIT = 0x00000010;
const VkSampleCountFlagBits SAMPLE_COUNT_32_BIT = 0x00000020;
const VkSampleCountFlagBits SAMPLE_COUNT_64_BIT = 0x00000040;
const VkSampleCountFlagBits SAMPLE_COUNT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkSampleCountFlags = VkFlags;

typedef VkQueueFlagBits = inline CUInt;
const VkQueueFlagBits QUEUE_GRAPHICS_BIT = 0x00000001;
const VkQueueFlagBits QUEUE_COMPUTE_BIT = 0x00000002;
const VkQueueFlagBits QUEUE_TRANSFER_BIT = 0x00000004;
const VkQueueFlagBits QUEUE_SPARSE_BINDING_BIT = 0x00000008;
const VkQueueFlagBits QUEUE_PROTECTED_BIT = 0x00000010;
const VkQueueFlagBits QUEUE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkQueueFlags = VkFlags;

typedef VkMemoryPropertyFlagBits = inline CUInt;
const VkMemoryPropertyFlagBits MEMORY_PROPERTY_DEVICE_LOCAL_BIT = 0x00000001;
const VkMemoryPropertyFlagBits MEMORY_PROPERTY_HOST_VISIBLE_BIT = 0x00000002;
const VkMemoryPropertyFlagBits MEMORY_PROPERTY_HOST_COHERENT_BIT = 0x00000004;
const VkMemoryPropertyFlagBits MEMORY_PROPERTY_HOST_CACHED_BIT = 0x00000008;
const VkMemoryPropertyFlagBits MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 0x00000010;
const VkMemoryPropertyFlagBits MEMORY_PROPERTY_PROTECTED_BIT = 0x00000020;
const VkMemoryPropertyFlagBits MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD = 0x00000040;
const VkMemoryPropertyFlagBits MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD = 0x00000080;
const VkMemoryPropertyFlagBits MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkMemoryPropertyFlags = VkFlags;

typedef VkMemoryHeapFlagBits = inline CUInt;
const VkMemoryHeapFlagBits MEMORY_HEAP_DEVICE_LOCAL_BIT = 0x00000001;
const VkMemoryHeapFlagBits MEMORY_HEAP_MULTI_INSTANCE_BIT = 0x00000002;
const VkMemoryHeapFlagBits MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR = MEMORY_HEAP_MULTI_INSTANCE_BIT;
const VkMemoryHeapFlagBits MEMORY_HEAP_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkMemoryHeapFlags = VkFlags;

alias VkDeviceCreateFlags = VkFlags;

typedef VkDeviceQueueCreateFlagBits = inline CUInt;
const VkDeviceQueueCreateFlagBits DEVICE_QUEUE_CREATE_PROTECTED_BIT = 0x00000001;
const VkDeviceQueueCreateFlagBits DEVICE_QUEUE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkDeviceQueueCreateFlags = VkFlags;

typedef VkPipelineStageFlagBits = inline CUInt;
const VkPipelineStageFlagBits PIPELINE_STAGE_TOP_OF_PIPE_BIT = 0x00000001;
const VkPipelineStageFlagBits PIPELINE_STAGE_DRAW_INDIRECT_BIT = 0x00000002;
const VkPipelineStageFlagBits PIPELINE_STAGE_VERTEX_INPUT_BIT = 0x00000004;
const VkPipelineStageFlagBits PIPELINE_STAGE_VERTEX_SHADER_BIT = 0x00000008;
const VkPipelineStageFlagBits PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = 0x00000010;
const VkPipelineStageFlagBits PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = 0x00000020;
const VkPipelineStageFlagBits PIPELINE_STAGE_GEOMETRY_SHADER_BIT = 0x00000040;
const VkPipelineStageFlagBits PIPELINE_STAGE_FRAGMENT_SHADER_BIT = 0x00000080;
const VkPipelineStageFlagBits PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = 0x00000100;
const VkPipelineStageFlagBits PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = 0x00000200;
const VkPipelineStageFlagBits PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = 0x00000400;
const VkPipelineStageFlagBits PIPELINE_STAGE_COMPUTE_SHADER_BIT = 0x00000800;
const VkPipelineStageFlagBits PIPELINE_STAGE_TRANSFER_BIT = 0x00001000;
const VkPipelineStageFlagBits PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = 0x00002000;
const VkPipelineStageFlagBits PIPELINE_STAGE_HOST_BIT = 0x00004000;
const VkPipelineStageFlagBits PIPELINE_STAGE_ALL_GRAPHICS_BIT = 0x00008000;
const VkPipelineStageFlagBits PIPELINE_STAGE_ALL_COMMANDS_BIT = 0x00010000;
const VkPipelineStageFlagBits PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT = 0x01000000;
const VkPipelineStageFlagBits PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT = 0x00040000;
const VkPipelineStageFlagBits PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX = 0x00020000;
const VkPipelineStageFlagBits PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV = 0x00400000;
const VkPipelineStageFlagBits PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV = 0x00200000;
const VkPipelineStageFlagBits PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV = 0x02000000;
const VkPipelineStageFlagBits PIPELINE_STAGE_TASK_SHADER_BIT_NV = 0x00080000;
const VkPipelineStageFlagBits PIPELINE_STAGE_MESH_SHADER_BIT_NV = 0x00100000;
const VkPipelineStageFlagBits PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT = 0x00800000;
const VkPipelineStageFlagBits PIPELINE_STAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkPipelineStageFlags = VkFlags;

alias VkMemoryMapFlags = VkFlags;

typedef VkImageAspectFlagBits = inline CUInt;
const VkImageAspectFlagBits IMAGE_ASPECT_COLOR_BIT = 0x00000001;
const VkImageAspectFlagBits IMAGE_ASPECT_DEPTH_BIT = 0x00000002;
const VkImageAspectFlagBits IMAGE_ASPECT_STENCIL_BIT = 0x00000004;
const VkImageAspectFlagBits IMAGE_ASPECT_METADATA_BIT = 0x00000008;
const VkImageAspectFlagBits IMAGE_ASPECT_PLANE_0_BIT = 0x00000010;
const VkImageAspectFlagBits IMAGE_ASPECT_PLANE_1_BIT = 0x00000020;
const VkImageAspectFlagBits IMAGE_ASPECT_PLANE_2_BIT = 0x00000040;
const VkImageAspectFlagBits IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT = 0x00000080;
const VkImageAspectFlagBits IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT = 0x00000100;
const VkImageAspectFlagBits IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT = 0x00000200;
const VkImageAspectFlagBits IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT = 0x00000400;
const VkImageAspectFlagBits IMAGE_ASPECT_PLANE_0_BIT_KHR = IMAGE_ASPECT_PLANE_0_BIT;
const VkImageAspectFlagBits IMAGE_ASPECT_PLANE_1_BIT_KHR = IMAGE_ASPECT_PLANE_1_BIT;
const VkImageAspectFlagBits IMAGE_ASPECT_PLANE_2_BIT_KHR = IMAGE_ASPECT_PLANE_2_BIT;
const VkImageAspectFlagBits IMAGE_ASPECT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkImageAspectFlags = VkFlags;

typedef VkSparseImageFormatFlagBits = inline CUInt;
const VkSparseImageFormatFlagBits SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT = 0x00000001;
const VkSparseImageFormatFlagBits SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT = 0x00000002;
const VkSparseImageFormatFlagBits SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT = 0x00000004;
const VkSparseImageFormatFlagBits SPARSE_IMAGE_FORMAT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkSparseImageFormatFlags = VkFlags;

typedef VkSparseMemoryBindFlagBits = inline CUInt;
const VkSparseMemoryBindFlagBits SPARSE_MEMORY_BIND_METADATA_BIT = 0x00000001;
const VkSparseMemoryBindFlagBits SPARSE_MEMORY_BIND_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkSparseMemoryBindFlags = VkFlags;

typedef VkFenceCreateFlagBits = inline CUInt;
const VkFenceCreateFlagBits FENCE_CREATE_SIGNALED_BIT = 0x00000001;
const VkFenceCreateFlagBits FENCE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkFenceCreateFlags = VkFlags;

alias VkSemaphoreCreateFlags = VkFlags;

alias VkEventCreateFlags = VkFlags;

alias VkQueryPoolCreateFlags = VkFlags;

typedef VkQueryPipelineStatisticFlagBits = inline CUInt;
const VkQueryPipelineStatisticFlagBits QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT = 0x00000001;
const VkQueryPipelineStatisticFlagBits QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT = 0x00000002;
const VkQueryPipelineStatisticFlagBits QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT = 0x00000004;
const VkQueryPipelineStatisticFlagBits QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT = 0x00000008;
const VkQueryPipelineStatisticFlagBits QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT = 0x00000010;
const VkQueryPipelineStatisticFlagBits QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT = 0x00000020;
const VkQueryPipelineStatisticFlagBits QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT = 0x00000040;
const VkQueryPipelineStatisticFlagBits QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT = 0x00000080;
const VkQueryPipelineStatisticFlagBits QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT = 0x00000100;
const VkQueryPipelineStatisticFlagBits QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT = 0x00000200;
const VkQueryPipelineStatisticFlagBits QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT = 0x00000400;
const VkQueryPipelineStatisticFlagBits QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkQueryPipelineStatisticFlags = VkFlags;

typedef VkQueryResultFlagBits = inline CUInt;
const VkQueryResultFlagBits QUERY_RESULT_64_BIT = 0x00000001;
const VkQueryResultFlagBits QUERY_RESULT_WAIT_BIT = 0x00000002;
const VkQueryResultFlagBits QUERY_RESULT_WITH_AVAILABILITY_BIT = 0x00000004;
const VkQueryResultFlagBits QUERY_RESULT_PARTIAL_BIT = 0x00000008;
const VkQueryResultFlagBits QUERY_RESULT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkQueryResultFlags = VkFlags;

typedef VkBufferCreateFlagBits = inline CUInt;
const VkBufferCreateFlagBits BUFFER_CREATE_SPARSE_BINDING_BIT = 0x00000001;
const VkBufferCreateFlagBits BUFFER_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002;
const VkBufferCreateFlagBits BUFFER_CREATE_SPARSE_ALIASED_BIT = 0x00000004;
const VkBufferCreateFlagBits BUFFER_CREATE_PROTECTED_BIT = 0x00000008;
const VkBufferCreateFlagBits BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR = 0x00000010;
const VkBufferCreateFlagBits BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT = BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR;
const VkBufferCreateFlagBits BUFFER_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkBufferCreateFlags = VkFlags;

typedef VkBufferUsageFlagBits = inline CUInt;
const VkBufferUsageFlagBits BUFFER_USAGE_TRANSFER_SRC_BIT = 0x00000001;
const VkBufferUsageFlagBits BUFFER_USAGE_TRANSFER_DST_BIT = 0x00000002;
const VkBufferUsageFlagBits BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000004;
const VkBufferUsageFlagBits BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = 0x00000008;
const VkBufferUsageFlagBits BUFFER_USAGE_UNIFORM_BUFFER_BIT = 0x00000010;
const VkBufferUsageFlagBits BUFFER_USAGE_STORAGE_BUFFER_BIT = 0x00000020;
const VkBufferUsageFlagBits BUFFER_USAGE_INDEX_BUFFER_BIT = 0x00000040;
const VkBufferUsageFlagBits BUFFER_USAGE_VERTEX_BUFFER_BIT = 0x00000080;
const VkBufferUsageFlagBits BUFFER_USAGE_INDIRECT_BUFFER_BIT = 0x00000100;
const VkBufferUsageFlagBits BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT = 0x00000800;
const VkBufferUsageFlagBits BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT = 0x00001000;
const VkBufferUsageFlagBits BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT = 0x00000200;
const VkBufferUsageFlagBits BUFFER_USAGE_RAY_TRACING_BIT_NV = 0x00000400;
const VkBufferUsageFlagBits BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR = 0x00020000;
const VkBufferUsageFlagBits BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT = BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR;
const VkBufferUsageFlagBits BUFFER_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkBufferUsageFlags = VkFlags;

alias VkBufferViewCreateFlags = VkFlags;

typedef VkImageViewCreateFlagBits = inline CUInt;
const VkImageViewCreateFlagBits IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT = 0x00000001;
const VkImageViewCreateFlagBits IMAGE_VIEW_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkImageViewCreateFlags = VkFlags;

typedef VkShaderModuleCreateFlagBits = inline CUInt;
const VkShaderModuleCreateFlagBits SHADER_MODULE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkShaderModuleCreateFlags = VkFlags;

alias VkPipelineCacheCreateFlags = VkFlags;

typedef VkPipelineCreateFlagBits = inline CUInt;
const VkPipelineCreateFlagBits PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT = 0x00000001;
const VkPipelineCreateFlagBits PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT = 0x00000002;
const VkPipelineCreateFlagBits PIPELINE_CREATE_DERIVATIVE_BIT = 0x00000004;
const VkPipelineCreateFlagBits PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT = 0x00000008;
const VkPipelineCreateFlagBits PIPELINE_CREATE_DISPATCH_BASE_BIT = 0x00000010;
const VkPipelineCreateFlagBits PIPELINE_CREATE_DEFER_COMPILE_BIT_NV = 0x00000020;
const VkPipelineCreateFlagBits PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR = 0x00000040;
const VkPipelineCreateFlagBits PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR = 0x00000080;
const VkPipelineCreateFlagBits PIPELINE_CREATE_DISPATCH_BASE = PIPELINE_CREATE_DISPATCH_BASE_BIT;
const VkPipelineCreateFlagBits PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR = PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT;
const VkPipelineCreateFlagBits PIPELINE_CREATE_DISPATCH_BASE_KHR = PIPELINE_CREATE_DISPATCH_BASE;
const VkPipelineCreateFlagBits PIPELINE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkPipelineCreateFlags = VkFlags;

typedef VkPipelineShaderStageCreateFlagBits = inline CUInt;
const VkPipelineShaderStageCreateFlagBits PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT = 0x00000001;
const VkPipelineShaderStageCreateFlagBits PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT = 0x00000002;
const VkPipelineShaderStageCreateFlagBits PIPELINE_SHADER_STAGE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkPipelineShaderStageCreateFlags = VkFlags;

typedef VkShaderStageFlagBits = inline CUInt;
const VkShaderStageFlagBits SHADER_STAGE_VERTEX_BIT = 0x00000001;
const VkShaderStageFlagBits SHADER_STAGE_TESSELLATION_CONTROL_BIT = 0x00000002;
const VkShaderStageFlagBits SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 0x00000004;
const VkShaderStageFlagBits SHADER_STAGE_GEOMETRY_BIT = 0x00000008;
const VkShaderStageFlagBits SHADER_STAGE_FRAGMENT_BIT = 0x00000010;
const VkShaderStageFlagBits SHADER_STAGE_COMPUTE_BIT = 0x00000020;
const VkShaderStageFlagBits SHADER_STAGE_ALL_GRAPHICS = 0x0000001F;
const VkShaderStageFlagBits SHADER_STAGE_ALL = 0x7FFFFFFF;
const VkShaderStageFlagBits SHADER_STAGE_RAYGEN_BIT_NV = 0x00000100;
const VkShaderStageFlagBits SHADER_STAGE_ANY_HIT_BIT_NV = 0x00000200;
const VkShaderStageFlagBits SHADER_STAGE_CLOSEST_HIT_BIT_NV = 0x00000400;
const VkShaderStageFlagBits SHADER_STAGE_MISS_BIT_NV = 0x00000800;
const VkShaderStageFlagBits SHADER_STAGE_INTERSECTION_BIT_NV = 0x00001000;
const VkShaderStageFlagBits SHADER_STAGE_CALLABLE_BIT_NV = 0x00002000;
const VkShaderStageFlagBits SHADER_STAGE_TASK_BIT_NV = 0x00000040;
const VkShaderStageFlagBits SHADER_STAGE_MESH_BIT_NV = 0x00000080;
const VkShaderStageFlagBits SHADER_STAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkPipelineVertexInputStateCreateFlags = VkFlags;

alias VkPipelineInputAssemblyStateCreateFlags = VkFlags;

alias VkPipelineTessellationStateCreateFlags = VkFlags;

alias VkPipelineViewportStateCreateFlags = VkFlags;

alias VkPipelineRasterizationStateCreateFlags = VkFlags;

typedef VkCullModeFlagBits = inline CUInt;
const VkCullModeFlagBits CULL_MODE_NONE = 0;
const VkCullModeFlagBits CULL_MODE_FRONT_BIT = 0x00000001;
const VkCullModeFlagBits CULL_MODE_BACK_BIT = 0x00000002;
const VkCullModeFlagBits CULL_MODE_FRONT_AND_BACK = 0x00000003;
const VkCullModeFlagBits CULL_MODE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkCullModeFlags = VkFlags;

alias VkPipelineMultisampleStateCreateFlags = VkFlags;

alias VkPipelineDepthStencilStateCreateFlags = VkFlags;

alias VkPipelineColorBlendStateCreateFlags = VkFlags;

typedef VkColorComponentFlagBits = inline CUInt;
const VkColorComponentFlagBits COLOR_COMPONENT_R_BIT = 0x00000001;
const VkColorComponentFlagBits COLOR_COMPONENT_G_BIT = 0x00000002;
const VkColorComponentFlagBits COLOR_COMPONENT_B_BIT = 0x00000004;
const VkColorComponentFlagBits COLOR_COMPONENT_A_BIT = 0x00000008;
const VkColorComponentFlagBits COLOR_COMPONENT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkColorComponentFlags = VkFlags;

alias VkPipelineDynamicStateCreateFlags = VkFlags;

alias VkPipelineLayoutCreateFlags = VkFlags;

alias VkShaderStageFlags = VkFlags;

typedef VkSamplerCreateFlagBits = inline CUInt;
const VkSamplerCreateFlagBits SAMPLER_CREATE_SUBSAMPLED_BIT_EXT = 0x00000001;
const VkSamplerCreateFlagBits SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT = 0x00000002;
const VkSamplerCreateFlagBits SAMPLER_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkSamplerCreateFlags = VkFlags;

typedef VkDescriptorSetLayoutCreateFlagBits = inline CUInt;
const VkDescriptorSetLayoutCreateFlagBits DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR = 0x00000001;
const VkDescriptorSetLayoutCreateFlagBits DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT = 0x00000002;
const VkDescriptorSetLayoutCreateFlagBits DESCRIPTOR_SET_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkDescriptorSetLayoutCreateFlags = VkFlags;

typedef VkDescriptorPoolCreateFlagBits = inline CUInt;
const VkDescriptorPoolCreateFlagBits DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = 0x00000001;
const VkDescriptorPoolCreateFlagBits DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT = 0x00000002;
const VkDescriptorPoolCreateFlagBits DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkDescriptorPoolCreateFlags = VkFlags;

alias VkDescriptorPoolResetFlags = VkFlags;

typedef VkFramebufferCreateFlagBits = inline CUInt;
const VkFramebufferCreateFlagBits FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR = 0x00000001;
const VkFramebufferCreateFlagBits FRAMEBUFFER_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkFramebufferCreateFlags = VkFlags;

typedef VkRenderPassCreateFlagBits = inline CUInt;
const VkRenderPassCreateFlagBits RENDER_PASS_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkRenderPassCreateFlags = VkFlags;

typedef VkAttachmentDescriptionFlagBits = inline CUInt;
const VkAttachmentDescriptionFlagBits ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = 0x00000001;
const VkAttachmentDescriptionFlagBits ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkAttachmentDescriptionFlags = VkFlags;

typedef VkSubpassDescriptionFlagBits = inline CUInt;
const VkSubpassDescriptionFlagBits SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX = 0x00000001;
const VkSubpassDescriptionFlagBits SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX = 0x00000002;
const VkSubpassDescriptionFlagBits SUBPASS_DESCRIPTION_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkSubpassDescriptionFlags = VkFlags;

typedef VkAccessFlagBits = inline CUInt;
const VkAccessFlagBits ACCESS_INDIRECT_COMMAND_READ_BIT = 0x00000001;
const VkAccessFlagBits ACCESS_INDEX_READ_BIT = 0x00000002;
const VkAccessFlagBits ACCESS_VERTEX_ATTRIBUTE_READ_BIT = 0x00000004;
const VkAccessFlagBits ACCESS_UNIFORM_READ_BIT = 0x00000008;
const VkAccessFlagBits ACCESS_INPUT_ATTACHMENT_READ_BIT = 0x00000010;
const VkAccessFlagBits ACCESS_SHADER_READ_BIT = 0x00000020;
const VkAccessFlagBits ACCESS_SHADER_WRITE_BIT = 0x00000040;
const VkAccessFlagBits ACCESS_COLOR_ATTACHMENT_READ_BIT = 0x00000080;
const VkAccessFlagBits ACCESS_COLOR_ATTACHMENT_WRITE_BIT = 0x00000100;
const VkAccessFlagBits ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 0x00000200;
const VkAccessFlagBits ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 0x00000400;
const VkAccessFlagBits ACCESS_TRANSFER_READ_BIT = 0x00000800;
const VkAccessFlagBits ACCESS_TRANSFER_WRITE_BIT = 0x00001000;
const VkAccessFlagBits ACCESS_HOST_READ_BIT = 0x00002000;
const VkAccessFlagBits ACCESS_HOST_WRITE_BIT = 0x00004000;
const VkAccessFlagBits ACCESS_MEMORY_READ_BIT = 0x00008000;
const VkAccessFlagBits ACCESS_MEMORY_WRITE_BIT = 0x00010000;
const VkAccessFlagBits ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT = 0x02000000;
const VkAccessFlagBits ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT = 0x04000000;
const VkAccessFlagBits ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT = 0x08000000;
const VkAccessFlagBits ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT = 0x00100000;
const VkAccessFlagBits ACCESS_COMMAND_PROCESS_READ_BIT_NVX = 0x00020000;
const VkAccessFlagBits ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX = 0x00040000;
const VkAccessFlagBits ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = 0x00080000;
const VkAccessFlagBits ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV = 0x00800000;
const VkAccessFlagBits ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV = 0x00200000;
const VkAccessFlagBits ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV = 0x00400000;
const VkAccessFlagBits ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT = 0x01000000;
const VkAccessFlagBits ACCESS_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkAccessFlags = VkFlags;

typedef VkDependencyFlagBits = inline CUInt;
const VkDependencyFlagBits DEPENDENCY_BY_REGION_BIT = 0x00000001;
const VkDependencyFlagBits DEPENDENCY_DEVICE_GROUP_BIT = 0x00000004;
const VkDependencyFlagBits DEPENDENCY_VIEW_LOCAL_BIT = 0x00000002;
const VkDependencyFlagBits DEPENDENCY_VIEW_LOCAL_BIT_KHR = DEPENDENCY_VIEW_LOCAL_BIT;
const VkDependencyFlagBits DEPENDENCY_DEVICE_GROUP_BIT_KHR = DEPENDENCY_DEVICE_GROUP_BIT;
const VkDependencyFlagBits DEPENDENCY_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkDependencyFlags = VkFlags;

typedef VkCommandPoolCreateFlagBits = inline CUInt;
const VkCommandPoolCreateFlagBits COMMAND_POOL_CREATE_TRANSIENT_BIT = 0x00000001;
const VkCommandPoolCreateFlagBits COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = 0x00000002;
const VkCommandPoolCreateFlagBits COMMAND_POOL_CREATE_PROTECTED_BIT = 0x00000004;
const VkCommandPoolCreateFlagBits COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkCommandPoolCreateFlags = VkFlags;

typedef VkCommandPoolResetFlagBits = inline CUInt;
const VkCommandPoolResetFlagBits COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT = 0x00000001;
const VkCommandPoolResetFlagBits COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkCommandPoolResetFlags = VkFlags;

typedef VkCommandBufferUsageFlagBits = inline CUInt;
const VkCommandBufferUsageFlagBits COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = 0x00000001;
const VkCommandBufferUsageFlagBits COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = 0x00000002;
const VkCommandBufferUsageFlagBits COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = 0x00000004;
const VkCommandBufferUsageFlagBits COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkCommandBufferUsageFlags = VkFlags;

typedef VkQueryControlFlagBits = inline CUInt;
const VkQueryControlFlagBits QUERY_CONTROL_PRECISE_BIT = 0x00000001;
const VkQueryControlFlagBits QUERY_CONTROL_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkQueryControlFlags = VkFlags;

typedef VkCommandBufferResetFlagBits = inline CUInt;
const VkCommandBufferResetFlagBits COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = 0x00000001;
const VkCommandBufferResetFlagBits COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkCommandBufferResetFlags = VkFlags;

typedef VkStencilFaceFlagBits = inline CUInt;
const VkStencilFaceFlagBits STENCIL_FACE_FRONT_BIT = 0x00000001;
const VkStencilFaceFlagBits STENCIL_FACE_BACK_BIT = 0x00000002;
const VkStencilFaceFlagBits STENCIL_FACE_FRONT_AND_BACK = 0x00000003;
const VkStencilFaceFlagBits STENCIL_FRONT_AND_BACK = STENCIL_FACE_FRONT_AND_BACK;
const VkStencilFaceFlagBits STENCIL_FACE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkStencilFaceFlags = VkFlags;

struct VkApplicationInfo {
  VkStructureType s_type;
  void * p_next;
  CChar * p_application_name;
  uint application_version;
  CChar * p_engine_name;
  uint engine_version;
  uint api_version;
}

struct VkInstanceCreateInfo {
  VkStructureType s_type;
  void * p_next;
  VkInstanceCreateFlags flags;
  VkApplicationInfo * p_application_info;
  uint enabled_layer_count;
  CChar ** pp_enabled_layer_names;
  uint enabled_extension_count;
  CChar ** pp_enabled_extension_names;
}

alias PFN_vkAllocationFunction = fn void *(
  void * p_user_data, 
  usz size, 
  usz alignment, 
  VkSystemAllocationScope allocation_scope);

alias PFN_vkReallocationFunction = fn void *(
  void * p_user_data, 
  void * p_original, 
  usz size, 
  usz alignment, 
  VkSystemAllocationScope allocation_scope);

alias PFN_vkFreeFunction = fn void(
  void * p_user_data, 
  void * p_memory);

alias PFN_vkInternalAllocationNotification = fn void(
  void * p_user_data, 
  usz size, 
  VkInternalAllocationType allocation_type, 
  VkSystemAllocationScope allocation_scope);

alias PFN_vkInternalFreeNotification = fn void(
  void * p_user_data, 
  usz size, 
  VkInternalAllocationType allocation_type, 
  VkSystemAllocationScope allocation_scope);

struct VkAllocationCallbacks {
  void * p_user_data;
  PFN_vkAllocationFunction pfn_allocation;
  PFN_vkReallocationFunction pfn_reallocation;
  PFN_vkFreeFunction pfn_free;
  PFN_vkInternalAllocationNotification pfn_internal_allocation;
  PFN_vkInternalFreeNotification pfn_internal_free;
}

struct VkPhysicalDeviceFeatures {
  VkBool32 robust_buffer_access;
  VkBool32 full_draw_index_uint_32;
  VkBool32 image_cube_array;
  VkBool32 independent_blend;
  VkBool32 geometry_shader;
  VkBool32 tessellation_shader;
  VkBool32 sample_rate_shading;
  VkBool32 dual_src_blend;
  VkBool32 logic_op;
  VkBool32 multi_draw_indirect;
  VkBool32 draw_indirect_first_instance;
  VkBool32 depth_clamp;
  VkBool32 depth_bias_clamp;
  VkBool32 fill_mode_non_solid;
  VkBool32 depth_bounds;
  VkBool32 wide_lines;
  VkBool32 large_points;
  VkBool32 alpha_to_one;
  VkBool32 multi_viewport;
  VkBool32 sampler_anisotropy;
  VkBool32 texture_compression_etc_2;
  VkBool32 texture_compression_astc__ldr;
  VkBool32 texture_compression_bc;
  VkBool32 occlusion_query_precise;
  VkBool32 pipeline_statistics_query;
  VkBool32 vertex_pipeline_stores_and_atomics;
  VkBool32 fragment_stores_and_atomics;
  VkBool32 shader_tessellation_and_geometry_point_size;
  VkBool32 shader_image_gather_extended;
  VkBool32 shader_storage_image_extended_formats;
  VkBool32 shader_storage_image_multisample;
  VkBool32 shader_storage_image_read_without_format;
  VkBool32 shader_storage_image_write_without_format;
  VkBool32 shader_uniform_buffer_array_dynamic_indexing;
  VkBool32 shader_sampled_image_array_dynamic_indexing;
  VkBool32 shader_storage_buffer_array_dynamic_indexing;
  VkBool32 shader_storage_image_array_dynamic_indexing;
  VkBool32 shader_clip_distance;
  VkBool32 shader_cull_distance;
  VkBool32 shader_float_64;
  VkBool32 shader_int_64;
  VkBool32 shader_int_16;
  VkBool32 shader_resource_residency;
  VkBool32 shader_resource_min_lod;
  VkBool32 sparse_binding;
  VkBool32 sparse_residency_buffer;
  VkBool32 sparse_residency_image_2_d;
  VkBool32 sparse_residency_image_3_d;
  VkBool32 sparse_residency_2_samples;
  VkBool32 sparse_residency_4_samples;
  VkBool32 sparse_residency_8_samples;
  VkBool32 sparse_residency_16_samples;
  VkBool32 sparse_residency_aliased;
  VkBool32 variable_multisample_rate;
  VkBool32 inherited_queries;
}

struct VkFormatProperties {
  VkFormatFeatureFlags linear_tiling_features;
  VkFormatFeatureFlags optimal_tiling_features;
  VkFormatFeatureFlags buffer_features;
}

struct VkExtent3D {
  uint width;
  uint height;
  uint depth;
}

struct VkImageFormatProperties {
  VkExtent3D max_extent;
  uint max_mip_levels;
  uint max_array_layers;
  VkSampleCountFlags sample_counts;
  VkDeviceSize max_resource_size;
}

struct VkPhysicalDeviceLimits {
  uint max_image_dimension_1_d;
  uint max_image_dimension_2_d;
  uint max_image_dimension_3_d;
  uint max_image_dimension_cube;
  uint max_image_array_layers;
  uint max_texel_buffer_elements;
  uint max_uniform_buffer_range;
  uint max_storage_buffer_range;
  uint max_push_constants_size;
  uint max_memory_allocation_count;
  uint max_sampler_allocation_count;
  VkDeviceSize buffer_image_granularity;
  VkDeviceSize sparse_address_space_size;
  uint max_bound_descriptor_sets;
  uint max_per_stage_descriptor_samplers;
  uint max_per_stage_descriptor_uniform_buffers;
  uint max_per_stage_descriptor_storage_buffers;
  uint max_per_stage_descriptor_sampled_images;
  uint max_per_stage_descriptor_storage_images;
  uint max_per_stage_descriptor_input_attachments;
  uint max_per_stage_resources;
  uint max_descriptor_set_samplers;
  uint max_descriptor_set_uniform_buffers;
  uint max_descriptor_set_uniform_buffers_dynamic;
  uint max_descriptor_set_storage_buffers;
  uint max_descriptor_set_storage_buffers_dynamic;
  uint max_descriptor_set_sampled_images;
  uint max_descriptor_set_storage_images;
  uint max_descriptor_set_input_attachments;
  uint max_vertex_input_attributes;
  uint max_vertex_input_bindings;
  uint max_vertex_input_attribute_offset;
  uint max_vertex_input_binding_stride;
  uint max_vertex_output_components;
  uint max_tessellation_generation_level;
  uint max_tessellation_patch_size;
  uint max_tessellation_control_per_vertex_input_components;
  uint max_tessellation_control_per_vertex_output_components;
  uint max_tessellation_control_per_patch_output_components;
  uint max_tessellation_control_total_output_components;
  uint max_tessellation_evaluation_input_components;
  uint max_tessellation_evaluation_output_components;
  uint max_geometry_shader_invocations;
  uint max_geometry_input_components;
  uint max_geometry_output_components;
  uint max_geometry_output_vertices;
  uint max_geometry_total_output_components;
  uint max_fragment_input_components;
  uint max_fragment_output_attachments;
  uint max_fragment_dual_src_attachments;
  uint max_fragment_combined_output_resources;
  uint max_compute_shared_memory_size;
  uint[3] max_compute_work_group_count;
  uint max_compute_work_group_invocations;
  uint[3] max_compute_work_group_size;
  uint sub_pixel_precision_bits;
  uint sub_texel_precision_bits;
  uint mipmap_precision_bits;
  uint max_draw_indexed_index_value;
  uint max_draw_indirect_count;
  float max_sampler_lod_bias;
  float max_sampler_anisotropy;
  uint max_viewports;
  uint[2] max_viewport_dimensions;
  float[2] viewport_bounds_range;
  uint viewport_sub_pixel_bits;
  usz min_memory_map_alignment;
  VkDeviceSize min_texel_buffer_offset_alignment;
  VkDeviceSize min_uniform_buffer_offset_alignment;
  VkDeviceSize min_storage_buffer_offset_alignment;
  int min_texel_offset;
  uint max_texel_offset;
  int min_texel_gather_offset;
  uint max_texel_gather_offset;
  float min_interpolation_offset;
  float max_interpolation_offset;
  uint sub_pixel_interpolation_offset_bits;
  uint max_framebuffer_width;
  uint max_framebuffer_height;
  uint max_framebuffer_layers;
  VkSampleCountFlags framebuffer_color_sample_counts;
  VkSampleCountFlags framebuffer_depth_sample_counts;
  VkSampleCountFlags framebuffer_stencil_sample_counts;
  VkSampleCountFlags framebuffer_no_attachments_sample_counts;
  uint max_color_attachments;
  VkSampleCountFlags sampled_image_color_sample_counts;
  VkSampleCountFlags sampled_image_integer_sample_counts;
  VkSampleCountFlags sampled_image_depth_sample_counts;
  VkSampleCountFlags sampled_image_stencil_sample_counts;
  VkSampleCountFlags storage_image_sample_counts;
  uint max_sample_mask_words;
  VkBool32 timestamp_compute_and_graphics;
  float timestamp_period;
  uint max_clip_distances;
  uint max_cull_distances;
  uint max_combined_clip_and_cull_distances;
  uint discrete_queue_priorities;
  float[2] point_size_range;
  float[2] line_width_range;
  float point_size_granularity;
  float line_width_granularity;
  VkBool32 strict_lines;
  VkBool32 standard_sample_locations;
  VkDeviceSize optimal_buffer_copy_offset_alignment;
  VkDeviceSize optimal_buffer_copy_row_pitch_alignment;
  VkDeviceSize non_coherent_atom_size;
}

struct VkPhysicalDeviceSparseProperties {
  VkBool32 residency_standard_2_dblock_shape;
  VkBool32 residency_standard_2_dmultisample_block_shape;
  VkBool32 residency_standard_3_dblock_shape;
  VkBool32 residency_aligned_mip_size;
  VkBool32 residency_non_resident_strict;
}

struct VkPhysicalDeviceProperties {
  uint api_version;
  uint driver_version;
  uint vendor_id;
  uint device_id;
  VkPhysicalDeviceType device_type;
  CChar[256] device_name;
  char[16] pipeline_cache_uuid;
  VkPhysicalDeviceLimits limits;
  VkPhysicalDeviceSparseProperties sparse_properties;
}

struct VkQueueFamilyProperties {
  VkQueueFlags queue_flags;
  uint queue_count;
  uint timestamp_valid_bits;
  VkExtent3D min_image_transfer_granularity;
}

struct VkMemoryType {
  VkMemoryPropertyFlags property_flags;
  uint heap_index;
}

struct VkMemoryHeap {
  VkDeviceSize size;
  VkMemoryHeapFlags flags;
}

struct VkPhysicalDeviceMemoryProperties {
  uint memory_type_count;
  VkMemoryType[32] memory_types;
  uint memory_heap_count;
  VkMemoryHeap[16] memory_heaps;
}

alias PFN_vkVoidFunction = fn void();

struct VkDeviceQueueCreateInfo {
  VkStructureType s_type;
  void * p_next;
  VkDeviceQueueCreateFlags flags;
  uint queue_family_index;
  uint queue_count;
  float * p_queue_priorities;
}

struct VkDeviceCreateInfo {
  VkStructureType s_type;
  void * p_next;
  VkDeviceCreateFlags flags;
  uint queue_create_info_count;
  VkDeviceQueueCreateInfo * p_queue_create_infos;
  uint enabled_layer_count;
  CChar ** pp_enabled_layer_names;
  uint enabled_extension_count;
  CChar ** pp_enabled_extension_names;
  VkPhysicalDeviceFeatures * p_enabled_features;
}

struct VkExtensionProperties {
  CChar[256] extension_name;
  uint spec_version;
}

struct VkLayerProperties {
  CChar[256] layer_name;
  uint spec_version;
  uint implementation_version;
  CChar[256] description;
}

struct VkSubmitInfo {
  VkStructureType s_type;
  void * p_next;
  uint wait_semaphore_count;
  VkSemaphore * p_wait_semaphores;
  VkPipelineStageFlags * p_wait_dst_stage_mask;
  uint command_buffer_count;
  VkCommandBuffer * p_command_buffers;
  uint signal_semaphore_count;
  VkSemaphore * p_signal_semaphores;
}

struct VkMemoryAllocateInfo {
  VkStructureType s_type;
  void * p_next;
  VkDeviceSize allocation_size;
  uint memory_type_index;
}

struct VkMappedMemoryRange {
  VkStructureType s_type;
  void * p_next;
  VkDeviceMemory memory;
  VkDeviceSize offset;
  VkDeviceSize size;
}

struct VkMemoryRequirements {
  VkDeviceSize size;
  VkDeviceSize alignment;
  uint memory_type_bits;
}

struct VkSparseImageFormatProperties {
  VkImageAspectFlags aspect_mask;
  VkExtent3D image_granularity;
  VkSparseImageFormatFlags flags;
}

struct VkSparseImageMemoryRequirements {
  VkSparseImageFormatProperties format_properties;
  uint image_mip_tail_first_lod;
  VkDeviceSize image_mip_tail_size;
  VkDeviceSize image_mip_tail_offset;
  VkDeviceSize image_mip_tail_stride;
}

struct VkSparseMemoryBind {
  VkDeviceSize resource_offset;
  VkDeviceSize size;
  VkDeviceMemory memory;
  VkDeviceSize memory_offset;
  VkSparseMemoryBindFlags flags;
}

struct VkSparseBufferMemoryBindInfo {
  VkBuffer buffer;
  uint bind_count;
  VkSparseMemoryBind * p_binds;
}

struct VkSparseImageOpaqueMemoryBindInfo {
  VkImage image;
  uint bind_count;
  VkSparseMemoryBind * p_binds;
}

struct VkImageSubresource {
  VkImageAspectFlags aspect_mask;
  uint mip_level;
  uint array_layer;
}

struct VkOffset3D {
  int x;
  int y;
  int z;
}

struct VkSparseImageMemoryBind {
  VkImageSubresource subresource;
  VkOffset3D offset;
  VkExtent3D extent;
  VkDeviceMemory memory;
  VkDeviceSize memory_offset;
  VkSparseMemoryBindFlags flags;
}

struct VkSparseImageMemoryBindInfo {
  VkImage image;
  uint bind_count;
  VkSparseImageMemoryBind * p_binds;
}

struct VkBindSparseInfo {
  VkStructureType s_type;
  void * p_next;
  uint wait_semaphore_count;
  VkSemaphore * p_wait_semaphores;
  uint buffer_bind_count;
  VkSparseBufferMemoryBindInfo * p_buffer_binds;
  uint image_opaque_bind_count;
  VkSparseImageOpaqueMemoryBindInfo * p_image_opaque_binds;
  uint image_bind_count;
  VkSparseImageMemoryBindInfo * p_image_binds;
  uint signal_semaphore_count;
  VkSemaphore * p_signal_semaphores;
}

struct VkFenceCreateInfo {
  VkStructureType s_type;
  void * p_next;
  VkFenceCreateFlags flags;
}

struct VkSemaphoreCreateInfo {
  VkStructureType s_type;
  void * p_next;
  VkSemaphoreCreateFlags flags;
}

struct VkEventCreateInfo {
  VkStructureType s_type;
  void * p_next;
  VkEventCreateFlags flags;
}

struct VkQueryPoolCreateInfo {
  VkStructureType s_type;
  void * p_next;
  VkQueryPoolCreateFlags flags;
  VkQueryType query_type;
  uint query_count;
  VkQueryPipelineStatisticFlags pipeline_statistics;
}

struct VkBufferCreateInfo {
  VkStructureType s_type;
  void * p_next;
  VkBufferCreateFlags flags;
  VkDeviceSize size;
  VkBufferUsageFlags usage;
  VkSharingMode sharing_mode;
  uint queue_family_index_count;
  uint * p_queue_family_indices;
}

struct VkBufferViewCreateInfo {
  VkStructureType s_type;
  void * p_next;
  VkBufferViewCreateFlags flags;
  VkBuffer buffer;
  VkFormat format;
  VkDeviceSize offset;
  VkDeviceSize range;
}

struct VkImageCreateInfo {
  VkStructureType s_type;
  void * p_next;
  VkImageCreateFlags flags;
  VkImageType image_type;
  VkFormat format;
  VkExtent3D extent;
  uint mip_levels;
  uint array_layers;
  VkSampleCountFlagBits samples;
  VkImageTiling tiling;
  VkImageUsageFlags usage;
  VkSharingMode sharing_mode;
  uint queue_family_index_count;
  uint * p_queue_family_indices;
  VkImageLayout initial_layout;
}

struct VkSubresourceLayout {
  VkDeviceSize offset;
  VkDeviceSize size;
  VkDeviceSize row_pitch;
  VkDeviceSize array_pitch;
  VkDeviceSize depth_pitch;
}

struct VkComponentMapping {
  VkComponentSwizzle r;
  VkComponentSwizzle g;
  VkComponentSwizzle b;
  VkComponentSwizzle a;
}

struct VkImageSubresourceRange {
  VkImageAspectFlags aspect_mask;
  uint base_mip_level;
  uint level_count;
  uint base_array_layer;
  uint layer_count;
}

struct VkImageViewCreateInfo {
  VkStructureType s_type;
  void * p_next;
  VkImageViewCreateFlags flags;
  VkImage image;
  VkImageViewType view_type;
  VkFormat format;
  VkComponentMapping components;
  VkImageSubresourceRange subresource_range;
}

struct VkShaderModuleCreateInfo {
  VkStructureType s_type;
  void * p_next;
  VkShaderModuleCreateFlags flags;
  usz code_size;
  uint * p_code;
}

struct VkPipelineCacheCreateInfo {
  VkStructureType s_type;
  void * p_next;
  VkPipelineCacheCreateFlags flags;
  usz initial_data_size;
  void * p_initial_data;
}

struct VkSpecializationMapEntry {
  uint constant_id;
  uint offset;
  usz size;
}

struct VkSpecializationInfo {
  uint map_entry_count;
  VkSpecializationMapEntry * p_map_entries;
  usz data_size;
  void * p_data;
}

struct VkPipelineShaderStageCreateInfo {
  VkStructureType s_type;
  void * p_next;
  VkPipelineShaderStageCreateFlags flags;
  VkShaderStageFlagBits stage;
  VkShaderModule mod;
  CChar * p_name;
  VkSpecializationInfo * p_specialization_info;
}

struct VkVertexInputBindingDescription {
  uint binding;
  uint stride;
  VkVertexInputRate input_rate;
}

struct VkVertexInputAttributeDescription {
  uint location;
  uint binding;
  VkFormat format;
  uint offset;
}

struct VkPipelineVertexInputStateCreateInfo {
  VkStructureType s_type;
  void * p_next;
  VkPipelineVertexInputStateCreateFlags flags;
  uint vertex_binding_description_count;
  VkVertexInputBindingDescription * p_vertex_binding_descriptions;
  uint vertex_attribute_description_count;
  VkVertexInputAttributeDescription * p_vertex_attribute_descriptions;
}

struct VkPipelineInputAssemblyStateCreateInfo {
  VkStructureType s_type;
  void * p_next;
  VkPipelineInputAssemblyStateCreateFlags flags;
  VkPrimitiveTopology topology;
  VkBool32 primitive_restart_enable;
}

struct VkPipelineTessellationStateCreateInfo {
  VkStructureType s_type;
  void * p_next;
  VkPipelineTessellationStateCreateFlags flags;
  uint patch_control_points;
}

struct VkViewport {
  float x;
  float y;
  float width;
  float height;
  float min_depth;
  float max_depth;
}

struct VkOffset2D {
  int x;
  int y;
}

struct VkExtent2D {
  uint width;
  uint height;
}

struct VkRect2D {
  VkOffset2D offset;
  VkExtent2D extent;
}

struct VkPipelineViewportStateCreateInfo {
  VkStructureType s_type;
  void * p_next;
  VkPipelineViewportStateCreateFlags flags;
  uint viewport_count;
  VkViewport * p_viewports;
  uint scissor_count;
  VkRect2D * p_scissors;
}

struct VkPipelineRasterizationStateCreateInfo {
  VkStructureType s_type;
  void * p_next;
  VkPipelineRasterizationStateCreateFlags flags;
  VkBool32 depth_clamp_enable;
  VkBool32 rasterizer_discard_enable;
  VkPolygonMode polygon_mode;
  VkCullModeFlags cull_mode;
  VkFrontFace front_face;
  VkBool32 depth_bias_enable;
  float depth_bias_constant_factor;
  float depth_bias_clamp;
  float depth_bias_slope_factor;
  float line_width;
}

struct VkPipelineMultisampleStateCreateInfo {
  VkStructureType s_type;
  void * p_next;
  VkPipelineMultisampleStateCreateFlags flags;
  VkSampleCountFlagBits rasterization_samples;
  VkBool32 sample_shading_enable;
  float min_sample_shading;
  VkSampleMask * p_sample_mask;
  VkBool32 alpha_to_coverage_enable;
  VkBool32 alpha_to_one_enable;
}

struct VkStencilOpState {
  VkStencilOp fail_op;
  VkStencilOp pass_op;
  VkStencilOp depth_fail_op;
  VkCompareOp compare_op;
  uint compare_mask;
  uint write_mask;
  uint reference;
}

struct VkPipelineDepthStencilStateCreateInfo {
  VkStructureType s_type;
  void * p_next;
  VkPipelineDepthStencilStateCreateFlags flags;
  VkBool32 depth_test_enable;
  VkBool32 depth_write_enable;
  VkCompareOp depth_compare_op;
  VkBool32 depth_bounds_test_enable;
  VkBool32 stencil_test_enable;
  VkStencilOpState front;
  VkStencilOpState back;
  float min_depth_bounds;
  float max_depth_bounds;
}

struct VkPipelineColorBlendAttachmentState {
  VkBool32 blend_enable;
  VkBlendFactor src_color_blend_factor;
  VkBlendFactor dst_color_blend_factor;
  VkBlendOp color_blend_op;
  VkBlendFactor src_alpha_blend_factor;
  VkBlendFactor dst_alpha_blend_factor;
  VkBlendOp alpha_blend_op;
  VkColorComponentFlags color_write_mask;
}

struct VkPipelineColorBlendStateCreateInfo {
  VkStructureType s_type;
  void * p_next;
  VkPipelineColorBlendStateCreateFlags flags;
  VkBool32 logic_op_enable;
  VkLogicOp logic_op;
  uint attachment_count;
  VkPipelineColorBlendAttachmentState * p_attachments;
  float[4] blend_constants;
}

struct VkPipelineDynamicStateCreateInfo {
  VkStructureType s_type;
  void * p_next;
  VkPipelineDynamicStateCreateFlags flags;
  uint dynamic_state_count;
  VkDynamicState * p_dynamic_states;
}

struct VkGraphicsPipelineCreateInfo {
  VkStructureType s_type;
  void * p_next;
  VkPipelineCreateFlags flags;
  uint stage_count;
  VkPipelineShaderStageCreateInfo * p_stages;
  VkPipelineVertexInputStateCreateInfo * p_vertex_input_state;
  VkPipelineInputAssemblyStateCreateInfo * p_input_assembly_state;
  VkPipelineTessellationStateCreateInfo * p_tessellation_state;
  VkPipelineViewportStateCreateInfo * p_viewport_state;
  VkPipelineRasterizationStateCreateInfo * p_rasterization_state;
  VkPipelineMultisampleStateCreateInfo * p_multisample_state;
  VkPipelineDepthStencilStateCreateInfo * p_depth_stencil_state;
  VkPipelineColorBlendStateCreateInfo * p_color_blend_state;
  VkPipelineDynamicStateCreateInfo * p_dynamic_state;
  VkPipelineLayout layout;
  VkRenderPass render_pass;
  uint subpass;
  VkPipeline base_pipeline_handle;
  int base_pipeline_index;
}

struct VkComputePipelineCreateInfo {
  VkStructureType s_type;
  void * p_next;
  VkPipelineCreateFlags flags;
  VkPipelineShaderStageCreateInfo stage;
  VkPipelineLayout layout;
  VkPipeline base_pipeline_handle;
  int base_pipeline_index;
}

struct VkPushConstantRange {
  VkShaderStageFlags stage_flags;
  uint offset;
  uint size;
}

struct VkPipelineLayoutCreateInfo {
  VkStructureType s_type;
  void * p_next;
  VkPipelineLayoutCreateFlags flags;
  uint set_layout_count;
  VkDescriptorSetLayout * p_set_layouts;
  uint push_constant_range_count;
  VkPushConstantRange * p_push_constant_ranges;
}

struct VkSamplerCreateInfo {
  VkStructureType s_type;
  void * p_next;
  VkSamplerCreateFlags flags;
  VkFilter mag_filter;
  VkFilter min_filter;
  VkSamplerMipmapMode mipmap_mode;
  VkSamplerAddressMode address_mode_u;
  VkSamplerAddressMode address_mode_v;
  VkSamplerAddressMode address_mode_w;
  float mip_lod_bias;
  VkBool32 anisotropy_enable;
  float max_anisotropy;
  VkBool32 compare_enable;
  VkCompareOp compare_op;
  float min_lod;
  float max_lod;
  VkBorderColor border_color;
  VkBool32 unnormalized_coordinates;
}

struct VkDescriptorSetLayoutBinding {
  uint binding;
  VkDescriptorType descriptor_type;
  uint descriptor_count;
  VkShaderStageFlags stage_flags;
  VkSampler * p_immutable_samplers;
}

struct VkDescriptorSetLayoutCreateInfo {
  VkStructureType s_type;
  void * p_next;
  VkDescriptorSetLayoutCreateFlags flags;
  uint binding_count;
  VkDescriptorSetLayoutBinding * p_bindings;
}

struct VkDescriptorPoolSize {
  VkDescriptorType type;
  uint descriptor_count;
}

struct VkDescriptorPoolCreateInfo {
  VkStructureType s_type;
  void * p_next;
  VkDescriptorPoolCreateFlags flags;
  uint max_sets;
  uint pool_size_count;
  VkDescriptorPoolSize * p_pool_sizes;
}

struct VkDescriptorSetAllocateInfo {
  VkStructureType s_type;
  void * p_next;
  VkDescriptorPool descriptor_pool;
  uint descriptor_set_count;
  VkDescriptorSetLayout * p_set_layouts;
}

struct VkDescriptorImageInfo {
  VkSampler sampler;
  VkImageView image_view;
  VkImageLayout image_layout;
}

struct VkDescriptorBufferInfo {
  VkBuffer buffer;
  VkDeviceSize offset;
  VkDeviceSize range;
}

struct VkWriteDescriptorSet {
  VkStructureType s_type;
  void * p_next;
  VkDescriptorSet dst_set;
  uint dst_binding;
  uint dst_array_element;
  uint descriptor_count;
  VkDescriptorType descriptor_type;
  VkDescriptorImageInfo * p_image_info;
  VkDescriptorBufferInfo * p_buffer_info;
  VkBufferView * p_texel_buffer_view;
}

struct VkCopyDescriptorSet {
  VkStructureType s_type;
  void * p_next;
  VkDescriptorSet src_set;
  uint src_binding;
  uint src_array_element;
  VkDescriptorSet dst_set;
  uint dst_binding;
  uint dst_array_element;
  uint descriptor_count;
}

struct VkFramebufferCreateInfo {
  VkStructureType s_type;
  void * p_next;
  VkFramebufferCreateFlags flags;
  VkRenderPass render_pass;
  uint attachment_count;
  VkImageView * p_attachments;
  uint width;
  uint height;
  uint layers;
}

struct VkAttachmentDescription {
  VkAttachmentDescriptionFlags flags;
  VkFormat format;
  VkSampleCountFlagBits samples;
  VkAttachmentLoadOp load_op;
  VkAttachmentStoreOp store_op;
  VkAttachmentLoadOp stencil_load_op;
  VkAttachmentStoreOp stencil_store_op;
  VkImageLayout initial_layout;
  VkImageLayout final_layout;
}

struct VkAttachmentReference {
  uint attachment;
  VkImageLayout layout;
}

struct VkSubpassDescription {
  VkSubpassDescriptionFlags flags;
  VkPipelineBindPoint pipeline_bind_point;
  uint input_attachment_count;
  VkAttachmentReference * p_input_attachments;
  uint color_attachment_count;
  VkAttachmentReference * p_color_attachments;
  VkAttachmentReference * p_resolve_attachments;
  VkAttachmentReference * p_depth_stencil_attachment;
  uint preserve_attachment_count;
  uint * p_preserve_attachments;
}

struct VkSubpassDependency {
  uint src_subpass;
  uint dst_subpass;
  VkPipelineStageFlags src_stage_mask;
  VkPipelineStageFlags dst_stage_mask;
  VkAccessFlags src_access_mask;
  VkAccessFlags dst_access_mask;
  VkDependencyFlags dependency_flags;
}

struct VkRenderPassCreateInfo {
  VkStructureType s_type;
  void * p_next;
  VkRenderPassCreateFlags flags;
  uint attachment_count;
  VkAttachmentDescription * p_attachments;
  uint subpass_count;
  VkSubpassDescription * p_subpasses;
  uint dependency_count;
  VkSubpassDependency * p_dependencies;
}

struct VkCommandPoolCreateInfo {
  VkStructureType s_type;
  void * p_next;
  VkCommandPoolCreateFlags flags;
  uint queue_family_index;
}

struct VkCommandBufferAllocateInfo {
  VkStructureType s_type;
  void * p_next;
  VkCommandPool command_pool;
  VkCommandBufferLevel level;
  uint command_buffer_count;
}

struct VkCommandBufferInheritanceInfo {
  VkStructureType s_type;
  void * p_next;
  VkRenderPass render_pass;
  uint subpass;
  VkFramebuffer framebuffer;
  VkBool32 occlusion_query_enable;
  VkQueryControlFlags query_flags;
  VkQueryPipelineStatisticFlags pipeline_statistics;
}

struct VkCommandBufferBeginInfo {
  VkStructureType s_type;
  void * p_next;
  VkCommandBufferUsageFlags flags;
  VkCommandBufferInheritanceInfo * p_inheritance_info;
}

struct VkBufferCopy {
  VkDeviceSize src_offset;
  VkDeviceSize dst_offset;
  VkDeviceSize size;
}

struct VkImageSubresourceLayers {
  VkImageAspectFlags aspect_mask;
  uint mip_level;
  uint base_array_layer;
  uint layer_count;
}

struct VkImageCopy {
  VkImageSubresourceLayers src_subresource;
  VkOffset3D src_offset;
  VkImageSubresourceLayers dst_subresource;
  VkOffset3D dst_offset;
  VkExtent3D extent;
}

struct VkImageBlit {
  VkImageSubresourceLayers src_subresource;
  VkOffset3D[2] src_offsets;
  VkImageSubresourceLayers dst_subresource;
  VkOffset3D[2] dst_offsets;
}

struct VkBufferImageCopy {
  VkDeviceSize buffer_offset;
  uint buffer_row_length;
  uint buffer_image_height;
  VkImageSubresourceLayers image_subresource;
  VkOffset3D image_offset;
  VkExtent3D image_extent;
}

union VkClearColorValue {
  float[4] float_32;
  int[4] int_32;
  uint[4] uint_32;
}

struct VkClearDepthStencilValue {
  float depth;
  uint stencil;
}

union VkClearValue {
  VkClearColorValue color;
  VkClearDepthStencilValue depth_stencil;
}

struct VkClearAttachment {
  VkImageAspectFlags aspect_mask;
  uint color_attachment;
  VkClearValue clear_value;
}

struct VkClearRect {
  VkRect2D rect;
  uint base_array_layer;
  uint layer_count;
}

struct VkImageResolve {
  VkImageSubresourceLayers src_subresource;
  VkOffset3D src_offset;
  VkImageSubresourceLayers dst_subresource;
  VkOffset3D dst_offset;
  VkExtent3D extent;
}

struct VkMemoryBarrier {
  VkStructureType s_type;
  void * p_next;
  VkAccessFlags src_access_mask;
  VkAccessFlags dst_access_mask;
}

struct VkBufferMemoryBarrier {
  VkStructureType s_type;
  void * p_next;
  VkAccessFlags src_access_mask;
  VkAccessFlags dst_access_mask;
  uint src_queue_family_index;
  uint dst_queue_family_index;
  VkBuffer buffer;
  VkDeviceSize offset;
  VkDeviceSize size;
}

struct VkImageMemoryBarrier {
  VkStructureType s_type;
  void * p_next;
  VkAccessFlags src_access_mask;
  VkAccessFlags dst_access_mask;
  VkImageLayout old_layout;
  VkImageLayout new_layout;
  uint src_queue_family_index;
  uint dst_queue_family_index;
  VkImage image;
  VkImageSubresourceRange subresource_range;
}

struct VkRenderPassBeginInfo {
  VkStructureType s_type;
  void * p_next;
  VkRenderPass render_pass;
  VkFramebuffer framebuffer;
  VkRect2D render_area;
  uint clear_value_count;
  VkClearValue * p_clear_values;
}

struct VkDispatchIndirectCommand {
  uint x;
  uint y;
  uint z;
}

struct VkDrawIndexedIndirectCommand {
  uint index_count;
  uint instance_count;
  uint first_index;
  int vertex_offset;
  uint first_instance;
}

struct VkDrawIndirectCommand {
  uint vertex_count;
  uint instance_count;
  uint first_vertex;
  uint first_instance;
}

struct VkBaseOutStructure {
  VkStructureType s_type;
  VkBaseOutStructure * p_next;
}

struct VkBaseInStructure {
  VkStructureType s_type;
  VkBaseInStructure * p_next;
}

alias PFN_vkCreateInstance = fn VkResult(
  VkInstanceCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkInstance * p_instance);

alias PFN_vkDestroyInstance = fn void(
  VkInstance instance, 
  VkAllocationCallbacks * p_allocator);

alias PFN_vkEnumeratePhysicalDevices = fn VkResult(
  VkInstance instance, 
  uint * p_physical_device_count, 
  VkPhysicalDevice * p_physical_devices);

alias PFN_vkGetPhysicalDeviceFeatures = fn void(
  VkPhysicalDevice physical_device, 
  VkPhysicalDeviceFeatures * p_features);

alias PFN_vkGetPhysicalDeviceFormatProperties = fn void(
  VkPhysicalDevice physical_device, 
  VkFormat format, 
  VkFormatProperties * p_format_properties);

alias PFN_vkGetPhysicalDeviceImageFormatProperties = fn VkResult(
  VkPhysicalDevice physical_device, 
  VkFormat format, 
  VkImageType type, 
  VkImageTiling tiling, 
  VkImageUsageFlags usage, 
  VkImageCreateFlags flags, 
  VkImageFormatProperties * p_image_format_properties);

alias PFN_vkGetPhysicalDeviceProperties = fn void(
  VkPhysicalDevice physical_device, 
  VkPhysicalDeviceProperties * p_properties);

alias PFN_vkGetPhysicalDeviceQueueFamilyProperties = fn void(
  VkPhysicalDevice physical_device, 
  uint * p_queue_family_property_count, 
  VkQueueFamilyProperties * p_queue_family_properties);

alias PFN_vkGetPhysicalDeviceMemoryProperties = fn void(
  VkPhysicalDevice physical_device, 
  VkPhysicalDeviceMemoryProperties * p_memory_properties);

alias PFN_vkGetInstanceProcAddr = fn PFN_vkVoidFunction(
  VkInstance instance, 
  CChar * p_name);

alias PFN_vkGetDeviceProcAddr = fn PFN_vkVoidFunction(
  VkDevice device, 
  CChar * p_name);

alias PFN_vkCreateDevice = fn VkResult(
  VkPhysicalDevice physical_device, 
  VkDeviceCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkDevice * p_device);

alias PFN_vkDestroyDevice = fn void(
  VkDevice device, 
  VkAllocationCallbacks * p_allocator);

alias PFN_vkEnumerateInstanceExtensionProperties = fn VkResult(
  CChar * p_layer_name, 
  uint * p_property_count, 
  VkExtensionProperties * p_properties);

alias PFN_vkEnumerateDeviceExtensionProperties = fn VkResult(
  VkPhysicalDevice physical_device, 
  CChar * p_layer_name, 
  uint * p_property_count, 
  VkExtensionProperties * p_properties);

alias PFN_vkEnumerateInstanceLayerProperties = fn VkResult(
  uint * p_property_count, 
  VkLayerProperties * p_properties);

alias PFN_vkEnumerateDeviceLayerProperties = fn VkResult(
  VkPhysicalDevice physical_device, 
  uint * p_property_count, 
  VkLayerProperties * p_properties);

alias PFN_vkGetDeviceQueue = fn void(
  VkDevice device, 
  uint queue_family_index, 
  uint queue_index, 
  VkQueue * p_queue);

alias PFN_vkQueueSubmit = fn VkResult(
  VkQueue queue, 
  uint submit_count, 
  VkSubmitInfo * p_submits, 
  VkFence fence);

alias PFN_vkQueueWaitIdle = fn VkResult(  VkQueue queue);

alias PFN_vkDeviceWaitIdle = fn VkResult(  VkDevice device);

alias PFN_vkAllocateMemory = fn VkResult(
  VkDevice device, 
  VkMemoryAllocateInfo * p_allocate_info, 
  VkAllocationCallbacks * p_allocator, 
  VkDeviceMemory * p_memory);

alias PFN_vkFreeMemory = fn void(
  VkDevice device, 
  VkDeviceMemory memory, 
  VkAllocationCallbacks * p_allocator);

alias PFN_vkMapMemory = fn VkResult(
  VkDevice device, 
  VkDeviceMemory memory, 
  VkDeviceSize offset, 
  VkDeviceSize size, 
  VkMemoryMapFlags flags, 
  void ** pp_data);

alias PFN_vkUnmapMemory = fn void(
  VkDevice device, 
  VkDeviceMemory memory);

alias PFN_vkFlushMappedMemoryRanges = fn VkResult(
  VkDevice device, 
  uint memory_range_count, 
  VkMappedMemoryRange * p_memory_ranges);

alias PFN_vkInvalidateMappedMemoryRanges = fn VkResult(
  VkDevice device, 
  uint memory_range_count, 
  VkMappedMemoryRange * p_memory_ranges);

alias PFN_vkGetDeviceMemoryCommitment = fn void(
  VkDevice device, 
  VkDeviceMemory memory, 
  VkDeviceSize * p_committed_memory_in_bytes);

alias PFN_vkBindBufferMemory = fn VkResult(
  VkDevice device, 
  VkBuffer buffer, 
  VkDeviceMemory memory, 
  VkDeviceSize memory_offset);

alias PFN_vkBindImageMemory = fn VkResult(
  VkDevice device, 
  VkImage image, 
  VkDeviceMemory memory, 
  VkDeviceSize memory_offset);

alias PFN_vkGetBufferMemoryRequirements = fn void(
  VkDevice device, 
  VkBuffer buffer, 
  VkMemoryRequirements * p_memory_requirements);

alias PFN_vkGetImageMemoryRequirements = fn void(
  VkDevice device, 
  VkImage image, 
  VkMemoryRequirements * p_memory_requirements);

alias PFN_vkGetImageSparseMemoryRequirements = fn void(
  VkDevice device, 
  VkImage image, 
  uint * p_sparse_memory_requirement_count, 
  VkSparseImageMemoryRequirements * p_sparse_memory_requirements);

alias PFN_vkGetPhysicalDeviceSparseImageFormatProperties = fn void(
  VkPhysicalDevice physical_device, 
  VkFormat format, 
  VkImageType type, 
  VkSampleCountFlagBits samples, 
  VkImageUsageFlags usage, 
  VkImageTiling tiling, 
  uint * p_property_count, 
  VkSparseImageFormatProperties * p_properties);

alias PFN_vkQueueBindSparse = fn VkResult(
  VkQueue queue, 
  uint bind_info_count, 
  VkBindSparseInfo * p_bind_info, 
  VkFence fence);

alias PFN_vkCreateFence = fn VkResult(
  VkDevice device, 
  VkFenceCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkFence * p_fence);

alias PFN_vkDestroyFence = fn void(
  VkDevice device, 
  VkFence fence, 
  VkAllocationCallbacks * p_allocator);

alias PFN_vkResetFences = fn VkResult(
  VkDevice device, 
  uint fence_count, 
  VkFence * p_fences);

alias PFN_vkGetFenceStatus = fn VkResult(
  VkDevice device, 
  VkFence fence);

alias PFN_vkWaitForFences = fn VkResult(
  VkDevice device, 
  uint fence_count, 
  VkFence * p_fences, 
  VkBool32 wait_all, 
  ulong timeout);

alias PFN_vkCreateSemaphore = fn VkResult(
  VkDevice device, 
  VkSemaphoreCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkSemaphore * p_semaphore);

alias PFN_vkDestroySemaphore = fn void(
  VkDevice device, 
  VkSemaphore semaphore, 
  VkAllocationCallbacks * p_allocator);

alias PFN_vkCreateEvent = fn VkResult(
  VkDevice device, 
  VkEventCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkEvent * p_event);

alias PFN_vkDestroyEvent = fn void(
  VkDevice device, 
  VkEvent event, 
  VkAllocationCallbacks * p_allocator);

alias PFN_vkGetEventStatus = fn VkResult(
  VkDevice device, 
  VkEvent event);

alias PFN_vkSetEvent = fn VkResult(
  VkDevice device, 
  VkEvent event);

alias PFN_vkResetEvent = fn VkResult(
  VkDevice device, 
  VkEvent event);

alias PFN_vkCreateQueryPool = fn VkResult(
  VkDevice device, 
  VkQueryPoolCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkQueryPool * p_query_pool);

alias PFN_vkDestroyQueryPool = fn void(
  VkDevice device, 
  VkQueryPool query_pool, 
  VkAllocationCallbacks * p_allocator);

alias PFN_vkGetQueryPoolResults = fn VkResult(
  VkDevice device, 
  VkQueryPool query_pool, 
  uint first_query, 
  uint query_count, 
  usz data_size, 
  void * p_data, 
  VkDeviceSize stride, 
  VkQueryResultFlags flags);

alias PFN_vkCreateBuffer = fn VkResult(
  VkDevice device, 
  VkBufferCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkBuffer * p_buffer);

alias PFN_vkDestroyBuffer = fn void(
  VkDevice device, 
  VkBuffer buffer, 
  VkAllocationCallbacks * p_allocator);

alias PFN_vkCreateBufferView = fn VkResult(
  VkDevice device, 
  VkBufferViewCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkBufferView * p_view);

alias PFN_vkDestroyBufferView = fn void(
  VkDevice device, 
  VkBufferView buffer_view, 
  VkAllocationCallbacks * p_allocator);

alias PFN_vkCreateImage = fn VkResult(
  VkDevice device, 
  VkImageCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkImage * p_image);

alias PFN_vkDestroyImage = fn void(
  VkDevice device, 
  VkImage image, 
  VkAllocationCallbacks * p_allocator);

alias PFN_vkGetImageSubresourceLayout = fn void(
  VkDevice device, 
  VkImage image, 
  VkImageSubresource * p_subresource, 
  VkSubresourceLayout * p_layout);

alias PFN_vkCreateImageView = fn VkResult(
  VkDevice device, 
  VkImageViewCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkImageView * p_view);

alias PFN_vkDestroyImageView = fn void(
  VkDevice device, 
  VkImageView image_view, 
  VkAllocationCallbacks * p_allocator);

alias PFN_vkCreateShaderModule = fn VkResult(
  VkDevice device, 
  VkShaderModuleCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkShaderModule * p_shader_module);

alias PFN_vkDestroyShaderModule = fn void(
  VkDevice device, 
  VkShaderModule shader_module, 
  VkAllocationCallbacks * p_allocator);

alias PFN_vkCreatePipelineCache = fn VkResult(
  VkDevice device, 
  VkPipelineCacheCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkPipelineCache * p_pipeline_cache);

alias PFN_vkDestroyPipelineCache = fn void(
  VkDevice device, 
  VkPipelineCache pipeline_cache, 
  VkAllocationCallbacks * p_allocator);

alias PFN_vkGetPipelineCacheData = fn VkResult(
  VkDevice device, 
  VkPipelineCache pipeline_cache, 
  usz * p_data_size, 
  void * p_data);

alias PFN_vkMergePipelineCaches = fn VkResult(
  VkDevice device, 
  VkPipelineCache dst_cache, 
  uint src_cache_count, 
  VkPipelineCache * p_src_caches);

alias PFN_vkCreateGraphicsPipelines = fn VkResult(
  VkDevice device, 
  VkPipelineCache pipeline_cache, 
  uint create_info_count, 
  VkGraphicsPipelineCreateInfo * p_create_infos, 
  VkAllocationCallbacks * p_allocator, 
  VkPipeline * p_pipelines);

alias PFN_vkCreateComputePipelines = fn VkResult(
  VkDevice device, 
  VkPipelineCache pipeline_cache, 
  uint create_info_count, 
  VkComputePipelineCreateInfo * p_create_infos, 
  VkAllocationCallbacks * p_allocator, 
  VkPipeline * p_pipelines);

alias PFN_vkDestroyPipeline = fn void(
  VkDevice device, 
  VkPipeline pipeline, 
  VkAllocationCallbacks * p_allocator);

alias PFN_vkCreatePipelineLayout = fn VkResult(
  VkDevice device, 
  VkPipelineLayoutCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkPipelineLayout * p_pipeline_layout);

alias PFN_vkDestroyPipelineLayout = fn void(
  VkDevice device, 
  VkPipelineLayout pipeline_layout, 
  VkAllocationCallbacks * p_allocator);

alias PFN_vkCreateSampler = fn VkResult(
  VkDevice device, 
  VkSamplerCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkSampler * p_sampler);

alias PFN_vkDestroySampler = fn void(
  VkDevice device, 
  VkSampler sampler, 
  VkAllocationCallbacks * p_allocator);

alias PFN_vkCreateDescriptorSetLayout = fn VkResult(
  VkDevice device, 
  VkDescriptorSetLayoutCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkDescriptorSetLayout * p_set_layout);

alias PFN_vkDestroyDescriptorSetLayout = fn void(
  VkDevice device, 
  VkDescriptorSetLayout descriptor_set_layout, 
  VkAllocationCallbacks * p_allocator);

alias PFN_vkCreateDescriptorPool = fn VkResult(
  VkDevice device, 
  VkDescriptorPoolCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkDescriptorPool * p_descriptor_pool);

alias PFN_vkDestroyDescriptorPool = fn void(
  VkDevice device, 
  VkDescriptorPool descriptor_pool, 
  VkAllocationCallbacks * p_allocator);

alias PFN_vkResetDescriptorPool = fn VkResult(
  VkDevice device, 
  VkDescriptorPool descriptor_pool, 
  VkDescriptorPoolResetFlags flags);

alias PFN_vkAllocateDescriptorSets = fn VkResult(
  VkDevice device, 
  VkDescriptorSetAllocateInfo * p_allocate_info, 
  VkDescriptorSet * p_descriptor_sets);

alias PFN_vkFreeDescriptorSets = fn VkResult(
  VkDevice device, 
  VkDescriptorPool descriptor_pool, 
  uint descriptor_set_count, 
  VkDescriptorSet * p_descriptor_sets);

alias PFN_vkUpdateDescriptorSets = fn void(
  VkDevice device, 
  uint descriptor_write_count, 
  VkWriteDescriptorSet * p_descriptor_writes, 
  uint descriptor_copy_count, 
  VkCopyDescriptorSet * p_descriptor_copies);

alias PFN_vkCreateFramebuffer = fn VkResult(
  VkDevice device, 
  VkFramebufferCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkFramebuffer * p_framebuffer);

alias PFN_vkDestroyFramebuffer = fn void(
  VkDevice device, 
  VkFramebuffer framebuffer, 
  VkAllocationCallbacks * p_allocator);

alias PFN_vkCreateRenderPass = fn VkResult(
  VkDevice device, 
  VkRenderPassCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkRenderPass * p_render_pass);

alias PFN_vkDestroyRenderPass = fn void(
  VkDevice device, 
  VkRenderPass render_pass, 
  VkAllocationCallbacks * p_allocator);

alias PFN_vkGetRenderAreaGranularity = fn void(
  VkDevice device, 
  VkRenderPass render_pass, 
  VkExtent2D * p_granularity);

alias PFN_vkCreateCommandPool = fn VkResult(
  VkDevice device, 
  VkCommandPoolCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkCommandPool * p_command_pool);

alias PFN_vkDestroyCommandPool = fn void(
  VkDevice device, 
  VkCommandPool command_pool, 
  VkAllocationCallbacks * p_allocator);

alias PFN_vkResetCommandPool = fn VkResult(
  VkDevice device, 
  VkCommandPool command_pool, 
  VkCommandPoolResetFlags flags);

alias PFN_vkAllocateCommandBuffers = fn VkResult(
  VkDevice device, 
  VkCommandBufferAllocateInfo * p_allocate_info, 
  VkCommandBuffer * p_command_buffers);

alias PFN_vkFreeCommandBuffers = fn void(
  VkDevice device, 
  VkCommandPool command_pool, 
  uint command_buffer_count, 
  VkCommandBuffer * p_command_buffers);

alias PFN_vkBeginCommandBuffer = fn VkResult(
  VkCommandBuffer command_buffer, 
  VkCommandBufferBeginInfo * p_begin_info);

alias PFN_vkEndCommandBuffer = fn VkResult(  VkCommandBuffer command_buffer);

alias PFN_vkResetCommandBuffer = fn VkResult(
  VkCommandBuffer command_buffer, 
  VkCommandBufferResetFlags flags);

alias PFN_vkCmdBindPipeline = fn void(
  VkCommandBuffer command_buffer, 
  VkPipelineBindPoint pipeline_bind_point, 
  VkPipeline pipeline);

alias PFN_vkCmdSetViewport = fn void(
  VkCommandBuffer command_buffer, 
  uint first_viewport, 
  uint viewport_count, 
  VkViewport * p_viewports);

alias PFN_vkCmdSetScissor = fn void(
  VkCommandBuffer command_buffer, 
  uint first_scissor, 
  uint scissor_count, 
  VkRect2D * p_scissors);

alias PFN_vkCmdSetLineWidth = fn void(
  VkCommandBuffer command_buffer, 
  float line_width);

alias PFN_vkCmdSetDepthBias = fn void(
  VkCommandBuffer command_buffer, 
  float depth_bias_constant_factor, 
  float depth_bias_clamp, 
  float depth_bias_slope_factor);

alias PFN_vkCmdSetBlendConstants = fn void(
  VkCommandBuffer command_buffer, 
  float[4] blend_constants);

alias PFN_vkCmdSetDepthBounds = fn void(
  VkCommandBuffer command_buffer, 
  float min_depth_bounds, 
  float max_depth_bounds);

alias PFN_vkCmdSetStencilCompareMask = fn void(
  VkCommandBuffer command_buffer, 
  VkStencilFaceFlags face_mask, 
  uint compare_mask);

alias PFN_vkCmdSetStencilWriteMask = fn void(
  VkCommandBuffer command_buffer, 
  VkStencilFaceFlags face_mask, 
  uint write_mask);

alias PFN_vkCmdSetStencilReference = fn void(
  VkCommandBuffer command_buffer, 
  VkStencilFaceFlags face_mask, 
  uint reference);

alias PFN_vkCmdBindDescriptorSets = fn void(
  VkCommandBuffer command_buffer, 
  VkPipelineBindPoint pipeline_bind_point, 
  VkPipelineLayout layout, 
  uint first_set, 
  uint descriptor_set_count, 
  VkDescriptorSet * p_descriptor_sets, 
  uint dynamic_offset_count, 
  uint * p_dynamic_offsets);

alias PFN_vkCmdBindIndexBuffer = fn void(
  VkCommandBuffer command_buffer, 
  VkBuffer buffer, 
  VkDeviceSize offset, 
  VkIndexType index_type);

alias PFN_vkCmdBindVertexBuffers = fn void(
  VkCommandBuffer command_buffer, 
  uint first_binding, 
  uint binding_count, 
  VkBuffer * p_buffers, 
  VkDeviceSize * p_offsets);

alias PFN_vkCmdDraw = fn void(
  VkCommandBuffer command_buffer, 
  uint vertex_count, 
  uint instance_count, 
  uint first_vertex, 
  uint first_instance);

alias PFN_vkCmdDrawIndexed = fn void(
  VkCommandBuffer command_buffer, 
  uint index_count, 
  uint instance_count, 
  uint first_index, 
  int vertex_offset, 
  uint first_instance);

alias PFN_vkCmdDrawIndirect = fn void(
  VkCommandBuffer command_buffer, 
  VkBuffer buffer, 
  VkDeviceSize offset, 
  uint draw_count, 
  uint stride);

alias PFN_vkCmdDrawIndexedIndirect = fn void(
  VkCommandBuffer command_buffer, 
  VkBuffer buffer, 
  VkDeviceSize offset, 
  uint draw_count, 
  uint stride);

alias PFN_vkCmdDispatch = fn void(
  VkCommandBuffer command_buffer, 
  uint group_count_x, 
  uint group_count_y, 
  uint group_count_z);

alias PFN_vkCmdDispatchIndirect = fn void(
  VkCommandBuffer command_buffer, 
  VkBuffer buffer, 
  VkDeviceSize offset);

alias PFN_vkCmdCopyBuffer = fn void(
  VkCommandBuffer command_buffer, 
  VkBuffer src_buffer, 
  VkBuffer dst_buffer, 
  uint region_count, 
  VkBufferCopy * p_regions);

alias PFN_vkCmdCopyImage = fn void(
  VkCommandBuffer command_buffer, 
  VkImage src_image, 
  VkImageLayout src_image_layout, 
  VkImage dst_image, 
  VkImageLayout dst_image_layout, 
  uint region_count, 
  VkImageCopy * p_regions);

alias PFN_vkCmdBlitImage = fn void(
  VkCommandBuffer command_buffer, 
  VkImage src_image, 
  VkImageLayout src_image_layout, 
  VkImage dst_image, 
  VkImageLayout dst_image_layout, 
  uint region_count, 
  VkImageBlit * p_regions, 
  VkFilter filter);

alias PFN_vkCmdCopyBufferToImage = fn void(
  VkCommandBuffer command_buffer, 
  VkBuffer src_buffer, 
  VkImage dst_image, 
  VkImageLayout dst_image_layout, 
  uint region_count, 
  VkBufferImageCopy * p_regions);

alias PFN_vkCmdCopyImageToBuffer = fn void(
  VkCommandBuffer command_buffer, 
  VkImage src_image, 
  VkImageLayout src_image_layout, 
  VkBuffer dst_buffer, 
  uint region_count, 
  VkBufferImageCopy * p_regions);

alias PFN_vkCmdUpdateBuffer = fn void(
  VkCommandBuffer command_buffer, 
  VkBuffer dst_buffer, 
  VkDeviceSize dst_offset, 
  VkDeviceSize data_size, 
  void * p_data);

alias PFN_vkCmdFillBuffer = fn void(
  VkCommandBuffer command_buffer, 
  VkBuffer dst_buffer, 
  VkDeviceSize dst_offset, 
  VkDeviceSize size, 
  uint data);

alias PFN_vkCmdClearColorImage = fn void(
  VkCommandBuffer command_buffer, 
  VkImage image, 
  VkImageLayout image_layout, 
  VkClearColorValue * p_color, 
  uint range_count, 
  VkImageSubresourceRange * p_ranges);

alias PFN_vkCmdClearDepthStencilImage = fn void(
  VkCommandBuffer command_buffer, 
  VkImage image, 
  VkImageLayout image_layout, 
  VkClearDepthStencilValue * p_depth_stencil, 
  uint range_count, 
  VkImageSubresourceRange * p_ranges);

alias PFN_vkCmdClearAttachments = fn void(
  VkCommandBuffer command_buffer, 
  uint attachment_count, 
  VkClearAttachment * p_attachments, 
  uint rect_count, 
  VkClearRect * p_rects);

alias PFN_vkCmdResolveImage = fn void(
  VkCommandBuffer command_buffer, 
  VkImage src_image, 
  VkImageLayout src_image_layout, 
  VkImage dst_image, 
  VkImageLayout dst_image_layout, 
  uint region_count, 
  VkImageResolve * p_regions);

alias PFN_vkCmdSetEvent = fn void(
  VkCommandBuffer command_buffer, 
  VkEvent event, 
  VkPipelineStageFlags stage_mask);

alias PFN_vkCmdResetEvent = fn void(
  VkCommandBuffer command_buffer, 
  VkEvent event, 
  VkPipelineStageFlags stage_mask);

alias PFN_vkCmdWaitEvents = fn void(
  VkCommandBuffer command_buffer, 
  uint event_count, 
  VkEvent * p_events, 
  VkPipelineStageFlags src_stage_mask, 
  VkPipelineStageFlags dst_stage_mask, 
  uint memory_barrier_count, 
  VkMemoryBarrier * p_memory_barriers, 
  uint buffer_memory_barrier_count, 
  VkBufferMemoryBarrier * p_buffer_memory_barriers, 
  uint image_memory_barrier_count, 
  VkImageMemoryBarrier * p_image_memory_barriers);

alias PFN_vkCmdPipelineBarrier = fn void(
  VkCommandBuffer command_buffer, 
  VkPipelineStageFlags src_stage_mask, 
  VkPipelineStageFlags dst_stage_mask, 
  VkDependencyFlags dependency_flags, 
  uint memory_barrier_count, 
  VkMemoryBarrier * p_memory_barriers, 
  uint buffer_memory_barrier_count, 
  VkBufferMemoryBarrier * p_buffer_memory_barriers, 
  uint image_memory_barrier_count, 
  VkImageMemoryBarrier * p_image_memory_barriers);

alias PFN_vkCmdBeginQuery = fn void(
  VkCommandBuffer command_buffer, 
  VkQueryPool query_pool, 
  uint query, 
  VkQueryControlFlags flags);

alias PFN_vkCmdEndQuery = fn void(
  VkCommandBuffer command_buffer, 
  VkQueryPool query_pool, 
  uint query);

alias PFN_vkCmdResetQueryPool = fn void(
  VkCommandBuffer command_buffer, 
  VkQueryPool query_pool, 
  uint first_query, 
  uint query_count);

alias PFN_vkCmdWriteTimestamp = fn void(
  VkCommandBuffer command_buffer, 
  VkPipelineStageFlagBits pipeline_stage, 
  VkQueryPool query_pool, 
  uint query);

alias PFN_vkCmdCopyQueryPoolResults = fn void(
  VkCommandBuffer command_buffer, 
  VkQueryPool query_pool, 
  uint first_query, 
  uint query_count, 
  VkBuffer dst_buffer, 
  VkDeviceSize dst_offset, 
  VkDeviceSize stride, 
  VkQueryResultFlags flags);

alias PFN_vkCmdPushConstants = fn void(
  VkCommandBuffer command_buffer, 
  VkPipelineLayout layout, 
  VkShaderStageFlags stage_flags, 
  uint offset, 
  uint size, 
  void * p_values);

alias PFN_vkCmdBeginRenderPass = fn void(
  VkCommandBuffer command_buffer, 
  VkRenderPassBeginInfo * p_render_pass_begin, 
  VkSubpassContents contents);

alias PFN_vkCmdNextSubpass = fn void(
  VkCommandBuffer command_buffer, 
  VkSubpassContents contents);

alias PFN_vkCmdEndRenderPass = fn void(  VkCommandBuffer command_buffer);

alias PFN_vkCmdExecuteCommands = fn void(
  VkCommandBuffer command_buffer, 
  uint command_buffer_count, 
  VkCommandBuffer * p_command_buffers);

fn VkResult create_instance(
  VkInstanceCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkInstance * p_instance)
@extern("vkCreateInstance");

fn void destroy_instance(
  VkInstance instance, 
  VkAllocationCallbacks * p_allocator)
@extern("vkDestroyInstance");

fn VkResult enumerate_physical_devices(
  VkInstance instance, 
  uint * p_physical_device_count, 
  VkPhysicalDevice * p_physical_devices)
@extern("vkEnumeratePhysicalDevices");

fn void get_physical_device_features(
  VkPhysicalDevice physical_device, 
  VkPhysicalDeviceFeatures * p_features)
@extern("vkGetPhysicalDeviceFeatures");

fn void get_physical_device_format_properties(
  VkPhysicalDevice physical_device, 
  VkFormat format, 
  VkFormatProperties * p_format_properties)
@extern("vkGetPhysicalDeviceFormatProperties");

fn VkResult get_physical_device_image_format_properties(
  VkPhysicalDevice physical_device, 
  VkFormat format, 
  VkImageType type, 
  VkImageTiling tiling, 
  VkImageUsageFlags usage, 
  VkImageCreateFlags flags, 
  VkImageFormatProperties * p_image_format_properties)
@extern("vkGetPhysicalDeviceImageFormatProperties");

fn void get_physical_device_properties(
  VkPhysicalDevice physical_device, 
  VkPhysicalDeviceProperties * p_properties)
@extern("vkGetPhysicalDeviceProperties");

fn void get_physical_device_queue_family_properties(
  VkPhysicalDevice physical_device, 
  uint * p_queue_family_property_count, 
  VkQueueFamilyProperties * p_queue_family_properties)
@extern("vkGetPhysicalDeviceQueueFamilyProperties");

fn void get_physical_device_memory_properties(
  VkPhysicalDevice physical_device, 
  VkPhysicalDeviceMemoryProperties * p_memory_properties)
@extern("vkGetPhysicalDeviceMemoryProperties");

fn PFN_vkVoidFunction get_instance_proc_addr(
  VkInstance instance, 
  CChar * p_name)
@extern("vkGetInstanceProcAddr");

fn PFN_vkVoidFunction get_device_proc_addr(
  VkDevice device, 
  CChar * p_name)
@extern("vkGetDeviceProcAddr");

fn VkResult create_device(
  VkPhysicalDevice physical_device, 
  VkDeviceCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkDevice * p_device)
@extern("vkCreateDevice");

fn void destroy_device(
  VkDevice device, 
  VkAllocationCallbacks * p_allocator)
@extern("vkDestroyDevice");

fn VkResult enumerate_instance_extension_properties(
  CChar * p_layer_name, 
  uint * p_property_count, 
  VkExtensionProperties * p_properties)
@extern("vkEnumerateInstanceExtensionProperties");

fn VkResult enumerate_device_extension_properties(
  VkPhysicalDevice physical_device, 
  CChar * p_layer_name, 
  uint * p_property_count, 
  VkExtensionProperties * p_properties)
@extern("vkEnumerateDeviceExtensionProperties");

fn VkResult enumerate_instance_layer_properties(
  uint * p_property_count, 
  VkLayerProperties * p_properties)
@extern("vkEnumerateInstanceLayerProperties");

fn VkResult enumerate_device_layer_properties(
  VkPhysicalDevice physical_device, 
  uint * p_property_count, 
  VkLayerProperties * p_properties)
@extern("vkEnumerateDeviceLayerProperties");

fn void get_device_queue(
  VkDevice device, 
  uint queue_family_index, 
  uint queue_index, 
  VkQueue * p_queue)
@extern("vkGetDeviceQueue");

fn VkResult queue_submit(
  VkQueue queue, 
  uint submit_count, 
  VkSubmitInfo * p_submits, 
  VkFence fence)
@extern("vkQueueSubmit");

fn VkResult queue_wait_idle(
  VkQueue queue)
@extern("vkQueueWaitIdle");

fn VkResult device_wait_idle(
  VkDevice device)
@extern("vkDeviceWaitIdle");

fn VkResult allocate_memory(
  VkDevice device, 
  VkMemoryAllocateInfo * p_allocate_info, 
  VkAllocationCallbacks * p_allocator, 
  VkDeviceMemory * p_memory)
@extern("vkAllocateMemory");

fn void free_memory(
  VkDevice device, 
  VkDeviceMemory memory, 
  VkAllocationCallbacks * p_allocator)
@extern("vkFreeMemory");

fn VkResult map_memory(
  VkDevice device, 
  VkDeviceMemory memory, 
  VkDeviceSize offset, 
  VkDeviceSize size, 
  VkMemoryMapFlags flags, 
  void ** pp_data)
@extern("vkMapMemory");

fn void unmap_memory(
  VkDevice device, 
  VkDeviceMemory memory)
@extern("vkUnmapMemory");

fn VkResult flush_mapped_memory_ranges(
  VkDevice device, 
  uint memory_range_count, 
  VkMappedMemoryRange * p_memory_ranges)
@extern("vkFlushMappedMemoryRanges");

fn VkResult invalidate_mapped_memory_ranges(
  VkDevice device, 
  uint memory_range_count, 
  VkMappedMemoryRange * p_memory_ranges)
@extern("vkInvalidateMappedMemoryRanges");

fn void get_device_memory_commitment(
  VkDevice device, 
  VkDeviceMemory memory, 
  VkDeviceSize * p_committed_memory_in_bytes)
@extern("vkGetDeviceMemoryCommitment");

fn VkResult bind_buffer_memory(
  VkDevice device, 
  VkBuffer buffer, 
  VkDeviceMemory memory, 
  VkDeviceSize memory_offset)
@extern("vkBindBufferMemory");

fn VkResult bind_image_memory(
  VkDevice device, 
  VkImage image, 
  VkDeviceMemory memory, 
  VkDeviceSize memory_offset)
@extern("vkBindImageMemory");

fn void get_buffer_memory_requirements(
  VkDevice device, 
  VkBuffer buffer, 
  VkMemoryRequirements * p_memory_requirements)
@extern("vkGetBufferMemoryRequirements");

fn void get_image_memory_requirements(
  VkDevice device, 
  VkImage image, 
  VkMemoryRequirements * p_memory_requirements)
@extern("vkGetImageMemoryRequirements");

fn void get_image_sparse_memory_requirements(
  VkDevice device, 
  VkImage image, 
  uint * p_sparse_memory_requirement_count, 
  VkSparseImageMemoryRequirements * p_sparse_memory_requirements)
@extern("vkGetImageSparseMemoryRequirements");

fn void get_physical_device_sparse_image_format_properties(
  VkPhysicalDevice physical_device, 
  VkFormat format, 
  VkImageType type, 
  VkSampleCountFlagBits samples, 
  VkImageUsageFlags usage, 
  VkImageTiling tiling, 
  uint * p_property_count, 
  VkSparseImageFormatProperties * p_properties)
@extern("vkGetPhysicalDeviceSparseImageFormatProperties");

fn VkResult queue_bind_sparse(
  VkQueue queue, 
  uint bind_info_count, 
  VkBindSparseInfo * p_bind_info, 
  VkFence fence)
@extern("vkQueueBindSparse");

fn VkResult create_fence(
  VkDevice device, 
  VkFenceCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkFence * p_fence)
@extern("vkCreateFence");

fn void destroy_fence(
  VkDevice device, 
  VkFence fence, 
  VkAllocationCallbacks * p_allocator)
@extern("vkDestroyFence");

fn VkResult reset_fences(
  VkDevice device, 
  uint fence_count, 
  VkFence * p_fences)
@extern("vkResetFences");

fn VkResult get_fence_status(
  VkDevice device, 
  VkFence fence)
@extern("vkGetFenceStatus");

fn VkResult wait_for_fences(
  VkDevice device, 
  uint fence_count, 
  VkFence * p_fences, 
  VkBool32 wait_all, 
  ulong timeout)
@extern("vkWaitForFences");

fn VkResult create_semaphore(
  VkDevice device, 
  VkSemaphoreCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkSemaphore * p_semaphore)
@extern("vkCreateSemaphore");

fn void destroy_semaphore(
  VkDevice device, 
  VkSemaphore semaphore, 
  VkAllocationCallbacks * p_allocator)
@extern("vkDestroySemaphore");

fn VkResult create_event(
  VkDevice device, 
  VkEventCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkEvent * p_event)
@extern("vkCreateEvent");

fn void destroy_event(
  VkDevice device, 
  VkEvent event, 
  VkAllocationCallbacks * p_allocator)
@extern("vkDestroyEvent");

fn VkResult get_event_status(
  VkDevice device, 
  VkEvent event)
@extern("vkGetEventStatus");

fn VkResult set_event(
  VkDevice device, 
  VkEvent event)
@extern("vkSetEvent");

fn VkResult reset_event(
  VkDevice device, 
  VkEvent event)
@extern("vkResetEvent");

fn VkResult create_query_pool(
  VkDevice device, 
  VkQueryPoolCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkQueryPool * p_query_pool)
@extern("vkCreateQueryPool");

fn void destroy_query_pool(
  VkDevice device, 
  VkQueryPool query_pool, 
  VkAllocationCallbacks * p_allocator)
@extern("vkDestroyQueryPool");

fn VkResult get_query_pool_results(
  VkDevice device, 
  VkQueryPool query_pool, 
  uint first_query, 
  uint query_count, 
  usz data_size, 
  void * p_data, 
  VkDeviceSize stride, 
  VkQueryResultFlags flags)
@extern("vkGetQueryPoolResults");

fn VkResult create_buffer(
  VkDevice device, 
  VkBufferCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkBuffer * p_buffer)
@extern("vkCreateBuffer");

fn void destroy_buffer(
  VkDevice device, 
  VkBuffer buffer, 
  VkAllocationCallbacks * p_allocator)
@extern("vkDestroyBuffer");

fn VkResult create_buffer_view(
  VkDevice device, 
  VkBufferViewCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkBufferView * p_view)
@extern("vkCreateBufferView");

fn void destroy_buffer_view(
  VkDevice device, 
  VkBufferView buffer_view, 
  VkAllocationCallbacks * p_allocator)
@extern("vkDestroyBufferView");

fn VkResult create_image(
  VkDevice device, 
  VkImageCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkImage * p_image)
@extern("vkCreateImage");

fn void destroy_image(
  VkDevice device, 
  VkImage image, 
  VkAllocationCallbacks * p_allocator)
@extern("vkDestroyImage");

fn void get_image_subresource_layout(
  VkDevice device, 
  VkImage image, 
  VkImageSubresource * p_subresource, 
  VkSubresourceLayout * p_layout)
@extern("vkGetImageSubresourceLayout");

fn VkResult create_image_view(
  VkDevice device, 
  VkImageViewCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkImageView * p_view)
@extern("vkCreateImageView");

fn void destroy_image_view(
  VkDevice device, 
  VkImageView image_view, 
  VkAllocationCallbacks * p_allocator)
@extern("vkDestroyImageView");

fn VkResult create_shader_module(
  VkDevice device, 
  VkShaderModuleCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkShaderModule * p_shader_module)
@extern("vkCreateShaderModule");

fn void destroy_shader_module(
  VkDevice device, 
  VkShaderModule shader_module, 
  VkAllocationCallbacks * p_allocator)
@extern("vkDestroyShaderModule");

fn VkResult create_pipeline_cache(
  VkDevice device, 
  VkPipelineCacheCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkPipelineCache * p_pipeline_cache)
@extern("vkCreatePipelineCache");

fn void destroy_pipeline_cache(
  VkDevice device, 
  VkPipelineCache pipeline_cache, 
  VkAllocationCallbacks * p_allocator)
@extern("vkDestroyPipelineCache");

fn VkResult get_pipeline_cache_data(
  VkDevice device, 
  VkPipelineCache pipeline_cache, 
  usz * p_data_size, 
  void * p_data)
@extern("vkGetPipelineCacheData");

fn VkResult merge_pipeline_caches(
  VkDevice device, 
  VkPipelineCache dst_cache, 
  uint src_cache_count, 
  VkPipelineCache * p_src_caches)
@extern("vkMergePipelineCaches");

fn VkResult create_graphics_pipelines(
  VkDevice device, 
  VkPipelineCache pipeline_cache, 
  uint create_info_count, 
  VkGraphicsPipelineCreateInfo * p_create_infos, 
  VkAllocationCallbacks * p_allocator, 
  VkPipeline * p_pipelines)
@extern("vkCreateGraphicsPipelines");

fn VkResult create_compute_pipelines(
  VkDevice device, 
  VkPipelineCache pipeline_cache, 
  uint create_info_count, 
  VkComputePipelineCreateInfo * p_create_infos, 
  VkAllocationCallbacks * p_allocator, 
  VkPipeline * p_pipelines)
@extern("vkCreateComputePipelines");

fn void destroy_pipeline(
  VkDevice device, 
  VkPipeline pipeline, 
  VkAllocationCallbacks * p_allocator)
@extern("vkDestroyPipeline");

fn VkResult create_pipeline_layout(
  VkDevice device, 
  VkPipelineLayoutCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkPipelineLayout * p_pipeline_layout)
@extern("vkCreatePipelineLayout");

fn void destroy_pipeline_layout(
  VkDevice device, 
  VkPipelineLayout pipeline_layout, 
  VkAllocationCallbacks * p_allocator)
@extern("vkDestroyPipelineLayout");

fn VkResult create_sampler(
  VkDevice device, 
  VkSamplerCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkSampler * p_sampler)
@extern("vkCreateSampler");

fn void destroy_sampler(
  VkDevice device, 
  VkSampler sampler, 
  VkAllocationCallbacks * p_allocator)
@extern("vkDestroySampler");

fn VkResult create_descriptor_set_layout(
  VkDevice device, 
  VkDescriptorSetLayoutCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkDescriptorSetLayout * p_set_layout)
@extern("vkCreateDescriptorSetLayout");

fn void destroy_descriptor_set_layout(
  VkDevice device, 
  VkDescriptorSetLayout descriptor_set_layout, 
  VkAllocationCallbacks * p_allocator)
@extern("vkDestroyDescriptorSetLayout");

fn VkResult create_descriptor_pool(
  VkDevice device, 
  VkDescriptorPoolCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkDescriptorPool * p_descriptor_pool)
@extern("vkCreateDescriptorPool");

fn void destroy_descriptor_pool(
  VkDevice device, 
  VkDescriptorPool descriptor_pool, 
  VkAllocationCallbacks * p_allocator)
@extern("vkDestroyDescriptorPool");

fn VkResult reset_descriptor_pool(
  VkDevice device, 
  VkDescriptorPool descriptor_pool, 
  VkDescriptorPoolResetFlags flags)
@extern("vkResetDescriptorPool");

fn VkResult allocate_descriptor_sets(
  VkDevice device, 
  VkDescriptorSetAllocateInfo * p_allocate_info, 
  VkDescriptorSet * p_descriptor_sets)
@extern("vkAllocateDescriptorSets");

fn VkResult free_descriptor_sets(
  VkDevice device, 
  VkDescriptorPool descriptor_pool, 
  uint descriptor_set_count, 
  VkDescriptorSet * p_descriptor_sets)
@extern("vkFreeDescriptorSets");

fn void update_descriptor_sets(
  VkDevice device, 
  uint descriptor_write_count, 
  VkWriteDescriptorSet * p_descriptor_writes, 
  uint descriptor_copy_count, 
  VkCopyDescriptorSet * p_descriptor_copies)
@extern("vkUpdateDescriptorSets");

fn VkResult create_framebuffer(
  VkDevice device, 
  VkFramebufferCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkFramebuffer * p_framebuffer)
@extern("vkCreateFramebuffer");

fn void destroy_framebuffer(
  VkDevice device, 
  VkFramebuffer framebuffer, 
  VkAllocationCallbacks * p_allocator)
@extern("vkDestroyFramebuffer");

fn VkResult create_render_pass(
  VkDevice device, 
  VkRenderPassCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkRenderPass * p_render_pass)
@extern("vkCreateRenderPass");

fn void destroy_render_pass(
  VkDevice device, 
  VkRenderPass render_pass, 
  VkAllocationCallbacks * p_allocator)
@extern("vkDestroyRenderPass");

fn void get_render_area_granularity(
  VkDevice device, 
  VkRenderPass render_pass, 
  VkExtent2D * p_granularity)
@extern("vkGetRenderAreaGranularity");

fn VkResult create_command_pool(
  VkDevice device, 
  VkCommandPoolCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkCommandPool * p_command_pool)
@extern("vkCreateCommandPool");

fn void destroy_command_pool(
  VkDevice device, 
  VkCommandPool command_pool, 
  VkAllocationCallbacks * p_allocator)
@extern("vkDestroyCommandPool");

fn VkResult reset_command_pool(
  VkDevice device, 
  VkCommandPool command_pool, 
  VkCommandPoolResetFlags flags)
@extern("vkResetCommandPool");

fn VkResult allocate_command_buffers(
  VkDevice device, 
  VkCommandBufferAllocateInfo * p_allocate_info, 
  VkCommandBuffer * p_command_buffers)
@extern("vkAllocateCommandBuffers");

fn void free_command_buffers(
  VkDevice device, 
  VkCommandPool command_pool, 
  uint command_buffer_count, 
  VkCommandBuffer * p_command_buffers)
@extern("vkFreeCommandBuffers");

fn VkResult begin_command_buffer(
  VkCommandBuffer command_buffer, 
  VkCommandBufferBeginInfo * p_begin_info)
@extern("vkBeginCommandBuffer");

fn VkResult end_command_buffer(
  VkCommandBuffer command_buffer)
@extern("vkEndCommandBuffer");

fn VkResult reset_command_buffer(
  VkCommandBuffer command_buffer, 
  VkCommandBufferResetFlags flags)
@extern("vkResetCommandBuffer");

fn void cmd_bind_pipeline(
  VkCommandBuffer command_buffer, 
  VkPipelineBindPoint pipeline_bind_point, 
  VkPipeline pipeline)
@extern("vkCmdBindPipeline");

fn void cmd_set_viewport(
  VkCommandBuffer command_buffer, 
  uint first_viewport, 
  uint viewport_count, 
  VkViewport * p_viewports)
@extern("vkCmdSetViewport");

fn void cmd_set_scissor(
  VkCommandBuffer command_buffer, 
  uint first_scissor, 
  uint scissor_count, 
  VkRect2D * p_scissors)
@extern("vkCmdSetScissor");

fn void cmd_set_line_width(
  VkCommandBuffer command_buffer, 
  float line_width)
@extern("vkCmdSetLineWidth");

fn void cmd_set_depth_bias(
  VkCommandBuffer command_buffer, 
  float depth_bias_constant_factor, 
  float depth_bias_clamp, 
  float depth_bias_slope_factor)
@extern("vkCmdSetDepthBias");

fn void cmd_set_blend_constants(
  VkCommandBuffer command_buffer, 
  float[4] blend_constants)
@extern("vkCmdSetBlendConstants");

fn void cmd_set_depth_bounds(
  VkCommandBuffer command_buffer, 
  float min_depth_bounds, 
  float max_depth_bounds)
@extern("vkCmdSetDepthBounds");

fn void cmd_set_stencil_compare_mask(
  VkCommandBuffer command_buffer, 
  VkStencilFaceFlags face_mask, 
  uint compare_mask)
@extern("vkCmdSetStencilCompareMask");

fn void cmd_set_stencil_write_mask(
  VkCommandBuffer command_buffer, 
  VkStencilFaceFlags face_mask, 
  uint write_mask)
@extern("vkCmdSetStencilWriteMask");

fn void cmd_set_stencil_reference(
  VkCommandBuffer command_buffer, 
  VkStencilFaceFlags face_mask, 
  uint reference)
@extern("vkCmdSetStencilReference");

fn void cmd_bind_descriptor_sets(
  VkCommandBuffer command_buffer, 
  VkPipelineBindPoint pipeline_bind_point, 
  VkPipelineLayout layout, 
  uint first_set, 
  uint descriptor_set_count, 
  VkDescriptorSet * p_descriptor_sets, 
  uint dynamic_offset_count, 
  uint * p_dynamic_offsets)
@extern("vkCmdBindDescriptorSets");

fn void cmd_bind_index_buffer(
  VkCommandBuffer command_buffer, 
  VkBuffer buffer, 
  VkDeviceSize offset, 
  VkIndexType index_type)
@extern("vkCmdBindIndexBuffer");

fn void cmd_bind_vertex_buffers(
  VkCommandBuffer command_buffer, 
  uint first_binding, 
  uint binding_count, 
  VkBuffer * p_buffers, 
  VkDeviceSize * p_offsets)
@extern("vkCmdBindVertexBuffers");

fn void cmd_draw(
  VkCommandBuffer command_buffer, 
  uint vertex_count, 
  uint instance_count, 
  uint first_vertex, 
  uint first_instance)
@extern("vkCmdDraw");

fn void cmd_draw_indexed(
  VkCommandBuffer command_buffer, 
  uint index_count, 
  uint instance_count, 
  uint first_index, 
  int vertex_offset, 
  uint first_instance)
@extern("vkCmdDrawIndexed");

fn void cmd_draw_indirect(
  VkCommandBuffer command_buffer, 
  VkBuffer buffer, 
  VkDeviceSize offset, 
  uint draw_count, 
  uint stride)
@extern("vkCmdDrawIndirect");

fn void cmd_draw_indexed_indirect(
  VkCommandBuffer command_buffer, 
  VkBuffer buffer, 
  VkDeviceSize offset, 
  uint draw_count, 
  uint stride)
@extern("vkCmdDrawIndexedIndirect");

fn void cmd_dispatch(
  VkCommandBuffer command_buffer, 
  uint group_count_x, 
  uint group_count_y, 
  uint group_count_z)
@extern("vkCmdDispatch");

fn void cmd_dispatch_indirect(
  VkCommandBuffer command_buffer, 
  VkBuffer buffer, 
  VkDeviceSize offset)
@extern("vkCmdDispatchIndirect");

fn void cmd_copy_buffer(
  VkCommandBuffer command_buffer, 
  VkBuffer src_buffer, 
  VkBuffer dst_buffer, 
  uint region_count, 
  VkBufferCopy * p_regions)
@extern("vkCmdCopyBuffer");

fn void cmd_copy_image(
  VkCommandBuffer command_buffer, 
  VkImage src_image, 
  VkImageLayout src_image_layout, 
  VkImage dst_image, 
  VkImageLayout dst_image_layout, 
  uint region_count, 
  VkImageCopy * p_regions)
@extern("vkCmdCopyImage");

fn void cmd_blit_image(
  VkCommandBuffer command_buffer, 
  VkImage src_image, 
  VkImageLayout src_image_layout, 
  VkImage dst_image, 
  VkImageLayout dst_image_layout, 
  uint region_count, 
  VkImageBlit * p_regions, 
  VkFilter filter)
@extern("vkCmdBlitImage");

fn void cmd_copy_buffer_to_image(
  VkCommandBuffer command_buffer, 
  VkBuffer src_buffer, 
  VkImage dst_image, 
  VkImageLayout dst_image_layout, 
  uint region_count, 
  VkBufferImageCopy * p_regions)
@extern("vkCmdCopyBufferToImage");

fn void cmd_copy_image_to_buffer(
  VkCommandBuffer command_buffer, 
  VkImage src_image, 
  VkImageLayout src_image_layout, 
  VkBuffer dst_buffer, 
  uint region_count, 
  VkBufferImageCopy * p_regions)
@extern("vkCmdCopyImageToBuffer");

fn void cmd_update_buffer(
  VkCommandBuffer command_buffer, 
  VkBuffer dst_buffer, 
  VkDeviceSize dst_offset, 
  VkDeviceSize data_size, 
  void * p_data)
@extern("vkCmdUpdateBuffer");

fn void cmd_fill_buffer(
  VkCommandBuffer command_buffer, 
  VkBuffer dst_buffer, 
  VkDeviceSize dst_offset, 
  VkDeviceSize size, 
  uint data)
@extern("vkCmdFillBuffer");

fn void cmd_clear_color_image(
  VkCommandBuffer command_buffer, 
  VkImage image, 
  VkImageLayout image_layout, 
  VkClearColorValue * p_color, 
  uint range_count, 
  VkImageSubresourceRange * p_ranges)
@extern("vkCmdClearColorImage");

fn void cmd_clear_depth_stencil_image(
  VkCommandBuffer command_buffer, 
  VkImage image, 
  VkImageLayout image_layout, 
  VkClearDepthStencilValue * p_depth_stencil, 
  uint range_count, 
  VkImageSubresourceRange * p_ranges)
@extern("vkCmdClearDepthStencilImage");

fn void cmd_clear_attachments(
  VkCommandBuffer command_buffer, 
  uint attachment_count, 
  VkClearAttachment * p_attachments, 
  uint rect_count, 
  VkClearRect * p_rects)
@extern("vkCmdClearAttachments");

fn void cmd_resolve_image(
  VkCommandBuffer command_buffer, 
  VkImage src_image, 
  VkImageLayout src_image_layout, 
  VkImage dst_image, 
  VkImageLayout dst_image_layout, 
  uint region_count, 
  VkImageResolve * p_regions)
@extern("vkCmdResolveImage");

fn void cmd_set_event(
  VkCommandBuffer command_buffer, 
  VkEvent event, 
  VkPipelineStageFlags stage_mask)
@extern("vkCmdSetEvent");

fn void cmd_reset_event(
  VkCommandBuffer command_buffer, 
  VkEvent event, 
  VkPipelineStageFlags stage_mask)
@extern("vkCmdResetEvent");

fn void cmd_wait_events(
  VkCommandBuffer command_buffer, 
  uint event_count, 
  VkEvent * p_events, 
  VkPipelineStageFlags src_stage_mask, 
  VkPipelineStageFlags dst_stage_mask, 
  uint memory_barrier_count, 
  VkMemoryBarrier * p_memory_barriers, 
  uint buffer_memory_barrier_count, 
  VkBufferMemoryBarrier * p_buffer_memory_barriers, 
  uint image_memory_barrier_count, 
  VkImageMemoryBarrier * p_image_memory_barriers)
@extern("vkCmdWaitEvents");

fn void cmd_pipeline_barrier(
  VkCommandBuffer command_buffer, 
  VkPipelineStageFlags src_stage_mask, 
  VkPipelineStageFlags dst_stage_mask, 
  VkDependencyFlags dependency_flags, 
  uint memory_barrier_count, 
  VkMemoryBarrier * p_memory_barriers, 
  uint buffer_memory_barrier_count, 
  VkBufferMemoryBarrier * p_buffer_memory_barriers, 
  uint image_memory_barrier_count, 
  VkImageMemoryBarrier * p_image_memory_barriers)
@extern("vkCmdPipelineBarrier");

fn void cmd_begin_query(
  VkCommandBuffer command_buffer, 
  VkQueryPool query_pool, 
  uint query, 
  VkQueryControlFlags flags)
@extern("vkCmdBeginQuery");

fn void cmd_end_query(
  VkCommandBuffer command_buffer, 
  VkQueryPool query_pool, 
  uint query)
@extern("vkCmdEndQuery");

fn void cmd_reset_query_pool(
  VkCommandBuffer command_buffer, 
  VkQueryPool query_pool, 
  uint first_query, 
  uint query_count)
@extern("vkCmdResetQueryPool");

fn void cmd_write_timestamp(
  VkCommandBuffer command_buffer, 
  VkPipelineStageFlagBits pipeline_stage, 
  VkQueryPool query_pool, 
  uint query)
@extern("vkCmdWriteTimestamp");

fn void cmd_copy_query_pool_results(
  VkCommandBuffer command_buffer, 
  VkQueryPool query_pool, 
  uint first_query, 
  uint query_count, 
  VkBuffer dst_buffer, 
  VkDeviceSize dst_offset, 
  VkDeviceSize stride, 
  VkQueryResultFlags flags)
@extern("vkCmdCopyQueryPoolResults");

fn void cmd_push_constants(
  VkCommandBuffer command_buffer, 
  VkPipelineLayout layout, 
  VkShaderStageFlags stage_flags, 
  uint offset, 
  uint size, 
  void * p_values)
@extern("vkCmdPushConstants");

fn void cmd_begin_render_pass(
  VkCommandBuffer command_buffer, 
  VkRenderPassBeginInfo * p_render_pass_begin, 
  VkSubpassContents contents)
@extern("vkCmdBeginRenderPass");

fn void cmd_next_subpass(
  VkCommandBuffer command_buffer, 
  VkSubpassContents contents)
@extern("vkCmdNextSubpass");

fn void cmd_end_render_pass(
  VkCommandBuffer command_buffer)
@extern("vkCmdEndRenderPass");

fn void cmd_execute_commands(
  VkCommandBuffer command_buffer, 
  uint command_buffer_count, 
  VkCommandBuffer * p_command_buffers)
@extern("vkCmdExecuteCommands");

typedef VkSamplerYcbcrConversion_T = void;

alias VkSamplerYcbcrConversion = VkSamplerYcbcrConversion_T *;

typedef VkDescriptorUpdateTemplate_T = void;

alias VkDescriptorUpdateTemplate = VkDescriptorUpdateTemplate_T *;

typedef VkPointClippingBehavior = inline CUInt;
const VkPointClippingBehavior POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES = 0;
const VkPointClippingBehavior POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY = 1;
const VkPointClippingBehavior POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR = POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES;
const VkPointClippingBehavior POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR = POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY;
const VkPointClippingBehavior POINT_CLIPPING_BEHAVIOR_BEGIN_RANGE = POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES;
const VkPointClippingBehavior POINT_CLIPPING_BEHAVIOR_END_RANGE = POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY;
const VkPointClippingBehavior POINT_CLIPPING_BEHAVIOR_RANGE_SIZE = (POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY-POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES+1);
const VkPointClippingBehavior POINT_CLIPPING_BEHAVIOR_MAX_ENUM = 0x7FFFFFFF;

typedef VkTessellationDomainOrigin = inline CUInt;
const VkTessellationDomainOrigin TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT = 0;
const VkTessellationDomainOrigin TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT = 1;
const VkTessellationDomainOrigin TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR = TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT;
const VkTessellationDomainOrigin TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR = TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT;
const VkTessellationDomainOrigin TESSELLATION_DOMAIN_ORIGIN_BEGIN_RANGE = TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT;
const VkTessellationDomainOrigin TESSELLATION_DOMAIN_ORIGIN_END_RANGE = TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT;
const VkTessellationDomainOrigin TESSELLATION_DOMAIN_ORIGIN_RANGE_SIZE = (TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT-TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT+1);
const VkTessellationDomainOrigin TESSELLATION_DOMAIN_ORIGIN_MAX_ENUM = 0x7FFFFFFF;

typedef VkSamplerYcbcrModelConversion = inline CUInt;
const VkSamplerYcbcrModelConversion SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY = 0;
const VkSamplerYcbcrModelConversion SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY = 1;
const VkSamplerYcbcrModelConversion SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709 = 2;
const VkSamplerYcbcrModelConversion SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601 = 3;
const VkSamplerYcbcrModelConversion SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020 = 4;
const VkSamplerYcbcrModelConversion SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR = SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY;
const VkSamplerYcbcrModelConversion SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR = SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY;
const VkSamplerYcbcrModelConversion SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR = SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709;
const VkSamplerYcbcrModelConversion SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR = SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601;
const VkSamplerYcbcrModelConversion SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR = SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020;
const VkSamplerYcbcrModelConversion SAMPLER_YCBCR_MODEL_CONVERSION_BEGIN_RANGE = SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY;
const VkSamplerYcbcrModelConversion SAMPLER_YCBCR_MODEL_CONVERSION_END_RANGE = SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020;
const VkSamplerYcbcrModelConversion SAMPLER_YCBCR_MODEL_CONVERSION_RANGE_SIZE = (SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020-SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY+1);
const VkSamplerYcbcrModelConversion SAMPLER_YCBCR_MODEL_CONVERSION_MAX_ENUM = 0x7FFFFFFF;

typedef VkSamplerYcbcrRange = inline CUInt;
const VkSamplerYcbcrRange SAMPLER_YCBCR_RANGE_ITU_FULL = 0;
const VkSamplerYcbcrRange SAMPLER_YCBCR_RANGE_ITU_NARROW = 1;
const VkSamplerYcbcrRange SAMPLER_YCBCR_RANGE_ITU_FULL_KHR = SAMPLER_YCBCR_RANGE_ITU_FULL;
const VkSamplerYcbcrRange SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR = SAMPLER_YCBCR_RANGE_ITU_NARROW;
const VkSamplerYcbcrRange SAMPLER_YCBCR_RANGE_BEGIN_RANGE = SAMPLER_YCBCR_RANGE_ITU_FULL;
const VkSamplerYcbcrRange SAMPLER_YCBCR_RANGE_END_RANGE = SAMPLER_YCBCR_RANGE_ITU_NARROW;
const VkSamplerYcbcrRange SAMPLER_YCBCR_RANGE_RANGE_SIZE = (SAMPLER_YCBCR_RANGE_ITU_NARROW-SAMPLER_YCBCR_RANGE_ITU_FULL+1);
const VkSamplerYcbcrRange SAMPLER_YCBCR_RANGE_MAX_ENUM = 0x7FFFFFFF;

typedef VkChromaLocation = inline CUInt;
const VkChromaLocation CHROMA_LOCATION_COSITED_EVEN = 0;
const VkChromaLocation CHROMA_LOCATION_MIDPOINT = 1;
const VkChromaLocation CHROMA_LOCATION_COSITED_EVEN_KHR = CHROMA_LOCATION_COSITED_EVEN;
const VkChromaLocation CHROMA_LOCATION_MIDPOINT_KHR = CHROMA_LOCATION_MIDPOINT;
const VkChromaLocation CHROMA_LOCATION_BEGIN_RANGE = CHROMA_LOCATION_COSITED_EVEN;
const VkChromaLocation CHROMA_LOCATION_END_RANGE = CHROMA_LOCATION_MIDPOINT;
const VkChromaLocation CHROMA_LOCATION_RANGE_SIZE = (CHROMA_LOCATION_MIDPOINT-CHROMA_LOCATION_COSITED_EVEN+1);
const VkChromaLocation CHROMA_LOCATION_MAX_ENUM = 0x7FFFFFFF;

typedef VkDescriptorUpdateTemplateType = inline CUInt;
const VkDescriptorUpdateTemplateType DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET = 0;
const VkDescriptorUpdateTemplateType DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR = 1;
const VkDescriptorUpdateTemplateType DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR = DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET;
const VkDescriptorUpdateTemplateType DESCRIPTOR_UPDATE_TEMPLATE_TYPE_BEGIN_RANGE = DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET;
const VkDescriptorUpdateTemplateType DESCRIPTOR_UPDATE_TEMPLATE_TYPE_END_RANGE = DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET;
const VkDescriptorUpdateTemplateType DESCRIPTOR_UPDATE_TEMPLATE_TYPE_RANGE_SIZE = (DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET-DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET+1);
const VkDescriptorUpdateTemplateType DESCRIPTOR_UPDATE_TEMPLATE_TYPE_MAX_ENUM = 0x7FFFFFFF;

typedef VkSubgroupFeatureFlagBits = inline CUInt;
const VkSubgroupFeatureFlagBits SUBGROUP_FEATURE_BASIC_BIT = 0x00000001;
const VkSubgroupFeatureFlagBits SUBGROUP_FEATURE_VOTE_BIT = 0x00000002;
const VkSubgroupFeatureFlagBits SUBGROUP_FEATURE_ARITHMETIC_BIT = 0x00000004;
const VkSubgroupFeatureFlagBits SUBGROUP_FEATURE_BALLOT_BIT = 0x00000008;
const VkSubgroupFeatureFlagBits SUBGROUP_FEATURE_SHUFFLE_BIT = 0x00000010;
const VkSubgroupFeatureFlagBits SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT = 0x00000020;
const VkSubgroupFeatureFlagBits SUBGROUP_FEATURE_CLUSTERED_BIT = 0x00000040;
const VkSubgroupFeatureFlagBits SUBGROUP_FEATURE_QUAD_BIT = 0x00000080;
const VkSubgroupFeatureFlagBits SUBGROUP_FEATURE_PARTITIONED_BIT_NV = 0x00000100;
const VkSubgroupFeatureFlagBits SUBGROUP_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkSubgroupFeatureFlags = VkFlags;

typedef VkPeerMemoryFeatureFlagBits = inline CUInt;
const VkPeerMemoryFeatureFlagBits PEER_MEMORY_FEATURE_COPY_SRC_BIT = 0x00000001;
const VkPeerMemoryFeatureFlagBits PEER_MEMORY_FEATURE_COPY_DST_BIT = 0x00000002;
const VkPeerMemoryFeatureFlagBits PEER_MEMORY_FEATURE_GENERIC_SRC_BIT = 0x00000004;
const VkPeerMemoryFeatureFlagBits PEER_MEMORY_FEATURE_GENERIC_DST_BIT = 0x00000008;
const VkPeerMemoryFeatureFlagBits PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR = PEER_MEMORY_FEATURE_COPY_SRC_BIT;
const VkPeerMemoryFeatureFlagBits PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR = PEER_MEMORY_FEATURE_COPY_DST_BIT;
const VkPeerMemoryFeatureFlagBits PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR = PEER_MEMORY_FEATURE_GENERIC_SRC_BIT;
const VkPeerMemoryFeatureFlagBits PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR = PEER_MEMORY_FEATURE_GENERIC_DST_BIT;
const VkPeerMemoryFeatureFlagBits PEER_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkPeerMemoryFeatureFlags = VkFlags;

typedef VkMemoryAllocateFlagBits = inline CUInt;
const VkMemoryAllocateFlagBits MEMORY_ALLOCATE_DEVICE_MASK_BIT = 0x00000001;
const VkMemoryAllocateFlagBits MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR = 0x00000002;
const VkMemoryAllocateFlagBits MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR = 0x00000004;
const VkMemoryAllocateFlagBits MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR = MEMORY_ALLOCATE_DEVICE_MASK_BIT;
const VkMemoryAllocateFlagBits MEMORY_ALLOCATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkMemoryAllocateFlags = VkFlags;

alias VkCommandPoolTrimFlags = VkFlags;

alias VkDescriptorUpdateTemplateCreateFlags = VkFlags;

typedef VkExternalMemoryHandleTypeFlagBits = inline CUInt;
const VkExternalMemoryHandleTypeFlagBits EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT = 0x00000001;
const VkExternalMemoryHandleTypeFlagBits EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT = 0x00000002;
const VkExternalMemoryHandleTypeFlagBits EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 0x00000004;
const VkExternalMemoryHandleTypeFlagBits EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT = 0x00000008;
const VkExternalMemoryHandleTypeFlagBits EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT = 0x00000010;
const VkExternalMemoryHandleTypeFlagBits EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT = 0x00000020;
const VkExternalMemoryHandleTypeFlagBits EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT = 0x00000040;
const VkExternalMemoryHandleTypeFlagBits EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT = 0x00000200;
const VkExternalMemoryHandleTypeFlagBits EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID = 0x00000400;
const VkExternalMemoryHandleTypeFlagBits EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT = 0x00000080;
const VkExternalMemoryHandleTypeFlagBits EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT = 0x00000100;
const VkExternalMemoryHandleTypeFlagBits EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
const VkExternalMemoryHandleTypeFlagBits EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT;
const VkExternalMemoryHandleTypeFlagBits EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT;
const VkExternalMemoryHandleTypeFlagBits EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR = EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT;
const VkExternalMemoryHandleTypeFlagBits EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR = EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT;
const VkExternalMemoryHandleTypeFlagBits EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR = EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT;
const VkExternalMemoryHandleTypeFlagBits EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR = EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT;
const VkExternalMemoryHandleTypeFlagBits EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkExternalMemoryHandleTypeFlags = VkFlags;

typedef VkExternalMemoryFeatureFlagBits = inline CUInt;
const VkExternalMemoryFeatureFlagBits EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT = 0x00000001;
const VkExternalMemoryFeatureFlagBits EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT = 0x00000002;
const VkExternalMemoryFeatureFlagBits EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT = 0x00000004;
const VkExternalMemoryFeatureFlagBits EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR = EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT;
const VkExternalMemoryFeatureFlagBits EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR = EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT;
const VkExternalMemoryFeatureFlagBits EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR = EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT;
const VkExternalMemoryFeatureFlagBits EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkExternalMemoryFeatureFlags = VkFlags;

typedef VkExternalFenceHandleTypeFlagBits = inline CUInt;
const VkExternalFenceHandleTypeFlagBits EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT = 0x00000001;
const VkExternalFenceHandleTypeFlagBits EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 0x00000002;
const VkExternalFenceHandleTypeFlagBits EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 0x00000004;
const VkExternalFenceHandleTypeFlagBits EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT = 0x00000008;
const VkExternalFenceHandleTypeFlagBits EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT;
const VkExternalFenceHandleTypeFlagBits EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT;
const VkExternalFenceHandleTypeFlagBits EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT;
const VkExternalFenceHandleTypeFlagBits EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR = EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT;
const VkExternalFenceHandleTypeFlagBits EXTERNAL_FENCE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkExternalFenceHandleTypeFlags = VkFlags;

typedef VkExternalFenceFeatureFlagBits = inline CUInt;
const VkExternalFenceFeatureFlagBits EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT = 0x00000001;
const VkExternalFenceFeatureFlagBits EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT = 0x00000002;
const VkExternalFenceFeatureFlagBits EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR = EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT;
const VkExternalFenceFeatureFlagBits EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR = EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT;
const VkExternalFenceFeatureFlagBits EXTERNAL_FENCE_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkExternalFenceFeatureFlags = VkFlags;

typedef VkFenceImportFlagBits = inline CUInt;
const VkFenceImportFlagBits FENCE_IMPORT_TEMPORARY_BIT = 0x00000001;
const VkFenceImportFlagBits FENCE_IMPORT_TEMPORARY_BIT_KHR = FENCE_IMPORT_TEMPORARY_BIT;
const VkFenceImportFlagBits FENCE_IMPORT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkFenceImportFlags = VkFlags;

typedef VkSemaphoreImportFlagBits = inline CUInt;
const VkSemaphoreImportFlagBits SEMAPHORE_IMPORT_TEMPORARY_BIT = 0x00000001;
const VkSemaphoreImportFlagBits SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR = SEMAPHORE_IMPORT_TEMPORARY_BIT;
const VkSemaphoreImportFlagBits SEMAPHORE_IMPORT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkSemaphoreImportFlags = VkFlags;

typedef VkExternalSemaphoreHandleTypeFlagBits = inline CUInt;
const VkExternalSemaphoreHandleTypeFlagBits EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT = 0x00000001;
const VkExternalSemaphoreHandleTypeFlagBits EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 0x00000002;
const VkExternalSemaphoreHandleTypeFlagBits EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 0x00000004;
const VkExternalSemaphoreHandleTypeFlagBits EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT = 0x00000008;
const VkExternalSemaphoreHandleTypeFlagBits EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT = 0x00000010;
const VkExternalSemaphoreHandleTypeFlagBits EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
const VkExternalSemaphoreHandleTypeFlagBits EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT;
const VkExternalSemaphoreHandleTypeFlagBits EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT;
const VkExternalSemaphoreHandleTypeFlagBits EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR = EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT;
const VkExternalSemaphoreHandleTypeFlagBits EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR = EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT;
const VkExternalSemaphoreHandleTypeFlagBits EXTERNAL_SEMAPHORE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkExternalSemaphoreHandleTypeFlags = VkFlags;

typedef VkExternalSemaphoreFeatureFlagBits = inline CUInt;
const VkExternalSemaphoreFeatureFlagBits EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT = 0x00000001;
const VkExternalSemaphoreFeatureFlagBits EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT = 0x00000002;
const VkExternalSemaphoreFeatureFlagBits EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR = EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT;
const VkExternalSemaphoreFeatureFlagBits EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR = EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT;
const VkExternalSemaphoreFeatureFlagBits EXTERNAL_SEMAPHORE_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF;

alias VkExternalSemaphoreFeatureFlags = VkFlags;

struct VkPhysicalDeviceSubgroupProperties {
  VkStructureType s_type;
  void * p_next;
  uint subgroup_size;
  VkShaderStageFlags supported_stages;
  VkSubgroupFeatureFlags supported_operations;
  VkBool32 quad_operations_in_all_stages;
}

struct VkBindBufferMemoryInfo {
  VkStructureType s_type;
  void * p_next;
  VkBuffer buffer;
  VkDeviceMemory memory;
  VkDeviceSize memory_offset;
}

struct VkBindImageMemoryInfo {
  VkStructureType s_type;
  void * p_next;
  VkImage image;
  VkDeviceMemory memory;
  VkDeviceSize memory_offset;
}

struct VkPhysicalDevice16BitStorageFeatures {
  VkStructureType s_type;
  void * p_next;
  VkBool32 storage_buffer_16_bit_access;
  VkBool32 uniform_and_storage_buffer_16_bit_access;
  VkBool32 storage_push_constant_16;
  VkBool32 storage_input_output_16;
}

struct VkMemoryDedicatedRequirements {
  VkStructureType s_type;
  void * p_next;
  VkBool32 prefers_dedicated_allocation;
  VkBool32 requires_dedicated_allocation;
}

struct VkMemoryDedicatedAllocateInfo {
  VkStructureType s_type;
  void * p_next;
  VkImage image;
  VkBuffer buffer;
}

struct VkMemoryAllocateFlagsInfo {
  VkStructureType s_type;
  void * p_next;
  VkMemoryAllocateFlags flags;
  uint device_mask;
}

struct VkDeviceGroupRenderPassBeginInfo {
  VkStructureType s_type;
  void * p_next;
  uint device_mask;
  uint device_render_area_count;
  VkRect2D * p_device_render_areas;
}

struct VkDeviceGroupCommandBufferBeginInfo {
  VkStructureType s_type;
  void * p_next;
  uint device_mask;
}

struct VkDeviceGroupSubmitInfo {
  VkStructureType s_type;
  void * p_next;
  uint wait_semaphore_count;
  uint * p_wait_semaphore_device_indices;
  uint command_buffer_count;
  uint * p_command_buffer_device_masks;
  uint signal_semaphore_count;
  uint * p_signal_semaphore_device_indices;
}

struct VkDeviceGroupBindSparseInfo {
  VkStructureType s_type;
  void * p_next;
  uint resource_device_index;
  uint memory_device_index;
}

struct VkBindBufferMemoryDeviceGroupInfo {
  VkStructureType s_type;
  void * p_next;
  uint device_index_count;
  uint * p_device_indices;
}

struct VkBindImageMemoryDeviceGroupInfo {
  VkStructureType s_type;
  void * p_next;
  uint device_index_count;
  uint * p_device_indices;
  uint split_instance_bind_region_count;
  VkRect2D * p_split_instance_bind_regions;
}

struct VkPhysicalDeviceGroupProperties {
  VkStructureType s_type;
  void * p_next;
  uint physical_device_count;
  VkPhysicalDevice[32] physical_devices;
  VkBool32 subset_allocation;
}

struct VkDeviceGroupDeviceCreateInfo {
  VkStructureType s_type;
  void * p_next;
  uint physical_device_count;
  VkPhysicalDevice * p_physical_devices;
}

struct VkBufferMemoryRequirementsInfo2 {
  VkStructureType s_type;
  void * p_next;
  VkBuffer buffer;
}

struct VkImageMemoryRequirementsInfo2 {
  VkStructureType s_type;
  void * p_next;
  VkImage image;
}

struct VkImageSparseMemoryRequirementsInfo2 {
  VkStructureType s_type;
  void * p_next;
  VkImage image;
}

struct VkMemoryRequirements2 {
  VkStructureType s_type;
  void * p_next;
  VkMemoryRequirements memory_requirements;
}

alias VkMemoryRequirements2KHR = VkMemoryRequirements2;

struct VkSparseImageMemoryRequirements2 {
  VkStructureType s_type;
  void * p_next;
  VkSparseImageMemoryRequirements memory_requirements;
}

struct VkPhysicalDeviceFeatures2 {
  VkStructureType s_type;
  void * p_next;
  VkPhysicalDeviceFeatures features;
}

struct VkPhysicalDeviceProperties2 {
  VkStructureType s_type;
  void * p_next;
  VkPhysicalDeviceProperties properties;
}

struct VkFormatProperties2 {
  VkStructureType s_type;
  void * p_next;
  VkFormatProperties format_properties;
}

struct VkImageFormatProperties2 {
  VkStructureType s_type;
  void * p_next;
  VkImageFormatProperties image_format_properties;
}

struct VkPhysicalDeviceImageFormatInfo2 {
  VkStructureType s_type;
  void * p_next;
  VkFormat format;
  VkImageType type;
  VkImageTiling tiling;
  VkImageUsageFlags usage;
  VkImageCreateFlags flags;
}

struct VkQueueFamilyProperties2 {
  VkStructureType s_type;
  void * p_next;
  VkQueueFamilyProperties queue_family_properties;
}

struct VkPhysicalDeviceMemoryProperties2 {
  VkStructureType s_type;
  void * p_next;
  VkPhysicalDeviceMemoryProperties memory_properties;
}

struct VkSparseImageFormatProperties2 {
  VkStructureType s_type;
  void * p_next;
  VkSparseImageFormatProperties properties;
}

struct VkPhysicalDeviceSparseImageFormatInfo2 {
  VkStructureType s_type;
  void * p_next;
  VkFormat format;
  VkImageType type;
  VkSampleCountFlagBits samples;
  VkImageUsageFlags usage;
  VkImageTiling tiling;
}

struct VkPhysicalDevicePointClippingProperties {
  VkStructureType s_type;
  void * p_next;
  VkPointClippingBehavior point_clipping_behavior;
}

struct VkInputAttachmentAspectReference {
  uint subpass;
  uint input_attachment_index;
  VkImageAspectFlags aspect_mask;
}

struct VkRenderPassInputAttachmentAspectCreateInfo {
  VkStructureType s_type;
  void * p_next;
  uint aspect_reference_count;
  VkInputAttachmentAspectReference * p_aspect_references;
}

struct VkImageViewUsageCreateInfo {
  VkStructureType s_type;
  void * p_next;
  VkImageUsageFlags usage;
}

struct VkPipelineTessellationDomainOriginStateCreateInfo {
  VkStructureType s_type;
  void * p_next;
  VkTessellationDomainOrigin domain_origin;
}

struct VkRenderPassMultiviewCreateInfo {
  VkStructureType s_type;
  void * p_next;
  uint subpass_count;
  uint * p_view_masks;
  uint dependency_count;
  int * p_view_offsets;
  uint correlation_mask_count;
  uint * p_correlation_masks;
}

struct VkPhysicalDeviceMultiviewFeatures {
  VkStructureType s_type;
  void * p_next;
  VkBool32 multiview;
  VkBool32 multiview_geometry_shader;
  VkBool32 multiview_tessellation_shader;
}

struct VkPhysicalDeviceMultiviewProperties {
  VkStructureType s_type;
  void * p_next;
  uint max_multiview_view_count;
  uint max_multiview_instance_index;
}

struct VkPhysicalDeviceVariablePointersFeatures {
  VkStructureType s_type;
  void * p_next;
  VkBool32 variable_pointers_storage_buffer;
  VkBool32 variable_pointers;
}

alias VkPhysicalDeviceVariablePointerFeatures = VkPhysicalDeviceVariablePointersFeatures;

struct VkPhysicalDeviceProtectedMemoryFeatures {
  VkStructureType s_type;
  void * p_next;
  VkBool32 protected_memory;
}

struct VkPhysicalDeviceProtectedMemoryProperties {
  VkStructureType s_type;
  void * p_next;
  VkBool32 protected_no_fault;
}

struct VkDeviceQueueInfo2 {
  VkStructureType s_type;
  void * p_next;
  VkDeviceQueueCreateFlags flags;
  uint queue_family_index;
  uint queue_index;
}

struct VkProtectedSubmitInfo {
  VkStructureType s_type;
  void * p_next;
  VkBool32 protected_submit;
}

struct VkSamplerYcbcrConversionCreateInfo {
  VkStructureType s_type;
  void * p_next;
  VkFormat format;
  VkSamplerYcbcrModelConversion ycbcr_model;
  VkSamplerYcbcrRange ycbcr_range;
  VkComponentMapping components;
  VkChromaLocation x_chroma_offset;
  VkChromaLocation y_chroma_offset;
  VkFilter chroma_filter;
  VkBool32 force_explicit_reconstruction;
}

struct VkSamplerYcbcrConversionInfo {
  VkStructureType s_type;
  void * p_next;
  VkSamplerYcbcrConversion conversion;
}

struct VkBindImagePlaneMemoryInfo {
  VkStructureType s_type;
  void * p_next;
  VkImageAspectFlagBits plane_aspect;
}

struct VkImagePlaneMemoryRequirementsInfo {
  VkStructureType s_type;
  void * p_next;
  VkImageAspectFlagBits plane_aspect;
}

struct VkPhysicalDeviceSamplerYcbcrConversionFeatures {
  VkStructureType s_type;
  void * p_next;
  VkBool32 sampler_ycbcr_conversion;
}

struct VkSamplerYcbcrConversionImageFormatProperties {
  VkStructureType s_type;
  void * p_next;
  uint combined_image_sampler_descriptor_count;
}

struct VkDescriptorUpdateTemplateEntry {
  uint dst_binding;
  uint dst_array_element;
  uint descriptor_count;
  VkDescriptorType descriptor_type;
  usz offset;
  usz stride;
}

struct VkDescriptorUpdateTemplateCreateInfo {
  VkStructureType s_type;
  void * p_next;
  VkDescriptorUpdateTemplateCreateFlags flags;
  uint descriptor_update_entry_count;
  VkDescriptorUpdateTemplateEntry * p_descriptor_update_entries;
  VkDescriptorUpdateTemplateType template_type;
  VkDescriptorSetLayout descriptor_set_layout;
  VkPipelineBindPoint pipeline_bind_point;
  VkPipelineLayout pipeline_layout;
  uint set;
}

struct VkExternalMemoryProperties {
  VkExternalMemoryFeatureFlags external_memory_features;
  VkExternalMemoryHandleTypeFlags export_from_imported_handle_types;
  VkExternalMemoryHandleTypeFlags compatible_handle_types;
}

struct VkPhysicalDeviceExternalImageFormatInfo {
  VkStructureType s_type;
  void * p_next;
  VkExternalMemoryHandleTypeFlagBits handle_type;
}

struct VkExternalImageFormatProperties {
  VkStructureType s_type;
  void * p_next;
  VkExternalMemoryProperties external_memory_properties;
}

struct VkPhysicalDeviceExternalBufferInfo {
  VkStructureType s_type;
  void * p_next;
  VkBufferCreateFlags flags;
  VkBufferUsageFlags usage;
  VkExternalMemoryHandleTypeFlagBits handle_type;
}

struct VkExternalBufferProperties {
  VkStructureType s_type;
  void * p_next;
  VkExternalMemoryProperties external_memory_properties;
}

struct VkPhysicalDeviceIDProperties {
  VkStructureType s_type;
  void * p_next;
  char[16] device_uuid;
  char[16] driver_uuid;
  char[8] device_luid;
  uint device_node_mask;
  VkBool32 device_luidvalid;
}

struct VkExternalMemoryImageCreateInfo {
  VkStructureType s_type;
  void * p_next;
  VkExternalMemoryHandleTypeFlags handle_types;
}

struct VkExternalMemoryBufferCreateInfo {
  VkStructureType s_type;
  void * p_next;
  VkExternalMemoryHandleTypeFlags handle_types;
}

struct VkExportMemoryAllocateInfo {
  VkStructureType s_type;
  void * p_next;
  VkExternalMemoryHandleTypeFlags handle_types;
}

struct VkPhysicalDeviceExternalFenceInfo {
  VkStructureType s_type;
  void * p_next;
  VkExternalFenceHandleTypeFlagBits handle_type;
}

struct VkExternalFenceProperties {
  VkStructureType s_type;
  void * p_next;
  VkExternalFenceHandleTypeFlags export_from_imported_handle_types;
  VkExternalFenceHandleTypeFlags compatible_handle_types;
  VkExternalFenceFeatureFlags external_fence_features;
}

struct VkExportFenceCreateInfo {
  VkStructureType s_type;
  void * p_next;
  VkExternalFenceHandleTypeFlags handle_types;
}

struct VkExportSemaphoreCreateInfo {
  VkStructureType s_type;
  void * p_next;
  VkExternalSemaphoreHandleTypeFlags handle_types;
}

struct VkPhysicalDeviceExternalSemaphoreInfo {
  VkStructureType s_type;
  void * p_next;
  VkExternalSemaphoreHandleTypeFlagBits handle_type;
}

struct VkExternalSemaphoreProperties {
  VkStructureType s_type;
  void * p_next;
  VkExternalSemaphoreHandleTypeFlags export_from_imported_handle_types;
  VkExternalSemaphoreHandleTypeFlags compatible_handle_types;
  VkExternalSemaphoreFeatureFlags external_semaphore_features;
}

struct VkPhysicalDeviceMaintenance3Properties {
  VkStructureType s_type;
  void * p_next;
  uint max_per_set_descriptors;
  VkDeviceSize max_memory_allocation_size;
}

struct VkDescriptorSetLayoutSupport {
  VkStructureType s_type;
  void * p_next;
  VkBool32 supported;
}

struct VkPhysicalDeviceShaderDrawParametersFeatures {
  VkStructureType s_type;
  void * p_next;
  VkBool32 shader_draw_parameters;
}

alias VkPhysicalDeviceShaderDrawParameterFeatures = VkPhysicalDeviceShaderDrawParametersFeatures;

alias PFN_vkEnumerateInstanceVersion = fn VkResult(  uint * p_api_version);

alias PFN_vkBindBufferMemory2 = fn VkResult(
  VkDevice device, 
  uint bind_info_count, 
  VkBindBufferMemoryInfo * p_bind_infos);

alias PFN_vkBindImageMemory2 = fn VkResult(
  VkDevice device, 
  uint bind_info_count, 
  VkBindImageMemoryInfo * p_bind_infos);

alias PFN_vkGetDeviceGroupPeerMemoryFeatures = fn void(
  VkDevice device, 
  uint heap_index, 
  uint local_device_index, 
  uint remote_device_index, 
  VkPeerMemoryFeatureFlags * p_peer_memory_features);

alias PFN_vkCmdSetDeviceMask = fn void(
  VkCommandBuffer command_buffer, 
  uint device_mask);

alias PFN_vkCmdDispatchBase = fn void(
  VkCommandBuffer command_buffer, 
  uint base_group_x, 
  uint base_group_y, 
  uint base_group_z, 
  uint group_count_x, 
  uint group_count_y, 
  uint group_count_z);

alias PFN_vkEnumeratePhysicalDeviceGroups = fn VkResult(
  VkInstance instance, 
  uint * p_physical_device_group_count, 
  VkPhysicalDeviceGroupProperties * p_physical_device_group_properties);

alias PFN_vkGetImageMemoryRequirements2 = fn void(
  VkDevice device, 
  VkImageMemoryRequirementsInfo2 * p_info, 
  VkMemoryRequirements2 * p_memory_requirements);

alias PFN_vkGetBufferMemoryRequirements2 = fn void(
  VkDevice device, 
  VkBufferMemoryRequirementsInfo2 * p_info, 
  VkMemoryRequirements2 * p_memory_requirements);

alias PFN_vkGetImageSparseMemoryRequirements2 = fn void(
  VkDevice device, 
  VkImageSparseMemoryRequirementsInfo2 * p_info, 
  uint * p_sparse_memory_requirement_count, 
  VkSparseImageMemoryRequirements2 * p_sparse_memory_requirements);

alias PFN_vkGetPhysicalDeviceFeatures2 = fn void(
  VkPhysicalDevice physical_device, 
  VkPhysicalDeviceFeatures2 * p_features);

alias PFN_vkGetPhysicalDeviceProperties2 = fn void(
  VkPhysicalDevice physical_device, 
  VkPhysicalDeviceProperties2 * p_properties);

alias PFN_vkGetPhysicalDeviceFormatProperties2 = fn void(
  VkPhysicalDevice physical_device, 
  VkFormat format, 
  VkFormatProperties2 * p_format_properties);

alias PFN_vkGetPhysicalDeviceImageFormatProperties2 = fn VkResult(
  VkPhysicalDevice physical_device, 
  VkPhysicalDeviceImageFormatInfo2 * p_image_format_info, 
  VkImageFormatProperties2 * p_image_format_properties);

alias PFN_vkGetPhysicalDeviceQueueFamilyProperties2 = fn void(
  VkPhysicalDevice physical_device, 
  uint * p_queue_family_property_count, 
  VkQueueFamilyProperties2 * p_queue_family_properties);

alias PFN_vkGetPhysicalDeviceMemoryProperties2 = fn void(
  VkPhysicalDevice physical_device, 
  VkPhysicalDeviceMemoryProperties2 * p_memory_properties);

alias PFN_vkGetPhysicalDeviceSparseImageFormatProperties2 = fn void(
  VkPhysicalDevice physical_device, 
  VkPhysicalDeviceSparseImageFormatInfo2 * p_format_info, 
  uint * p_property_count, 
  VkSparseImageFormatProperties2 * p_properties);

alias PFN_vkTrimCommandPool = fn void(
  VkDevice device, 
  VkCommandPool command_pool, 
  VkCommandPoolTrimFlags flags);

alias PFN_vkGetDeviceQueue2 = fn void(
  VkDevice device, 
  VkDeviceQueueInfo2 * p_queue_info, 
  VkQueue * p_queue);

alias PFN_vkCreateSamplerYcbcrConversion = fn VkResult(
  VkDevice device, 
  VkSamplerYcbcrConversionCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkSamplerYcbcrConversion * p_ycbcr_conversion);

alias PFN_vkDestroySamplerYcbcrConversion = fn void(
  VkDevice device, 
  VkSamplerYcbcrConversion ycbcr_conversion, 
  VkAllocationCallbacks * p_allocator);

alias PFN_vkCreateDescriptorUpdateTemplate = fn VkResult(
  VkDevice device, 
  VkDescriptorUpdateTemplateCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkDescriptorUpdateTemplate * p_descriptor_update_template);

alias PFN_vkDestroyDescriptorUpdateTemplate = fn void(
  VkDevice device, 
  VkDescriptorUpdateTemplate descriptor_update_template, 
  VkAllocationCallbacks * p_allocator);

alias PFN_vkUpdateDescriptorSetWithTemplate = fn void(
  VkDevice device, 
  VkDescriptorSet descriptor_set, 
  VkDescriptorUpdateTemplate descriptor_update_template, 
  void * p_data);

alias PFN_vkGetPhysicalDeviceExternalBufferProperties = fn void(
  VkPhysicalDevice physical_device, 
  VkPhysicalDeviceExternalBufferInfo * p_external_buffer_info, 
  VkExternalBufferProperties * p_external_buffer_properties);

alias PFN_vkGetPhysicalDeviceExternalFenceProperties = fn void(
  VkPhysicalDevice physical_device, 
  VkPhysicalDeviceExternalFenceInfo * p_external_fence_info, 
  VkExternalFenceProperties * p_external_fence_properties);

alias PFN_vkGetPhysicalDeviceExternalSemaphoreProperties = fn void(
  VkPhysicalDevice physical_device, 
  VkPhysicalDeviceExternalSemaphoreInfo * p_external_semaphore_info, 
  VkExternalSemaphoreProperties * p_external_semaphore_properties);

alias PFN_vkGetDescriptorSetLayoutSupport = fn void(
  VkDevice device, 
  VkDescriptorSetLayoutCreateInfo * p_create_info, 
  VkDescriptorSetLayoutSupport * p_support);

fn VkResult enumerate_instance_version(
  uint * p_api_version)
@extern("vkEnumerateInstanceVersion");

fn VkResult bind_buffer_memory_2(
  VkDevice device, 
  uint bind_info_count, 
  VkBindBufferMemoryInfo * p_bind_infos)
@extern("vkBindBufferMemory2");

fn VkResult bind_image_memory_2(
  VkDevice device, 
  uint bind_info_count, 
  VkBindImageMemoryInfo * p_bind_infos)
@extern("vkBindImageMemory2");

fn void get_device_group_peer_memory_features(
  VkDevice device, 
  uint heap_index, 
  uint local_device_index, 
  uint remote_device_index, 
  VkPeerMemoryFeatureFlags * p_peer_memory_features)
@extern("vkGetDeviceGroupPeerMemoryFeatures");

fn void cmd_set_device_mask(
  VkCommandBuffer command_buffer, 
  uint device_mask)
@extern("vkCmdSetDeviceMask");

fn void cmd_dispatch_base(
  VkCommandBuffer command_buffer, 
  uint base_group_x, 
  uint base_group_y, 
  uint base_group_z, 
  uint group_count_x, 
  uint group_count_y, 
  uint group_count_z)
@extern("vkCmdDispatchBase");

fn VkResult enumerate_physical_device_groups(
  VkInstance instance, 
  uint * p_physical_device_group_count, 
  VkPhysicalDeviceGroupProperties * p_physical_device_group_properties)
@extern("vkEnumeratePhysicalDeviceGroups");

fn void get_image_memory_requirements_2(
  VkDevice device, 
  VkImageMemoryRequirementsInfo2 * p_info, 
  VkMemoryRequirements2 * p_memory_requirements)
@extern("vkGetImageMemoryRequirements2");

fn void get_buffer_memory_requirements_2(
  VkDevice device, 
  VkBufferMemoryRequirementsInfo2 * p_info, 
  VkMemoryRequirements2 * p_memory_requirements)
@extern("vkGetBufferMemoryRequirements2");

fn void get_image_sparse_memory_requirements_2(
  VkDevice device, 
  VkImageSparseMemoryRequirementsInfo2 * p_info, 
  uint * p_sparse_memory_requirement_count, 
  VkSparseImageMemoryRequirements2 * p_sparse_memory_requirements)
@extern("vkGetImageSparseMemoryRequirements2");

fn void get_physical_device_features_2(
  VkPhysicalDevice physical_device, 
  VkPhysicalDeviceFeatures2 * p_features)
@extern("vkGetPhysicalDeviceFeatures2");

fn void get_physical_device_properties_2(
  VkPhysicalDevice physical_device, 
  VkPhysicalDeviceProperties2 * p_properties)
@extern("vkGetPhysicalDeviceProperties2");

fn void get_physical_device_format_properties_2(
  VkPhysicalDevice physical_device, 
  VkFormat format, 
  VkFormatProperties2 * p_format_properties)
@extern("vkGetPhysicalDeviceFormatProperties2");

fn VkResult get_physical_device_image_format_properties_2(
  VkPhysicalDevice physical_device, 
  VkPhysicalDeviceImageFormatInfo2 * p_image_format_info, 
  VkImageFormatProperties2 * p_image_format_properties)
@extern("vkGetPhysicalDeviceImageFormatProperties2");

fn void get_physical_device_queue_family_properties_2(
  VkPhysicalDevice physical_device, 
  uint * p_queue_family_property_count, 
  VkQueueFamilyProperties2 * p_queue_family_properties)
@extern("vkGetPhysicalDeviceQueueFamilyProperties2");

fn void get_physical_device_memory_properties_2(
  VkPhysicalDevice physical_device, 
  VkPhysicalDeviceMemoryProperties2 * p_memory_properties)
@extern("vkGetPhysicalDeviceMemoryProperties2");

fn void get_physical_device_sparse_image_format_properties_2(
  VkPhysicalDevice physical_device, 
  VkPhysicalDeviceSparseImageFormatInfo2 * p_format_info, 
  uint * p_property_count, 
  VkSparseImageFormatProperties2 * p_properties)
@extern("vkGetPhysicalDeviceSparseImageFormatProperties2");

fn void trim_command_pool(
  VkDevice device, 
  VkCommandPool command_pool, 
  VkCommandPoolTrimFlags flags)
@extern("vkTrimCommandPool");

fn void get_device_queue_2(
  VkDevice device, 
  VkDeviceQueueInfo2 * p_queue_info, 
  VkQueue * p_queue)
@extern("vkGetDeviceQueue2");

fn VkResult create_sampler_ycbcr_conversion(
  VkDevice device, 
  VkSamplerYcbcrConversionCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkSamplerYcbcrConversion * p_ycbcr_conversion)
@extern("vkCreateSamplerYcbcrConversion");

fn void destroy_sampler_ycbcr_conversion(
  VkDevice device, 
  VkSamplerYcbcrConversion ycbcr_conversion, 
  VkAllocationCallbacks * p_allocator)
@extern("vkDestroySamplerYcbcrConversion");

fn VkResult create_descriptor_update_template(
  VkDevice device, 
  VkDescriptorUpdateTemplateCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkDescriptorUpdateTemplate * p_descriptor_update_template)
@extern("vkCreateDescriptorUpdateTemplate");

fn void destroy_descriptor_update_template(
  VkDevice device, 
  VkDescriptorUpdateTemplate descriptor_update_template, 
  VkAllocationCallbacks * p_allocator)
@extern("vkDestroyDescriptorUpdateTemplate");

fn void update_descriptor_set_with_template(
  VkDevice device, 
  VkDescriptorSet descriptor_set, 
  VkDescriptorUpdateTemplate descriptor_update_template, 
  void * p_data)
@extern("vkUpdateDescriptorSetWithTemplate");

fn void get_physical_device_external_buffer_properties(
  VkPhysicalDevice physical_device, 
  VkPhysicalDeviceExternalBufferInfo * p_external_buffer_info, 
  VkExternalBufferProperties * p_external_buffer_properties)
@extern("vkGetPhysicalDeviceExternalBufferProperties");

fn void get_physical_device_external_fence_properties(
  VkPhysicalDevice physical_device, 
  VkPhysicalDeviceExternalFenceInfo * p_external_fence_info, 
  VkExternalFenceProperties * p_external_fence_properties)
@extern("vkGetPhysicalDeviceExternalFenceProperties");

fn void get_physical_device_external_semaphore_properties(
  VkPhysicalDevice physical_device, 
  VkPhysicalDeviceExternalSemaphoreInfo * p_external_semaphore_info, 
  VkExternalSemaphoreProperties * p_external_semaphore_properties)
@extern("vkGetPhysicalDeviceExternalSemaphoreProperties");

fn void get_descriptor_set_layout_support(
  VkDevice device, 
  VkDescriptorSetLayoutCreateInfo * p_create_info, 
  VkDescriptorSetLayoutSupport * p_support)
@extern("vkGetDescriptorSetLayoutSupport");

typedef VkSurfaceKHR_T = void;

alias VkSurfaceKHR = VkSurfaceKHR_T *;

typedef VkColorSpaceKHR = inline CUInt;
const VkColorSpaceKHR COLOR_SPACE_SRGB_NONLINEAR_KHR = 0;
const VkColorSpaceKHR COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT = 1000104001;
const VkColorSpaceKHR COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT = 1000104002;
const VkColorSpaceKHR COLOR_SPACE_DISPLAY_P3_LINEAR_EXT = 1000104003;
const VkColorSpaceKHR COLOR_SPACE_DCI_P3_NONLINEAR_EXT = 1000104004;
const VkColorSpaceKHR COLOR_SPACE_BT709_LINEAR_EXT = 1000104005;
const VkColorSpaceKHR COLOR_SPACE_BT709_NONLINEAR_EXT = 1000104006;
const VkColorSpaceKHR COLOR_SPACE_BT2020_LINEAR_EXT = 1000104007;
const VkColorSpaceKHR COLOR_SPACE_HDR10_ST2084_EXT = 1000104008;
const VkColorSpaceKHR COLOR_SPACE_DOLBYVISION_EXT = 1000104009;
const VkColorSpaceKHR COLOR_SPACE_HDR10_HLG_EXT = 1000104010;
const VkColorSpaceKHR COLOR_SPACE_ADOBERGB_LINEAR_EXT = 1000104011;
const VkColorSpaceKHR COLOR_SPACE_ADOBERGB_NONLINEAR_EXT = 1000104012;
const VkColorSpaceKHR COLOR_SPACE_PASS_THROUGH_EXT = 1000104013;
const VkColorSpaceKHR COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT = 1000104014;
const VkColorSpaceKHR COLOR_SPACE_DISPLAY_NATIVE_AMD = 1000213000;
const VkColorSpaceKHR COLORSPACE_SRGB_NONLINEAR_KHR = COLOR_SPACE_SRGB_NONLINEAR_KHR;
const VkColorSpaceKHR COLOR_SPACE_DCI_P3_LINEAR_EXT = COLOR_SPACE_DISPLAY_P3_LINEAR_EXT;
const VkColorSpaceKHR COLOR_SPACE_BEGIN_RANGE_KHR = COLOR_SPACE_SRGB_NONLINEAR_KHR;
const VkColorSpaceKHR COLOR_SPACE_END_RANGE_KHR = COLOR_SPACE_SRGB_NONLINEAR_KHR;
const VkColorSpaceKHR COLOR_SPACE_RANGE_SIZE_KHR = (COLOR_SPACE_SRGB_NONLINEAR_KHR-COLOR_SPACE_SRGB_NONLINEAR_KHR+1);
const VkColorSpaceKHR COLOR_SPACE_MAX_ENUM_KHR = 0x7FFFFFFF;

typedef VkPresentModeKHR = inline CUInt;
const VkPresentModeKHR PRESENT_MODE_IMMEDIATE_KHR = 0;
const VkPresentModeKHR PRESENT_MODE_MAILBOX_KHR = 1;
const VkPresentModeKHR PRESENT_MODE_FIFO_KHR = 2;
const VkPresentModeKHR PRESENT_MODE_FIFO_RELAXED_KHR = 3;
const VkPresentModeKHR PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR = 1000111000;
const VkPresentModeKHR PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR = 1000111001;
const VkPresentModeKHR PRESENT_MODE_BEGIN_RANGE_KHR = PRESENT_MODE_IMMEDIATE_KHR;
const VkPresentModeKHR PRESENT_MODE_END_RANGE_KHR = PRESENT_MODE_FIFO_RELAXED_KHR;
const VkPresentModeKHR PRESENT_MODE_RANGE_SIZE_KHR = (PRESENT_MODE_FIFO_RELAXED_KHR-PRESENT_MODE_IMMEDIATE_KHR+1);
const VkPresentModeKHR PRESENT_MODE_MAX_ENUM_KHR = 0x7FFFFFFF;

typedef VkSurfaceTransformFlagBitsKHR = inline CUInt;
const VkSurfaceTransformFlagBitsKHR SURFACE_TRANSFORM_IDENTITY_BIT_KHR = 0x00000001;
const VkSurfaceTransformFlagBitsKHR SURFACE_TRANSFORM_ROTATE_90_BIT_KHR = 0x00000002;
const VkSurfaceTransformFlagBitsKHR SURFACE_TRANSFORM_ROTATE_180_BIT_KHR = 0x00000004;
const VkSurfaceTransformFlagBitsKHR SURFACE_TRANSFORM_ROTATE_270_BIT_KHR = 0x00000008;
const VkSurfaceTransformFlagBitsKHR SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR = 0x00000010;
const VkSurfaceTransformFlagBitsKHR SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = 0x00000020;
const VkSurfaceTransformFlagBitsKHR SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = 0x00000040;
const VkSurfaceTransformFlagBitsKHR SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = 0x00000080;
const VkSurfaceTransformFlagBitsKHR SURFACE_TRANSFORM_INHERIT_BIT_KHR = 0x00000100;
const VkSurfaceTransformFlagBitsKHR SURFACE_TRANSFORM_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF;

alias VkSurfaceTransformFlagsKHR = VkFlags;

typedef VkCompositeAlphaFlagBitsKHR = inline CUInt;
const VkCompositeAlphaFlagBitsKHR COMPOSITE_ALPHA_OPAQUE_BIT_KHR = 0x00000001;
const VkCompositeAlphaFlagBitsKHR COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR = 0x00000002;
const VkCompositeAlphaFlagBitsKHR COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR = 0x00000004;
const VkCompositeAlphaFlagBitsKHR COMPOSITE_ALPHA_INHERIT_BIT_KHR = 0x00000008;
const VkCompositeAlphaFlagBitsKHR COMPOSITE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF;

alias VkCompositeAlphaFlagsKHR = VkFlags;

struct VkSurfaceCapabilitiesKHR {
  uint min_image_count;
  uint max_image_count;
  VkExtent2D current_extent;
  VkExtent2D min_image_extent;
  VkExtent2D max_image_extent;
  uint max_image_array_layers;
  VkSurfaceTransformFlagsKHR supported_transforms;
  VkSurfaceTransformFlagBitsKHR current_transform;
  VkCompositeAlphaFlagsKHR supported_composite_alpha;
  VkImageUsageFlags supported_usage_flags;
}

struct VkSurfaceFormatKHR {
  VkFormat format;
  VkColorSpaceKHR color_space;
}

alias PFN_vkDestroySurfaceKHR = fn void(
  VkInstance instance, 
  VkSurfaceKHR surface, 
  VkAllocationCallbacks * p_allocator);

alias PFN_vkGetPhysicalDeviceSurfaceSupportKHR = fn VkResult(
  VkPhysicalDevice physical_device, 
  uint queue_family_index, 
  VkSurfaceKHR surface, 
  VkBool32 * p_supported);

alias PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR = fn VkResult(
  VkPhysicalDevice physical_device, 
  VkSurfaceKHR surface, 
  VkSurfaceCapabilitiesKHR * p_surface_capabilities);

alias PFN_vkGetPhysicalDeviceSurfaceFormatsKHR = fn VkResult(
  VkPhysicalDevice physical_device, 
  VkSurfaceKHR surface, 
  uint * p_surface_format_count, 
  VkSurfaceFormatKHR * p_surface_formats);

alias PFN_vkGetPhysicalDeviceSurfacePresentModesKHR = fn VkResult(
  VkPhysicalDevice physical_device, 
  VkSurfaceKHR surface, 
  uint * p_present_mode_count, 
  VkPresentModeKHR * p_present_modes);

fn void destroy_surface_khr(
  VkInstance instance, 
  VkSurfaceKHR surface, 
  VkAllocationCallbacks * p_allocator)
@extern("vkDestroySurfaceKHR");

fn VkResult get_physical_device_surface_support_khr(
  VkPhysicalDevice physical_device, 
  uint queue_family_index, 
  VkSurfaceKHR surface, 
  VkBool32 * p_supported)
@extern("vkGetPhysicalDeviceSurfaceSupportKHR");

fn VkResult get_physical_device_surface_capabilities_khr(
  VkPhysicalDevice physical_device, 
  VkSurfaceKHR surface, 
  VkSurfaceCapabilitiesKHR * p_surface_capabilities)
@extern("vkGetPhysicalDeviceSurfaceCapabilitiesKHR");

fn VkResult get_physical_device_surface_formats_khr(
  VkPhysicalDevice physical_device, 
  VkSurfaceKHR surface, 
  uint * p_surface_format_count, 
  VkSurfaceFormatKHR * p_surface_formats)
@extern("vkGetPhysicalDeviceSurfaceFormatsKHR");

fn VkResult get_physical_device_surface_present_modes_khr(
  VkPhysicalDevice physical_device, 
  VkSurfaceKHR surface, 
  uint * p_present_mode_count, 
  VkPresentModeKHR * p_present_modes)
@extern("vkGetPhysicalDeviceSurfacePresentModesKHR");

typedef VkSwapchainKHR_T = void;

alias VkSwapchainKHR = VkSwapchainKHR_T *;

typedef VkSwapchainCreateFlagBitsKHR = inline CUInt;
const VkSwapchainCreateFlagBitsKHR SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = 0x00000001;
const VkSwapchainCreateFlagBitsKHR SWAPCHAIN_CREATE_PROTECTED_BIT_KHR = 0x00000002;
const VkSwapchainCreateFlagBitsKHR SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR = 0x00000004;
const VkSwapchainCreateFlagBitsKHR SWAPCHAIN_CREATE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF;

alias VkSwapchainCreateFlagsKHR = VkFlags;

typedef VkDeviceGroupPresentModeFlagBitsKHR = inline CUInt;
const VkDeviceGroupPresentModeFlagBitsKHR DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR = 0x00000001;
const VkDeviceGroupPresentModeFlagBitsKHR DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR = 0x00000002;
const VkDeviceGroupPresentModeFlagBitsKHR DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR = 0x00000004;
const VkDeviceGroupPresentModeFlagBitsKHR DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR = 0x00000008;
const VkDeviceGroupPresentModeFlagBitsKHR DEVICE_GROUP_PRESENT_MODE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF;

alias VkDeviceGroupPresentModeFlagsKHR = VkFlags;

struct VkSwapchainCreateInfoKHR {
  VkStructureType s_type;
  void * p_next;
  VkSwapchainCreateFlagsKHR flags;
  VkSurfaceKHR surface;
  uint min_image_count;
  VkFormat image_format;
  VkColorSpaceKHR image_color_space;
  VkExtent2D image_extent;
  uint image_array_layers;
  VkImageUsageFlags image_usage;
  VkSharingMode image_sharing_mode;
  uint queue_family_index_count;
  uint * p_queue_family_indices;
  VkSurfaceTransformFlagBitsKHR pre_transform;
  VkCompositeAlphaFlagBitsKHR composite_alpha;
  VkPresentModeKHR present_mode;
  VkBool32 clipped;
  VkSwapchainKHR old_swapchain;
}

struct VkPresentInfoKHR {
  VkStructureType s_type;
  void * p_next;
  uint wait_semaphore_count;
  VkSemaphore * p_wait_semaphores;
  uint swapchain_count;
  VkSwapchainKHR * p_swapchains;
  uint * p_image_indices;
  VkResult * p_results;
}

struct VkImageSwapchainCreateInfoKHR {
  VkStructureType s_type;
  void * p_next;
  VkSwapchainKHR swapchain;
}

struct VkBindImageMemorySwapchainInfoKHR {
  VkStructureType s_type;
  void * p_next;
  VkSwapchainKHR swapchain;
  uint image_index;
}

struct VkAcquireNextImageInfoKHR {
  VkStructureType s_type;
  void * p_next;
  VkSwapchainKHR swapchain;
  ulong timeout;
  VkSemaphore semaphore;
  VkFence fence;
  uint device_mask;
}

struct VkDeviceGroupPresentCapabilitiesKHR {
  VkStructureType s_type;
  void * p_next;
  uint[32] present_mask;
  VkDeviceGroupPresentModeFlagsKHR modes;
}

struct VkDeviceGroupPresentInfoKHR {
  VkStructureType s_type;
  void * p_next;
  uint swapchain_count;
  uint * p_device_masks;
  VkDeviceGroupPresentModeFlagBitsKHR mode;
}

struct VkDeviceGroupSwapchainCreateInfoKHR {
  VkStructureType s_type;
  void * p_next;
  VkDeviceGroupPresentModeFlagsKHR modes;
}

alias PFN_vkCreateSwapchainKHR = fn VkResult(
  VkDevice device, 
  VkSwapchainCreateInfoKHR * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkSwapchainKHR * p_swapchain);

alias PFN_vkDestroySwapchainKHR = fn void(
  VkDevice device, 
  VkSwapchainKHR swapchain, 
  VkAllocationCallbacks * p_allocator);

alias PFN_vkGetSwapchainImagesKHR = fn VkResult(
  VkDevice device, 
  VkSwapchainKHR swapchain, 
  uint * p_swapchain_image_count, 
  VkImage * p_swapchain_images);

alias PFN_vkAcquireNextImageKHR = fn VkResult(
  VkDevice device, 
  VkSwapchainKHR swapchain, 
  ulong timeout, 
  VkSemaphore semaphore, 
  VkFence fence, 
  uint * p_image_index);

alias PFN_vkQueuePresentKHR = fn VkResult(
  VkQueue queue, 
  VkPresentInfoKHR * p_present_info);

alias PFN_vkGetDeviceGroupPresentCapabilitiesKHR = fn VkResult(
  VkDevice device, 
  VkDeviceGroupPresentCapabilitiesKHR * p_device_group_present_capabilities);

alias PFN_vkGetDeviceGroupSurfacePresentModesKHR = fn VkResult(
  VkDevice device, 
  VkSurfaceKHR surface, 
  VkDeviceGroupPresentModeFlagsKHR * p_modes);

alias PFN_vkGetPhysicalDevicePresentRectanglesKHR = fn VkResult(
  VkPhysicalDevice physical_device, 
  VkSurfaceKHR surface, 
  uint * p_rect_count, 
  VkRect2D * p_rects);

alias PFN_vkAcquireNextImage2KHR = fn VkResult(
  VkDevice device, 
  VkAcquireNextImageInfoKHR * p_acquire_info, 
  uint * p_image_index);

fn VkResult create_swapchain_khr(
  VkDevice device, 
  VkSwapchainCreateInfoKHR * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkSwapchainKHR * p_swapchain)
@extern("vkCreateSwapchainKHR");

fn void destroy_swapchain_khr(
  VkDevice device, 
  VkSwapchainKHR swapchain, 
  VkAllocationCallbacks * p_allocator)
@extern("vkDestroySwapchainKHR");

fn VkResult get_swapchain_images_khr(
  VkDevice device, 
  VkSwapchainKHR swapchain, 
  uint * p_swapchain_image_count, 
  VkImage * p_swapchain_images)
@extern("vkGetSwapchainImagesKHR");

fn VkResult acquire_next_image_khr(
  VkDevice device, 
  VkSwapchainKHR swapchain, 
  ulong timeout, 
  VkSemaphore semaphore, 
  VkFence fence, 
  uint * p_image_index)
@extern("vkAcquireNextImageKHR");

fn VkResult queue_present_khr(
  VkQueue queue, 
  VkPresentInfoKHR * p_present_info)
@extern("vkQueuePresentKHR");

fn VkResult get_device_group_present_capabilities_khr(
  VkDevice device, 
  VkDeviceGroupPresentCapabilitiesKHR * p_device_group_present_capabilities)
@extern("vkGetDeviceGroupPresentCapabilitiesKHR");

fn VkResult get_device_group_surface_present_modes_khr(
  VkDevice device, 
  VkSurfaceKHR surface, 
  VkDeviceGroupPresentModeFlagsKHR * p_modes)
@extern("vkGetDeviceGroupSurfacePresentModesKHR");

fn VkResult get_physical_device_present_rectangles_khr(
  VkPhysicalDevice physical_device, 
  VkSurfaceKHR surface, 
  uint * p_rect_count, 
  VkRect2D * p_rects)
@extern("vkGetPhysicalDevicePresentRectanglesKHR");

fn VkResult acquire_next_image_2_khr(
  VkDevice device, 
  VkAcquireNextImageInfoKHR * p_acquire_info, 
  uint * p_image_index)
@extern("vkAcquireNextImage2KHR");

typedef VkDisplayKHR_T = void;

alias VkDisplayKHR = VkDisplayKHR_T *;

typedef VkDisplayModeKHR_T = void;

alias VkDisplayModeKHR = VkDisplayModeKHR_T *;

typedef VkDisplayPlaneAlphaFlagBitsKHR = inline CUInt;
const VkDisplayPlaneAlphaFlagBitsKHR DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR = 0x00000001;
const VkDisplayPlaneAlphaFlagBitsKHR DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR = 0x00000002;
const VkDisplayPlaneAlphaFlagBitsKHR DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR = 0x00000004;
const VkDisplayPlaneAlphaFlagBitsKHR DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR = 0x00000008;
const VkDisplayPlaneAlphaFlagBitsKHR DISPLAY_PLANE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF;

alias VkDisplayPlaneAlphaFlagsKHR = VkFlags;

alias VkDisplayModeCreateFlagsKHR = VkFlags;

alias VkDisplaySurfaceCreateFlagsKHR = VkFlags;

struct VkDisplayPropertiesKHR {
  VkDisplayKHR display;
  CChar * display_name;
  VkExtent2D physical_dimensions;
  VkExtent2D physical_resolution;
  VkSurfaceTransformFlagsKHR supported_transforms;
  VkBool32 plane_reorder_possible;
  VkBool32 persistent_content;
}

struct VkDisplayModeParametersKHR {
  VkExtent2D visible_region;
  uint refresh_rate;
}

struct VkDisplayModePropertiesKHR {
  VkDisplayModeKHR display_mode;
  VkDisplayModeParametersKHR parameters;
}

struct VkDisplayModeCreateInfoKHR {
  VkStructureType s_type;
  void * p_next;
  VkDisplayModeCreateFlagsKHR flags;
  VkDisplayModeParametersKHR parameters;
}

struct VkDisplayPlaneCapabilitiesKHR {
  VkDisplayPlaneAlphaFlagsKHR supported_alpha;
  VkOffset2D min_src_position;
  VkOffset2D max_src_position;
  VkExtent2D min_src_extent;
  VkExtent2D max_src_extent;
  VkOffset2D min_dst_position;
  VkOffset2D max_dst_position;
  VkExtent2D min_dst_extent;
  VkExtent2D max_dst_extent;
}

struct VkDisplayPlanePropertiesKHR {
  VkDisplayKHR current_display;
  uint current_stack_index;
}

struct VkDisplaySurfaceCreateInfoKHR {
  VkStructureType s_type;
  void * p_next;
  VkDisplaySurfaceCreateFlagsKHR flags;
  VkDisplayModeKHR display_mode;
  uint plane_index;
  uint plane_stack_index;
  VkSurfaceTransformFlagBitsKHR transform;
  float global_alpha;
  VkDisplayPlaneAlphaFlagBitsKHR alpha_mode;
  VkExtent2D image_extent;
}

alias PFN_vkGetPhysicalDeviceDisplayPropertiesKHR = fn VkResult(
  VkPhysicalDevice physical_device, 
  uint * p_property_count, 
  VkDisplayPropertiesKHR * p_properties);

alias PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR = fn VkResult(
  VkPhysicalDevice physical_device, 
  uint * p_property_count, 
  VkDisplayPlanePropertiesKHR * p_properties);

alias PFN_vkGetDisplayPlaneSupportedDisplaysKHR = fn VkResult(
  VkPhysicalDevice physical_device, 
  uint plane_index, 
  uint * p_display_count, 
  VkDisplayKHR * p_displays);

alias PFN_vkGetDisplayModePropertiesKHR = fn VkResult(
  VkPhysicalDevice physical_device, 
  VkDisplayKHR display, 
  uint * p_property_count, 
  VkDisplayModePropertiesKHR * p_properties);

alias PFN_vkCreateDisplayModeKHR = fn VkResult(
  VkPhysicalDevice physical_device, 
  VkDisplayKHR display, 
  VkDisplayModeCreateInfoKHR * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkDisplayModeKHR * p_mode);

alias PFN_vkGetDisplayPlaneCapabilitiesKHR = fn VkResult(
  VkPhysicalDevice physical_device, 
  VkDisplayModeKHR mode, 
  uint plane_index, 
  VkDisplayPlaneCapabilitiesKHR * p_capabilities);

alias PFN_vkCreateDisplayPlaneSurfaceKHR = fn VkResult(
  VkInstance instance, 
  VkDisplaySurfaceCreateInfoKHR * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkSurfaceKHR * p_surface);

fn VkResult get_physical_device_display_properties_khr(
  VkPhysicalDevice physical_device, 
  uint * p_property_count, 
  VkDisplayPropertiesKHR * p_properties)
@extern("vkGetPhysicalDeviceDisplayPropertiesKHR");

fn VkResult get_physical_device_display_plane_properties_khr(
  VkPhysicalDevice physical_device, 
  uint * p_property_count, 
  VkDisplayPlanePropertiesKHR * p_properties)
@extern("vkGetPhysicalDeviceDisplayPlanePropertiesKHR");

fn VkResult get_display_plane_supported_displays_khr(
  VkPhysicalDevice physical_device, 
  uint plane_index, 
  uint * p_display_count, 
  VkDisplayKHR * p_displays)
@extern("vkGetDisplayPlaneSupportedDisplaysKHR");

fn VkResult get_display_mode_properties_khr(
  VkPhysicalDevice physical_device, 
  VkDisplayKHR display, 
  uint * p_property_count, 
  VkDisplayModePropertiesKHR * p_properties)
@extern("vkGetDisplayModePropertiesKHR");

fn VkResult create_display_mode_khr(
  VkPhysicalDevice physical_device, 
  VkDisplayKHR display, 
  VkDisplayModeCreateInfoKHR * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkDisplayModeKHR * p_mode)
@extern("vkCreateDisplayModeKHR");

fn VkResult get_display_plane_capabilities_khr(
  VkPhysicalDevice physical_device, 
  VkDisplayModeKHR mode, 
  uint plane_index, 
  VkDisplayPlaneCapabilitiesKHR * p_capabilities)
@extern("vkGetDisplayPlaneCapabilitiesKHR");

fn VkResult create_display_plane_surface_khr(
  VkInstance instance, 
  VkDisplaySurfaceCreateInfoKHR * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkSurfaceKHR * p_surface)
@extern("vkCreateDisplayPlaneSurfaceKHR");

struct VkDisplayPresentInfoKHR {
  VkStructureType s_type;
  void * p_next;
  VkRect2D src_rect;
  VkRect2D dst_rect;
  VkBool32 persistent;
}

alias PFN_vkCreateSharedSwapchainsKHR = fn VkResult(
  VkDevice device, 
  uint swapchain_count, 
  VkSwapchainCreateInfoKHR * p_create_infos, 
  VkAllocationCallbacks * p_allocator, 
  VkSwapchainKHR * p_swapchains);

fn VkResult create_shared_swapchains_khr(
  VkDevice device, 
  uint swapchain_count, 
  VkSwapchainCreateInfoKHR * p_create_infos, 
  VkAllocationCallbacks * p_allocator, 
  VkSwapchainKHR * p_swapchains)
@extern("vkCreateSharedSwapchainsKHR");

alias VkRenderPassMultiviewCreateInfoKHR = VkRenderPassMultiviewCreateInfo;

alias VkPhysicalDeviceMultiviewFeaturesKHR = VkPhysicalDeviceMultiviewFeatures;

alias VkPhysicalDeviceMultiviewPropertiesKHR = VkPhysicalDeviceMultiviewProperties;

alias VkPhysicalDeviceFeatures2KHR = VkPhysicalDeviceFeatures2;

alias VkPhysicalDeviceProperties2KHR = VkPhysicalDeviceProperties2;

alias VkFormatProperties2KHR = VkFormatProperties2;

alias VkImageFormatProperties2KHR = VkImageFormatProperties2;

alias VkPhysicalDeviceImageFormatInfo2KHR = VkPhysicalDeviceImageFormatInfo2;

alias VkQueueFamilyProperties2KHR = VkQueueFamilyProperties2;

alias VkPhysicalDeviceMemoryProperties2KHR = VkPhysicalDeviceMemoryProperties2;

alias VkSparseImageFormatProperties2KHR = VkSparseImageFormatProperties2;

alias VkPhysicalDeviceSparseImageFormatInfo2KHR = VkPhysicalDeviceSparseImageFormatInfo2;

alias PFN_vkGetPhysicalDeviceFeatures2KHR = fn void(
  VkPhysicalDevice physical_device, 
  VkPhysicalDeviceFeatures2 * p_features);

alias PFN_vkGetPhysicalDeviceProperties2KHR = fn void(
  VkPhysicalDevice physical_device, 
  VkPhysicalDeviceProperties2 * p_properties);

alias PFN_vkGetPhysicalDeviceFormatProperties2KHR = fn void(
  VkPhysicalDevice physical_device, 
  VkFormat format, 
  VkFormatProperties2 * p_format_properties);

alias PFN_vkGetPhysicalDeviceImageFormatProperties2KHR = fn VkResult(
  VkPhysicalDevice physical_device, 
  VkPhysicalDeviceImageFormatInfo2 * p_image_format_info, 
  VkImageFormatProperties2 * p_image_format_properties);

alias PFN_vkGetPhysicalDeviceQueueFamilyProperties2KHR = fn void(
  VkPhysicalDevice physical_device, 
  uint * p_queue_family_property_count, 
  VkQueueFamilyProperties2 * p_queue_family_properties);

alias PFN_vkGetPhysicalDeviceMemoryProperties2KHR = fn void(
  VkPhysicalDevice physical_device, 
  VkPhysicalDeviceMemoryProperties2 * p_memory_properties);

alias PFN_vkGetPhysicalDeviceSparseImageFormatProperties2KHR = fn void(
  VkPhysicalDevice physical_device, 
  VkPhysicalDeviceSparseImageFormatInfo2 * p_format_info, 
  uint * p_property_count, 
  VkSparseImageFormatProperties2 * p_properties);

fn void get_physical_device_features_2_khr(
  VkPhysicalDevice physical_device, 
  VkPhysicalDeviceFeatures2 * p_features)
@extern("vkGetPhysicalDeviceFeatures2KHR");

fn void get_physical_device_properties_2_khr(
  VkPhysicalDevice physical_device, 
  VkPhysicalDeviceProperties2 * p_properties)
@extern("vkGetPhysicalDeviceProperties2KHR");

fn void get_physical_device_format_properties_2_khr(
  VkPhysicalDevice physical_device, 
  VkFormat format, 
  VkFormatProperties2 * p_format_properties)
@extern("vkGetPhysicalDeviceFormatProperties2KHR");

fn VkResult get_physical_device_image_format_properties_2_khr(
  VkPhysicalDevice physical_device, 
  VkPhysicalDeviceImageFormatInfo2 * p_image_format_info, 
  VkImageFormatProperties2 * p_image_format_properties)
@extern("vkGetPhysicalDeviceImageFormatProperties2KHR");

fn void get_physical_device_queue_family_properties_2_khr(
  VkPhysicalDevice physical_device, 
  uint * p_queue_family_property_count, 
  VkQueueFamilyProperties2 * p_queue_family_properties)
@extern("vkGetPhysicalDeviceQueueFamilyProperties2KHR");

fn void get_physical_device_memory_properties_2_khr(
  VkPhysicalDevice physical_device, 
  VkPhysicalDeviceMemoryProperties2 * p_memory_properties)
@extern("vkGetPhysicalDeviceMemoryProperties2KHR");

fn void get_physical_device_sparse_image_format_properties_2_khr(
  VkPhysicalDevice physical_device, 
  VkPhysicalDeviceSparseImageFormatInfo2 * p_format_info, 
  uint * p_property_count, 
  VkSparseImageFormatProperties2 * p_properties)
@extern("vkGetPhysicalDeviceSparseImageFormatProperties2KHR");

alias VkPeerMemoryFeatureFlagsKHR = VkPeerMemoryFeatureFlags;

alias VkPeerMemoryFeatureFlagBitsKHR = VkPeerMemoryFeatureFlagBits;

alias VkMemoryAllocateFlagsKHR = VkMemoryAllocateFlags;

alias VkMemoryAllocateFlagBitsKHR = VkMemoryAllocateFlagBits;

alias VkMemoryAllocateFlagsInfoKHR = VkMemoryAllocateFlagsInfo;

alias VkDeviceGroupRenderPassBeginInfoKHR = VkDeviceGroupRenderPassBeginInfo;

alias VkDeviceGroupCommandBufferBeginInfoKHR = VkDeviceGroupCommandBufferBeginInfo;

alias VkDeviceGroupSubmitInfoKHR = VkDeviceGroupSubmitInfo;

alias VkDeviceGroupBindSparseInfoKHR = VkDeviceGroupBindSparseInfo;

alias VkBindBufferMemoryDeviceGroupInfoKHR = VkBindBufferMemoryDeviceGroupInfo;

alias VkBindImageMemoryDeviceGroupInfoKHR = VkBindImageMemoryDeviceGroupInfo;

alias PFN_vkGetDeviceGroupPeerMemoryFeaturesKHR = fn void(
  VkDevice device, 
  uint heap_index, 
  uint local_device_index, 
  uint remote_device_index, 
  VkPeerMemoryFeatureFlags * p_peer_memory_features);

alias PFN_vkCmdSetDeviceMaskKHR = fn void(
  VkCommandBuffer command_buffer, 
  uint device_mask);

alias PFN_vkCmdDispatchBaseKHR = fn void(
  VkCommandBuffer command_buffer, 
  uint base_group_x, 
  uint base_group_y, 
  uint base_group_z, 
  uint group_count_x, 
  uint group_count_y, 
  uint group_count_z);

fn void get_device_group_peer_memory_features_khr(
  VkDevice device, 
  uint heap_index, 
  uint local_device_index, 
  uint remote_device_index, 
  VkPeerMemoryFeatureFlags * p_peer_memory_features)
@extern("vkGetDeviceGroupPeerMemoryFeaturesKHR");

fn void cmd_set_device_mask_khr(
  VkCommandBuffer command_buffer, 
  uint device_mask)
@extern("vkCmdSetDeviceMaskKHR");

fn void cmd_dispatch_base_khr(
  VkCommandBuffer command_buffer, 
  uint base_group_x, 
  uint base_group_y, 
  uint base_group_z, 
  uint group_count_x, 
  uint group_count_y, 
  uint group_count_z)
@extern("vkCmdDispatchBaseKHR");

alias VkCommandPoolTrimFlagsKHR = VkCommandPoolTrimFlags;

alias PFN_vkTrimCommandPoolKHR = fn void(
  VkDevice device, 
  VkCommandPool command_pool, 
  VkCommandPoolTrimFlags flags);

fn void trim_command_pool_khr(
  VkDevice device, 
  VkCommandPool command_pool, 
  VkCommandPoolTrimFlags flags)
@extern("vkTrimCommandPoolKHR");

alias VkPhysicalDeviceGroupPropertiesKHR = VkPhysicalDeviceGroupProperties;

alias VkDeviceGroupDeviceCreateInfoKHR = VkDeviceGroupDeviceCreateInfo;

alias PFN_vkEnumeratePhysicalDeviceGroupsKHR = fn VkResult(
  VkInstance instance, 
  uint * p_physical_device_group_count, 
  VkPhysicalDeviceGroupProperties * p_physical_device_group_properties);

fn VkResult enumerate_physical_device_groups_khr(
  VkInstance instance, 
  uint * p_physical_device_group_count, 
  VkPhysicalDeviceGroupProperties * p_physical_device_group_properties)
@extern("vkEnumeratePhysicalDeviceGroupsKHR");

alias VkExternalMemoryHandleTypeFlagsKHR = VkExternalMemoryHandleTypeFlags;

alias VkExternalMemoryHandleTypeFlagBitsKHR = VkExternalMemoryHandleTypeFlagBits;

alias VkExternalMemoryFeatureFlagsKHR = VkExternalMemoryFeatureFlags;

alias VkExternalMemoryFeatureFlagBitsKHR = VkExternalMemoryFeatureFlagBits;

alias VkExternalMemoryPropertiesKHR = VkExternalMemoryProperties;

alias VkPhysicalDeviceExternalImageFormatInfoKHR = VkPhysicalDeviceExternalImageFormatInfo;

alias VkExternalImageFormatPropertiesKHR = VkExternalImageFormatProperties;

alias VkPhysicalDeviceExternalBufferInfoKHR = VkPhysicalDeviceExternalBufferInfo;

alias VkExternalBufferPropertiesKHR = VkExternalBufferProperties;

alias VkPhysicalDeviceIDPropertiesKHR = VkPhysicalDeviceIDProperties;

alias PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR = fn void(
  VkPhysicalDevice physical_device, 
  VkPhysicalDeviceExternalBufferInfo * p_external_buffer_info, 
  VkExternalBufferProperties * p_external_buffer_properties);

fn void get_physical_device_external_buffer_properties_khr(
  VkPhysicalDevice physical_device, 
  VkPhysicalDeviceExternalBufferInfo * p_external_buffer_info, 
  VkExternalBufferProperties * p_external_buffer_properties)
@extern("vkGetPhysicalDeviceExternalBufferPropertiesKHR");

alias VkExternalMemoryImageCreateInfoKHR = VkExternalMemoryImageCreateInfo;

alias VkExternalMemoryBufferCreateInfoKHR = VkExternalMemoryBufferCreateInfo;

alias VkExportMemoryAllocateInfoKHR = VkExportMemoryAllocateInfo;

struct VkImportMemoryFdInfoKHR {
  VkStructureType s_type;
  void * p_next;
  VkExternalMemoryHandleTypeFlagBits handle_type;
  CInt fd;
}

struct VkMemoryFdPropertiesKHR {
  VkStructureType s_type;
  void * p_next;
  uint memory_type_bits;
}

struct VkMemoryGetFdInfoKHR {
  VkStructureType s_type;
  void * p_next;
  VkDeviceMemory memory;
  VkExternalMemoryHandleTypeFlagBits handle_type;
}

alias PFN_vkGetMemoryFdKHR = fn VkResult(
  VkDevice device, 
  VkMemoryGetFdInfoKHR * p_get_fd_info, 
  CInt * p_fd);

alias PFN_vkGetMemoryFdPropertiesKHR = fn VkResult(
  VkDevice device, 
  VkExternalMemoryHandleTypeFlagBits handle_type, 
  CInt fd, 
  VkMemoryFdPropertiesKHR * p_memory_fd_properties);

fn VkResult get_memory_fd_khr(
  VkDevice device, 
  VkMemoryGetFdInfoKHR * p_get_fd_info, 
  CInt * p_fd)
@extern("vkGetMemoryFdKHR");

fn VkResult get_memory_fd_properties_khr(
  VkDevice device, 
  VkExternalMemoryHandleTypeFlagBits handle_type, 
  CInt fd, 
  VkMemoryFdPropertiesKHR * p_memory_fd_properties)
@extern("vkGetMemoryFdPropertiesKHR");

alias VkExternalSemaphoreHandleTypeFlagsKHR = VkExternalSemaphoreHandleTypeFlags;

alias VkExternalSemaphoreHandleTypeFlagBitsKHR = VkExternalSemaphoreHandleTypeFlagBits;

alias VkExternalSemaphoreFeatureFlagsKHR = VkExternalSemaphoreFeatureFlags;

alias VkExternalSemaphoreFeatureFlagBitsKHR = VkExternalSemaphoreFeatureFlagBits;

alias VkPhysicalDeviceExternalSemaphoreInfoKHR = VkPhysicalDeviceExternalSemaphoreInfo;

alias VkExternalSemaphorePropertiesKHR = VkExternalSemaphoreProperties;

alias PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR = fn void(
  VkPhysicalDevice physical_device, 
  VkPhysicalDeviceExternalSemaphoreInfo * p_external_semaphore_info, 
  VkExternalSemaphoreProperties * p_external_semaphore_properties);

fn void get_physical_device_external_semaphore_properties_khr(
  VkPhysicalDevice physical_device, 
  VkPhysicalDeviceExternalSemaphoreInfo * p_external_semaphore_info, 
  VkExternalSemaphoreProperties * p_external_semaphore_properties)
@extern("vkGetPhysicalDeviceExternalSemaphorePropertiesKHR");

alias VkSemaphoreImportFlagsKHR = VkSemaphoreImportFlags;

alias VkSemaphoreImportFlagBitsKHR = VkSemaphoreImportFlagBits;

alias VkExportSemaphoreCreateInfoKHR = VkExportSemaphoreCreateInfo;

struct VkImportSemaphoreFdInfoKHR {
  VkStructureType s_type;
  void * p_next;
  VkSemaphore semaphore;
  VkSemaphoreImportFlags flags;
  VkExternalSemaphoreHandleTypeFlagBits handle_type;
  CInt fd;
}

struct VkSemaphoreGetFdInfoKHR {
  VkStructureType s_type;
  void * p_next;
  VkSemaphore semaphore;
  VkExternalSemaphoreHandleTypeFlagBits handle_type;
}

alias PFN_vkImportSemaphoreFdKHR = fn VkResult(
  VkDevice device, 
  VkImportSemaphoreFdInfoKHR * p_import_semaphore_fd_info);

alias PFN_vkGetSemaphoreFdKHR = fn VkResult(
  VkDevice device, 
  VkSemaphoreGetFdInfoKHR * p_get_fd_info, 
  CInt * p_fd);

fn VkResult import_semaphore_fd_khr(
  VkDevice device, 
  VkImportSemaphoreFdInfoKHR * p_import_semaphore_fd_info)
@extern("vkImportSemaphoreFdKHR");

fn VkResult get_semaphore_fd_khr(
  VkDevice device, 
  VkSemaphoreGetFdInfoKHR * p_get_fd_info, 
  CInt * p_fd)
@extern("vkGetSemaphoreFdKHR");

struct VkPhysicalDevicePushDescriptorPropertiesKHR {
  VkStructureType s_type;
  void * p_next;
  uint max_push_descriptors;
}

alias PFN_vkCmdPushDescriptorSetKHR = fn void(
  VkCommandBuffer command_buffer, 
  VkPipelineBindPoint pipeline_bind_point, 
  VkPipelineLayout layout, 
  uint set, 
  uint descriptor_write_count, 
  VkWriteDescriptorSet * p_descriptor_writes);

alias PFN_vkCmdPushDescriptorSetWithTemplateKHR = fn void(
  VkCommandBuffer command_buffer, 
  VkDescriptorUpdateTemplate descriptor_update_template, 
  VkPipelineLayout layout, 
  uint set, 
  void * p_data);

fn void cmd_push_descriptor_set_khr(
  VkCommandBuffer command_buffer, 
  VkPipelineBindPoint pipeline_bind_point, 
  VkPipelineLayout layout, 
  uint set, 
  uint descriptor_write_count, 
  VkWriteDescriptorSet * p_descriptor_writes)
@extern("vkCmdPushDescriptorSetKHR");

fn void cmd_push_descriptor_set_with_template_khr(
  VkCommandBuffer command_buffer, 
  VkDescriptorUpdateTemplate descriptor_update_template, 
  VkPipelineLayout layout, 
  uint set, 
  void * p_data)
@extern("vkCmdPushDescriptorSetWithTemplateKHR");

struct VkPhysicalDeviceShaderFloat16Int8FeaturesKHR {
  VkStructureType s_type;
  void * p_next;
  VkBool32 shader_float_16;
  VkBool32 shader_int_8;
}

alias VkPhysicalDeviceFloat16Int8FeaturesKHR = VkPhysicalDeviceShaderFloat16Int8FeaturesKHR;

alias VkPhysicalDevice16BitStorageFeaturesKHR = VkPhysicalDevice16BitStorageFeatures;

struct VkRectLayerKHR {
  VkOffset2D offset;
  VkExtent2D extent;
  uint layer;
}

struct VkPresentRegionKHR {
  uint rectangle_count;
  VkRectLayerKHR * p_rectangles;
}

struct VkPresentRegionsKHR {
  VkStructureType s_type;
  void * p_next;
  uint swapchain_count;
  VkPresentRegionKHR * p_regions;
}

alias VkDescriptorUpdateTemplateKHR = VkDescriptorUpdateTemplate;

alias VkDescriptorUpdateTemplateTypeKHR = VkDescriptorUpdateTemplateType;

alias VkDescriptorUpdateTemplateCreateFlagsKHR = VkDescriptorUpdateTemplateCreateFlags;

alias VkDescriptorUpdateTemplateEntryKHR = VkDescriptorUpdateTemplateEntry;

alias VkDescriptorUpdateTemplateCreateInfoKHR = VkDescriptorUpdateTemplateCreateInfo;

alias PFN_vkCreateDescriptorUpdateTemplateKHR = fn VkResult(
  VkDevice device, 
  VkDescriptorUpdateTemplateCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkDescriptorUpdateTemplate * p_descriptor_update_template);

alias PFN_vkDestroyDescriptorUpdateTemplateKHR = fn void(
  VkDevice device, 
  VkDescriptorUpdateTemplate descriptor_update_template, 
  VkAllocationCallbacks * p_allocator);

alias PFN_vkUpdateDescriptorSetWithTemplateKHR = fn void(
  VkDevice device, 
  VkDescriptorSet descriptor_set, 
  VkDescriptorUpdateTemplate descriptor_update_template, 
  void * p_data);

fn VkResult create_descriptor_update_template_khr(
  VkDevice device, 
  VkDescriptorUpdateTemplateCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkDescriptorUpdateTemplate * p_descriptor_update_template)
@extern("vkCreateDescriptorUpdateTemplateKHR");

fn void destroy_descriptor_update_template_khr(
  VkDevice device, 
  VkDescriptorUpdateTemplate descriptor_update_template, 
  VkAllocationCallbacks * p_allocator)
@extern("vkDestroyDescriptorUpdateTemplateKHR");

fn void update_descriptor_set_with_template_khr(
  VkDevice device, 
  VkDescriptorSet descriptor_set, 
  VkDescriptorUpdateTemplate descriptor_update_template, 
  void * p_data)
@extern("vkUpdateDescriptorSetWithTemplateKHR");

struct VkPhysicalDeviceImagelessFramebufferFeaturesKHR {
  VkStructureType s_type;
  void * p_next;
  VkBool32 imageless_framebuffer;
}

struct VkFramebufferAttachmentImageInfoKHR {
  VkStructureType s_type;
  void * p_next;
  VkImageCreateFlags flags;
  VkImageUsageFlags usage;
  uint width;
  uint height;
  uint layer_count;
  uint view_format_count;
  VkFormat * p_view_formats;
}

struct VkFramebufferAttachmentsCreateInfoKHR {
  VkStructureType s_type;
  void * p_next;
  uint attachment_image_info_count;
  VkFramebufferAttachmentImageInfoKHR * p_attachment_image_infos;
}

struct VkRenderPassAttachmentBeginInfoKHR {
  VkStructureType s_type;
  void * p_next;
  uint attachment_count;
  VkImageView * p_attachments;
}

struct VkAttachmentDescription2KHR {
  VkStructureType s_type;
  void * p_next;
  VkAttachmentDescriptionFlags flags;
  VkFormat format;
  VkSampleCountFlagBits samples;
  VkAttachmentLoadOp load_op;
  VkAttachmentStoreOp store_op;
  VkAttachmentLoadOp stencil_load_op;
  VkAttachmentStoreOp stencil_store_op;
  VkImageLayout initial_layout;
  VkImageLayout final_layout;
}

struct VkAttachmentReference2KHR {
  VkStructureType s_type;
  void * p_next;
  uint attachment;
  VkImageLayout layout;
  VkImageAspectFlags aspect_mask;
}

struct VkSubpassDescription2KHR {
  VkStructureType s_type;
  void * p_next;
  VkSubpassDescriptionFlags flags;
  VkPipelineBindPoint pipeline_bind_point;
  uint view_mask;
  uint input_attachment_count;
  VkAttachmentReference2KHR * p_input_attachments;
  uint color_attachment_count;
  VkAttachmentReference2KHR * p_color_attachments;
  VkAttachmentReference2KHR * p_resolve_attachments;
  VkAttachmentReference2KHR * p_depth_stencil_attachment;
  uint preserve_attachment_count;
  uint * p_preserve_attachments;
}

struct VkSubpassDependency2KHR {
  VkStructureType s_type;
  void * p_next;
  uint src_subpass;
  uint dst_subpass;
  VkPipelineStageFlags src_stage_mask;
  VkPipelineStageFlags dst_stage_mask;
  VkAccessFlags src_access_mask;
  VkAccessFlags dst_access_mask;
  VkDependencyFlags dependency_flags;
  int view_offset;
}

struct VkRenderPassCreateInfo2KHR {
  VkStructureType s_type;
  void * p_next;
  VkRenderPassCreateFlags flags;
  uint attachment_count;
  VkAttachmentDescription2KHR * p_attachments;
  uint subpass_count;
  VkSubpassDescription2KHR * p_subpasses;
  uint dependency_count;
  VkSubpassDependency2KHR * p_dependencies;
  uint correlated_view_mask_count;
  uint * p_correlated_view_masks;
}

struct VkSubpassBeginInfoKHR {
  VkStructureType s_type;
  void * p_next;
  VkSubpassContents contents;
}

struct VkSubpassEndInfoKHR {
  VkStructureType s_type;
  void * p_next;
}

alias PFN_vkCreateRenderPass2KHR = fn VkResult(
  VkDevice device, 
  VkRenderPassCreateInfo2KHR * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkRenderPass * p_render_pass);

alias PFN_vkCmdBeginRenderPass2KHR = fn void(
  VkCommandBuffer command_buffer, 
  VkRenderPassBeginInfo * p_render_pass_begin, 
  VkSubpassBeginInfoKHR * p_subpass_begin_info);

alias PFN_vkCmdNextSubpass2KHR = fn void(
  VkCommandBuffer command_buffer, 
  VkSubpassBeginInfoKHR * p_subpass_begin_info, 
  VkSubpassEndInfoKHR * p_subpass_end_info);

alias PFN_vkCmdEndRenderPass2KHR = fn void(
  VkCommandBuffer command_buffer, 
  VkSubpassEndInfoKHR * p_subpass_end_info);

fn VkResult create_render_pass_2_khr(
  VkDevice device, 
  VkRenderPassCreateInfo2KHR * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkRenderPass * p_render_pass)
@extern("vkCreateRenderPass2KHR");

fn void cmd_begin_render_pass_2_khr(
  VkCommandBuffer command_buffer, 
  VkRenderPassBeginInfo * p_render_pass_begin, 
  VkSubpassBeginInfoKHR * p_subpass_begin_info)
@extern("vkCmdBeginRenderPass2KHR");

fn void cmd_next_subpass_2_khr(
  VkCommandBuffer command_buffer, 
  VkSubpassBeginInfoKHR * p_subpass_begin_info, 
  VkSubpassEndInfoKHR * p_subpass_end_info)
@extern("vkCmdNextSubpass2KHR");

fn void cmd_end_render_pass_2_khr(
  VkCommandBuffer command_buffer, 
  VkSubpassEndInfoKHR * p_subpass_end_info)
@extern("vkCmdEndRenderPass2KHR");

struct VkSharedPresentSurfaceCapabilitiesKHR {
  VkStructureType s_type;
  void * p_next;
  VkImageUsageFlags shared_present_supported_usage_flags;
}

alias PFN_vkGetSwapchainStatusKHR = fn VkResult(
  VkDevice device, 
  VkSwapchainKHR swapchain);

fn VkResult get_swapchain_status_khr(
  VkDevice device, 
  VkSwapchainKHR swapchain)
@extern("vkGetSwapchainStatusKHR");

alias VkExternalFenceHandleTypeFlagsKHR = VkExternalFenceHandleTypeFlags;

alias VkExternalFenceHandleTypeFlagBitsKHR = VkExternalFenceHandleTypeFlagBits;

alias VkExternalFenceFeatureFlagsKHR = VkExternalFenceFeatureFlags;

alias VkExternalFenceFeatureFlagBitsKHR = VkExternalFenceFeatureFlagBits;

alias VkPhysicalDeviceExternalFenceInfoKHR = VkPhysicalDeviceExternalFenceInfo;

alias VkExternalFencePropertiesKHR = VkExternalFenceProperties;

alias PFN_vkGetPhysicalDeviceExternalFencePropertiesKHR = fn void(
  VkPhysicalDevice physical_device, 
  VkPhysicalDeviceExternalFenceInfo * p_external_fence_info, 
  VkExternalFenceProperties * p_external_fence_properties);

fn void get_physical_device_external_fence_properties_khr(
  VkPhysicalDevice physical_device, 
  VkPhysicalDeviceExternalFenceInfo * p_external_fence_info, 
  VkExternalFenceProperties * p_external_fence_properties)
@extern("vkGetPhysicalDeviceExternalFencePropertiesKHR");

alias VkFenceImportFlagsKHR = VkFenceImportFlags;

alias VkFenceImportFlagBitsKHR = VkFenceImportFlagBits;

alias VkExportFenceCreateInfoKHR = VkExportFenceCreateInfo;

struct VkImportFenceFdInfoKHR {
  VkStructureType s_type;
  void * p_next;
  VkFence fence;
  VkFenceImportFlags flags;
  VkExternalFenceHandleTypeFlagBits handle_type;
  CInt fd;
}

struct VkFenceGetFdInfoKHR {
  VkStructureType s_type;
  void * p_next;
  VkFence fence;
  VkExternalFenceHandleTypeFlagBits handle_type;
}

alias PFN_vkImportFenceFdKHR = fn VkResult(
  VkDevice device, 
  VkImportFenceFdInfoKHR * p_import_fence_fd_info);

alias PFN_vkGetFenceFdKHR = fn VkResult(
  VkDevice device, 
  VkFenceGetFdInfoKHR * p_get_fd_info, 
  CInt * p_fd);

fn VkResult import_fence_fd_khr(
  VkDevice device, 
  VkImportFenceFdInfoKHR * p_import_fence_fd_info)
@extern("vkImportFenceFdKHR");

fn VkResult get_fence_fd_khr(
  VkDevice device, 
  VkFenceGetFdInfoKHR * p_get_fd_info, 
  CInt * p_fd)
@extern("vkGetFenceFdKHR");

typedef VkPerformanceCounterUnitKHR = inline CUInt;
const VkPerformanceCounterUnitKHR PERFORMANCE_COUNTER_UNIT_GENERIC_KHR = 0;
const VkPerformanceCounterUnitKHR PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR = 1;
const VkPerformanceCounterUnitKHR PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR = 2;
const VkPerformanceCounterUnitKHR PERFORMANCE_COUNTER_UNIT_BYTES_KHR = 3;
const VkPerformanceCounterUnitKHR PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR = 4;
const VkPerformanceCounterUnitKHR PERFORMANCE_COUNTER_UNIT_KELVIN_KHR = 5;
const VkPerformanceCounterUnitKHR PERFORMANCE_COUNTER_UNIT_WATTS_KHR = 6;
const VkPerformanceCounterUnitKHR PERFORMANCE_COUNTER_UNIT_VOLTS_KHR = 7;
const VkPerformanceCounterUnitKHR PERFORMANCE_COUNTER_UNIT_AMPS_KHR = 8;
const VkPerformanceCounterUnitKHR PERFORMANCE_COUNTER_UNIT_HERTZ_KHR = 9;
const VkPerformanceCounterUnitKHR PERFORMANCE_COUNTER_UNIT_CYCLES_KHR = 10;
const VkPerformanceCounterUnitKHR PERFORMANCE_COUNTER_UNIT_BEGIN_RANGE_KHR = PERFORMANCE_COUNTER_UNIT_GENERIC_KHR;
const VkPerformanceCounterUnitKHR PERFORMANCE_COUNTER_UNIT_END_RANGE_KHR = PERFORMANCE_COUNTER_UNIT_CYCLES_KHR;
const VkPerformanceCounterUnitKHR PERFORMANCE_COUNTER_UNIT_RANGE_SIZE_KHR = (PERFORMANCE_COUNTER_UNIT_CYCLES_KHR-PERFORMANCE_COUNTER_UNIT_GENERIC_KHR+1);
const VkPerformanceCounterUnitKHR PERFORMANCE_COUNTER_UNIT_MAX_ENUM_KHR = 0x7FFFFFFF;

typedef VkPerformanceCounterScopeKHR = inline CUInt;
const VkPerformanceCounterScopeKHR QUERY_SCOPE_COMMAND_BUFFER_KHR = 0;
const VkPerformanceCounterScopeKHR QUERY_SCOPE_RENDER_PASS_KHR = 1;
const VkPerformanceCounterScopeKHR QUERY_SCOPE_COMMAND_KHR = 2;
const VkPerformanceCounterScopeKHR PERFORMANCE_COUNTER_SCOPE_BEGIN_RANGE_KHR = QUERY_SCOPE_COMMAND_BUFFER_KHR;
const VkPerformanceCounterScopeKHR PERFORMANCE_COUNTER_SCOPE_END_RANGE_KHR = QUERY_SCOPE_COMMAND_KHR;
const VkPerformanceCounterScopeKHR PERFORMANCE_COUNTER_SCOPE_RANGE_SIZE_KHR = (QUERY_SCOPE_COMMAND_KHR-QUERY_SCOPE_COMMAND_BUFFER_KHR+1);
const VkPerformanceCounterScopeKHR PERFORMANCE_COUNTER_SCOPE_MAX_ENUM_KHR = 0x7FFFFFFF;

typedef VkPerformanceCounterStorageKHR = inline CUInt;
const VkPerformanceCounterStorageKHR PERFORMANCE_COUNTER_STORAGE_INT32_KHR = 0;
const VkPerformanceCounterStorageKHR PERFORMANCE_COUNTER_STORAGE_INT64_KHR = 1;
const VkPerformanceCounterStorageKHR PERFORMANCE_COUNTER_STORAGE_UINT32_KHR = 2;
const VkPerformanceCounterStorageKHR PERFORMANCE_COUNTER_STORAGE_UINT64_KHR = 3;
const VkPerformanceCounterStorageKHR PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR = 4;
const VkPerformanceCounterStorageKHR PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR = 5;
const VkPerformanceCounterStorageKHR PERFORMANCE_COUNTER_STORAGE_BEGIN_RANGE_KHR = PERFORMANCE_COUNTER_STORAGE_INT32_KHR;
const VkPerformanceCounterStorageKHR PERFORMANCE_COUNTER_STORAGE_END_RANGE_KHR = PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR;
const VkPerformanceCounterStorageKHR PERFORMANCE_COUNTER_STORAGE_RANGE_SIZE_KHR = (PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR-PERFORMANCE_COUNTER_STORAGE_INT32_KHR+1);
const VkPerformanceCounterStorageKHR PERFORMANCE_COUNTER_STORAGE_MAX_ENUM_KHR = 0x7FFFFFFF;

typedef VkPerformanceCounterDescriptionFlagBitsKHR = inline CUInt;
const VkPerformanceCounterDescriptionFlagBitsKHR PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_KHR = 0x00000001;
const VkPerformanceCounterDescriptionFlagBitsKHR PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_KHR = 0x00000002;
const VkPerformanceCounterDescriptionFlagBitsKHR PERFORMANCE_COUNTER_DESCRIPTION_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF;

alias VkPerformanceCounterDescriptionFlagsKHR = VkFlags;

typedef VkAcquireProfilingLockFlagBitsKHR = inline CUInt;
const VkAcquireProfilingLockFlagBitsKHR ACQUIRE_PROFILING_LOCK_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF;

alias VkAcquireProfilingLockFlagsKHR = VkFlags;

struct VkPhysicalDevicePerformanceQueryFeaturesKHR {
  VkStructureType s_type;
  void * p_next;
  VkBool32 performance_counter_query_pools;
  VkBool32 performance_counter_multiple_query_pools;
}

struct VkPhysicalDevicePerformanceQueryPropertiesKHR {
  VkStructureType s_type;
  void * p_next;
  VkBool32 allow_command_buffer_query_copies;
}

struct VkPerformanceCounterKHR {
  VkStructureType s_type;
  void * p_next;
  VkPerformanceCounterUnitKHR unit;
  VkPerformanceCounterScopeKHR scope;
  VkPerformanceCounterStorageKHR storage;
  char[16] uuid;
}

struct VkPerformanceCounterDescriptionKHR {
  VkStructureType s_type;
  void * p_next;
  VkPerformanceCounterDescriptionFlagsKHR flags;
  CChar[256] name;
  CChar[256] category;
  CChar[256] description;
}

struct VkQueryPoolPerformanceCreateInfoKHR {
  VkStructureType s_type;
  void * p_next;
  uint queue_family_index;
  uint counter_index_count;
  uint * p_counter_indices;
}

union VkPerformanceCounterResultKHR {
  int int_32;
  long int_64;
  uint uint_32;
  ulong uint_64;
  float float_32;
  double float_64;
}

struct VkAcquireProfilingLockInfoKHR {
  VkStructureType s_type;
  void * p_next;
  VkAcquireProfilingLockFlagsKHR flags;
  ulong timeout;
}

struct VkPerformanceQuerySubmitInfoKHR {
  VkStructureType s_type;
  void * p_next;
  uint counter_pass_index;
}

alias PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR = fn VkResult(
  VkPhysicalDevice physical_device, 
  uint queue_family_index, 
  uint * p_counter_count, 
  VkPerformanceCounterKHR * p_counters, 
  VkPerformanceCounterDescriptionKHR * p_counter_descriptions);

alias PFN_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR = fn void(
  VkPhysicalDevice physical_device, 
  VkQueryPoolPerformanceCreateInfoKHR * p_performance_query_create_info, 
  uint * p_num_passes);

alias PFN_vkAcquireProfilingLockKHR = fn VkResult(
  VkDevice device, 
  VkAcquireProfilingLockInfoKHR * p_info);

alias PFN_vkReleaseProfilingLockKHR = fn void(  VkDevice device);

fn VkResult enumerate_physical_device_queue_family_performance_query_counters_khr(
  VkPhysicalDevice physical_device, 
  uint queue_family_index, 
  uint * p_counter_count, 
  VkPerformanceCounterKHR * p_counters, 
  VkPerformanceCounterDescriptionKHR * p_counter_descriptions)
@extern("vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR");

fn void get_physical_device_queue_family_performance_query_passes_khr(
  VkPhysicalDevice physical_device, 
  VkQueryPoolPerformanceCreateInfoKHR * p_performance_query_create_info, 
  uint * p_num_passes)
@extern("vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR");

fn VkResult acquire_profiling_lock_khr(
  VkDevice device, 
  VkAcquireProfilingLockInfoKHR * p_info)
@extern("vkAcquireProfilingLockKHR");

fn void release_profiling_lock_khr(
  VkDevice device)
@extern("vkReleaseProfilingLockKHR");

alias VkPointClippingBehaviorKHR = VkPointClippingBehavior;

alias VkTessellationDomainOriginKHR = VkTessellationDomainOrigin;

alias VkPhysicalDevicePointClippingPropertiesKHR = VkPhysicalDevicePointClippingProperties;

alias VkRenderPassInputAttachmentAspectCreateInfoKHR = VkRenderPassInputAttachmentAspectCreateInfo;

alias VkInputAttachmentAspectReferenceKHR = VkInputAttachmentAspectReference;

alias VkImageViewUsageCreateInfoKHR = VkImageViewUsageCreateInfo;

alias VkPipelineTessellationDomainOriginStateCreateInfoKHR = VkPipelineTessellationDomainOriginStateCreateInfo;

struct VkPhysicalDeviceSurfaceInfo2KHR {
  VkStructureType s_type;
  void * p_next;
  VkSurfaceKHR surface;
}

struct VkSurfaceCapabilities2KHR {
  VkStructureType s_type;
  void * p_next;
  VkSurfaceCapabilitiesKHR surface_capabilities;
}

struct VkSurfaceFormat2KHR {
  VkStructureType s_type;
  void * p_next;
  VkSurfaceFormatKHR surface_format;
}

alias PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR = fn VkResult(
  VkPhysicalDevice physical_device, 
  VkPhysicalDeviceSurfaceInfo2KHR * p_surface_info, 
  VkSurfaceCapabilities2KHR * p_surface_capabilities);

alias PFN_vkGetPhysicalDeviceSurfaceFormats2KHR = fn VkResult(
  VkPhysicalDevice physical_device, 
  VkPhysicalDeviceSurfaceInfo2KHR * p_surface_info, 
  uint * p_surface_format_count, 
  VkSurfaceFormat2KHR * p_surface_formats);

fn VkResult get_physical_device_surface_capabilities_2_khr(
  VkPhysicalDevice physical_device, 
  VkPhysicalDeviceSurfaceInfo2KHR * p_surface_info, 
  VkSurfaceCapabilities2KHR * p_surface_capabilities)
@extern("vkGetPhysicalDeviceSurfaceCapabilities2KHR");

fn VkResult get_physical_device_surface_formats_2_khr(
  VkPhysicalDevice physical_device, 
  VkPhysicalDeviceSurfaceInfo2KHR * p_surface_info, 
  uint * p_surface_format_count, 
  VkSurfaceFormat2KHR * p_surface_formats)
@extern("vkGetPhysicalDeviceSurfaceFormats2KHR");

alias VkPhysicalDeviceVariablePointerFeaturesKHR = VkPhysicalDeviceVariablePointersFeatures;

alias VkPhysicalDeviceVariablePointersFeaturesKHR = VkPhysicalDeviceVariablePointersFeatures;

struct VkDisplayProperties2KHR {
  VkStructureType s_type;
  void * p_next;
  VkDisplayPropertiesKHR display_properties;
}

struct VkDisplayPlaneProperties2KHR {
  VkStructureType s_type;
  void * p_next;
  VkDisplayPlanePropertiesKHR display_plane_properties;
}

struct VkDisplayModeProperties2KHR {
  VkStructureType s_type;
  void * p_next;
  VkDisplayModePropertiesKHR display_mode_properties;
}

struct VkDisplayPlaneInfo2KHR {
  VkStructureType s_type;
  void * p_next;
  VkDisplayModeKHR mode;
  uint plane_index;
}

struct VkDisplayPlaneCapabilities2KHR {
  VkStructureType s_type;
  void * p_next;
  VkDisplayPlaneCapabilitiesKHR capabilities;
}

alias PFN_vkGetPhysicalDeviceDisplayProperties2KHR = fn VkResult(
  VkPhysicalDevice physical_device, 
  uint * p_property_count, 
  VkDisplayProperties2KHR * p_properties);

alias PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR = fn VkResult(
  VkPhysicalDevice physical_device, 
  uint * p_property_count, 
  VkDisplayPlaneProperties2KHR * p_properties);

alias PFN_vkGetDisplayModeProperties2KHR = fn VkResult(
  VkPhysicalDevice physical_device, 
  VkDisplayKHR display, 
  uint * p_property_count, 
  VkDisplayModeProperties2KHR * p_properties);

alias PFN_vkGetDisplayPlaneCapabilities2KHR = fn VkResult(
  VkPhysicalDevice physical_device, 
  VkDisplayPlaneInfo2KHR * p_display_plane_info, 
  VkDisplayPlaneCapabilities2KHR * p_capabilities);

fn VkResult get_physical_device_display_properties_2_khr(
  VkPhysicalDevice physical_device, 
  uint * p_property_count, 
  VkDisplayProperties2KHR * p_properties)
@extern("vkGetPhysicalDeviceDisplayProperties2KHR");

fn VkResult get_physical_device_display_plane_properties_2_khr(
  VkPhysicalDevice physical_device, 
  uint * p_property_count, 
  VkDisplayPlaneProperties2KHR * p_properties)
@extern("vkGetPhysicalDeviceDisplayPlaneProperties2KHR");

fn VkResult get_display_mode_properties_2_khr(
  VkPhysicalDevice physical_device, 
  VkDisplayKHR display, 
  uint * p_property_count, 
  VkDisplayModeProperties2KHR * p_properties)
@extern("vkGetDisplayModeProperties2KHR");

fn VkResult get_display_plane_capabilities_2_khr(
  VkPhysicalDevice physical_device, 
  VkDisplayPlaneInfo2KHR * p_display_plane_info, 
  VkDisplayPlaneCapabilities2KHR * p_capabilities)
@extern("vkGetDisplayPlaneCapabilities2KHR");

alias VkMemoryDedicatedRequirementsKHR = VkMemoryDedicatedRequirements;

alias VkMemoryDedicatedAllocateInfoKHR = VkMemoryDedicatedAllocateInfo;

alias VkBufferMemoryRequirementsInfo2KHR = VkBufferMemoryRequirementsInfo2;

alias VkImageMemoryRequirementsInfo2KHR = VkImageMemoryRequirementsInfo2;

alias VkImageSparseMemoryRequirementsInfo2KHR = VkImageSparseMemoryRequirementsInfo2;

alias VkSparseImageMemoryRequirements2KHR = VkSparseImageMemoryRequirements2;

alias PFN_vkGetImageMemoryRequirements2KHR = fn void(
  VkDevice device, 
  VkImageMemoryRequirementsInfo2 * p_info, 
  VkMemoryRequirements2 * p_memory_requirements);

alias PFN_vkGetBufferMemoryRequirements2KHR = fn void(
  VkDevice device, 
  VkBufferMemoryRequirementsInfo2 * p_info, 
  VkMemoryRequirements2 * p_memory_requirements);

alias PFN_vkGetImageSparseMemoryRequirements2KHR = fn void(
  VkDevice device, 
  VkImageSparseMemoryRequirementsInfo2 * p_info, 
  uint * p_sparse_memory_requirement_count, 
  VkSparseImageMemoryRequirements2 * p_sparse_memory_requirements);

fn void get_image_memory_requirements_2_khr(
  VkDevice device, 
  VkImageMemoryRequirementsInfo2 * p_info, 
  VkMemoryRequirements2 * p_memory_requirements)
@extern("vkGetImageMemoryRequirements2KHR");

fn void get_buffer_memory_requirements_2_khr(
  VkDevice device, 
  VkBufferMemoryRequirementsInfo2 * p_info, 
  VkMemoryRequirements2 * p_memory_requirements)
@extern("vkGetBufferMemoryRequirements2KHR");

fn void get_image_sparse_memory_requirements_2_khr(
  VkDevice device, 
  VkImageSparseMemoryRequirementsInfo2 * p_info, 
  uint * p_sparse_memory_requirement_count, 
  VkSparseImageMemoryRequirements2 * p_sparse_memory_requirements)
@extern("vkGetImageSparseMemoryRequirements2KHR");

struct VkImageFormatListCreateInfoKHR {
  VkStructureType s_type;
  void * p_next;
  uint view_format_count;
  VkFormat * p_view_formats;
}

alias VkSamplerYcbcrConversionKHR = VkSamplerYcbcrConversion;

alias VkSamplerYcbcrModelConversionKHR = VkSamplerYcbcrModelConversion;

alias VkSamplerYcbcrRangeKHR = VkSamplerYcbcrRange;

alias VkChromaLocationKHR = VkChromaLocation;

alias VkSamplerYcbcrConversionCreateInfoKHR = VkSamplerYcbcrConversionCreateInfo;

alias VkSamplerYcbcrConversionInfoKHR = VkSamplerYcbcrConversionInfo;

alias VkBindImagePlaneMemoryInfoKHR = VkBindImagePlaneMemoryInfo;

alias VkImagePlaneMemoryRequirementsInfoKHR = VkImagePlaneMemoryRequirementsInfo;

alias VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR = VkPhysicalDeviceSamplerYcbcrConversionFeatures;

alias VkSamplerYcbcrConversionImageFormatPropertiesKHR = VkSamplerYcbcrConversionImageFormatProperties;

alias PFN_vkCreateSamplerYcbcrConversionKHR = fn VkResult(
  VkDevice device, 
  VkSamplerYcbcrConversionCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkSamplerYcbcrConversion * p_ycbcr_conversion);

alias PFN_vkDestroySamplerYcbcrConversionKHR = fn void(
  VkDevice device, 
  VkSamplerYcbcrConversion ycbcr_conversion, 
  VkAllocationCallbacks * p_allocator);

fn VkResult create_sampler_ycbcr_conversion_khr(
  VkDevice device, 
  VkSamplerYcbcrConversionCreateInfo * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkSamplerYcbcrConversion * p_ycbcr_conversion)
@extern("vkCreateSamplerYcbcrConversionKHR");

fn void destroy_sampler_ycbcr_conversion_khr(
  VkDevice device, 
  VkSamplerYcbcrConversion ycbcr_conversion, 
  VkAllocationCallbacks * p_allocator)
@extern("vkDestroySamplerYcbcrConversionKHR");

alias VkBindBufferMemoryInfoKHR = VkBindBufferMemoryInfo;

alias VkBindImageMemoryInfoKHR = VkBindImageMemoryInfo;

alias PFN_vkBindBufferMemory2KHR = fn VkResult(
  VkDevice device, 
  uint bind_info_count, 
  VkBindBufferMemoryInfo * p_bind_infos);

alias PFN_vkBindImageMemory2KHR = fn VkResult(
  VkDevice device, 
  uint bind_info_count, 
  VkBindImageMemoryInfo * p_bind_infos);

fn VkResult bind_buffer_memory_2_khr(
  VkDevice device, 
  uint bind_info_count, 
  VkBindBufferMemoryInfo * p_bind_infos)
@extern("vkBindBufferMemory2KHR");

fn VkResult bind_image_memory_2_khr(
  VkDevice device, 
  uint bind_info_count, 
  VkBindImageMemoryInfo * p_bind_infos)
@extern("vkBindImageMemory2KHR");

alias VkPhysicalDeviceMaintenance3PropertiesKHR = VkPhysicalDeviceMaintenance3Properties;

alias VkDescriptorSetLayoutSupportKHR = VkDescriptorSetLayoutSupport;

alias PFN_vkGetDescriptorSetLayoutSupportKHR = fn void(
  VkDevice device, 
  VkDescriptorSetLayoutCreateInfo * p_create_info, 
  VkDescriptorSetLayoutSupport * p_support);

fn void get_descriptor_set_layout_support_khr(
  VkDevice device, 
  VkDescriptorSetLayoutCreateInfo * p_create_info, 
  VkDescriptorSetLayoutSupport * p_support)
@extern("vkGetDescriptorSetLayoutSupportKHR");

alias PFN_vkCmdDrawIndirectCountKHR = fn void(
  VkCommandBuffer command_buffer, 
  VkBuffer buffer, 
  VkDeviceSize offset, 
  VkBuffer count_buffer, 
  VkDeviceSize count_buffer_offset, 
  uint max_draw_count, 
  uint stride);

alias PFN_vkCmdDrawIndexedIndirectCountKHR = fn void(
  VkCommandBuffer command_buffer, 
  VkBuffer buffer, 
  VkDeviceSize offset, 
  VkBuffer count_buffer, 
  VkDeviceSize count_buffer_offset, 
  uint max_draw_count, 
  uint stride);

fn void cmd_draw_indirect_count_khr(
  VkCommandBuffer command_buffer, 
  VkBuffer buffer, 
  VkDeviceSize offset, 
  VkBuffer count_buffer, 
  VkDeviceSize count_buffer_offset, 
  uint max_draw_count, 
  uint stride)
@extern("vkCmdDrawIndirectCountKHR");

fn void cmd_draw_indexed_indirect_count_khr(
  VkCommandBuffer command_buffer, 
  VkBuffer buffer, 
  VkDeviceSize offset, 
  VkBuffer count_buffer, 
  VkDeviceSize count_buffer_offset, 
  uint max_draw_count, 
  uint stride)
@extern("vkCmdDrawIndexedIndirectCountKHR");

struct VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR {
  VkStructureType s_type;
  void * p_next;
  VkBool32 shader_subgroup_extended_types;
}

struct VkPhysicalDevice8BitStorageFeaturesKHR {
  VkStructureType s_type;
  void * p_next;
  VkBool32 storage_buffer_8_bit_access;
  VkBool32 uniform_and_storage_buffer_8_bit_access;
  VkBool32 storage_push_constant_8;
}

struct VkPhysicalDeviceShaderAtomicInt64FeaturesKHR {
  VkStructureType s_type;
  void * p_next;
  VkBool32 shader_buffer_int_64_atomics;
  VkBool32 shader_shared_int_64_atomics;
}

struct VkPhysicalDeviceShaderClockFeaturesKHR {
  VkStructureType s_type;
  void * p_next;
  VkBool32 shader_subgroup_clock;
  VkBool32 shader_device_clock;
}

typedef VkDriverIdKHR = inline CUInt;
const VkDriverIdKHR DRIVER_ID_AMD_PROPRIETARY_KHR = 1;
const VkDriverIdKHR DRIVER_ID_AMD_OPEN_SOURCE_KHR = 2;
const VkDriverIdKHR DRIVER_ID_MESA_RADV_KHR = 3;
const VkDriverIdKHR DRIVER_ID_NVIDIA_PROPRIETARY_KHR = 4;
const VkDriverIdKHR DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR = 5;
const VkDriverIdKHR DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR = 6;
const VkDriverIdKHR DRIVER_ID_IMAGINATION_PROPRIETARY_KHR = 7;
const VkDriverIdKHR DRIVER_ID_QUALCOMM_PROPRIETARY_KHR = 8;
const VkDriverIdKHR DRIVER_ID_ARM_PROPRIETARY_KHR = 9;
const VkDriverIdKHR DRIVER_ID_GOOGLE_SWIFTSHADER_KHR = 10;
const VkDriverIdKHR DRIVER_ID_GGP_PROPRIETARY_KHR = 11;
const VkDriverIdKHR DRIVER_ID_BROADCOM_PROPRIETARY_KHR = 12;
const VkDriverIdKHR DRIVER_ID_BEGIN_RANGE_KHR = DRIVER_ID_AMD_PROPRIETARY_KHR;
const VkDriverIdKHR DRIVER_ID_END_RANGE_KHR = DRIVER_ID_BROADCOM_PROPRIETARY_KHR;
const VkDriverIdKHR DRIVER_ID_RANGE_SIZE_KHR = (DRIVER_ID_BROADCOM_PROPRIETARY_KHR-DRIVER_ID_AMD_PROPRIETARY_KHR+1);
const VkDriverIdKHR DRIVER_ID_MAX_ENUM_KHR = 0x7FFFFFFF;

struct VkConformanceVersionKHR {
  char major;
  char minor;
  char subminor;
  char patch;
}

struct VkPhysicalDeviceDriverPropertiesKHR {
  VkStructureType s_type;
  void * p_next;
  VkDriverIdKHR driver_id;
  CChar[256] driver_name;
  CChar[256] driver_info;
  VkConformanceVersionKHR conformance_version;
}

typedef VkShaderFloatControlsIndependenceKHR = inline CUInt;
const VkShaderFloatControlsIndependenceKHR SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR = 0;
const VkShaderFloatControlsIndependenceKHR SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR = 1;
const VkShaderFloatControlsIndependenceKHR SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR = 2;
const VkShaderFloatControlsIndependenceKHR SHADER_FLOAT_CONTROLS_INDEPENDENCE_BEGIN_RANGE_KHR = SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR;
const VkShaderFloatControlsIndependenceKHR SHADER_FLOAT_CONTROLS_INDEPENDENCE_END_RANGE_KHR = SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR;
const VkShaderFloatControlsIndependenceKHR SHADER_FLOAT_CONTROLS_INDEPENDENCE_RANGE_SIZE_KHR = (SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR-SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR+1);
const VkShaderFloatControlsIndependenceKHR SHADER_FLOAT_CONTROLS_INDEPENDENCE_MAX_ENUM_KHR = 0x7FFFFFFF;

struct VkPhysicalDeviceFloatControlsPropertiesKHR {
  VkStructureType s_type;
  void * p_next;
  VkShaderFloatControlsIndependenceKHR denorm_behavior_independence;
  VkShaderFloatControlsIndependenceKHR rounding_mode_independence;
  VkBool32 shader_signed_zero_inf_nan_preserve_float_16;
  VkBool32 shader_signed_zero_inf_nan_preserve_float_32;
  VkBool32 shader_signed_zero_inf_nan_preserve_float_64;
  VkBool32 shader_denorm_preserve_float_16;
  VkBool32 shader_denorm_preserve_float_32;
  VkBool32 shader_denorm_preserve_float_64;
  VkBool32 shader_denorm_flush_to_zero_float_16;
  VkBool32 shader_denorm_flush_to_zero_float_32;
  VkBool32 shader_denorm_flush_to_zero_float_64;
  VkBool32 shader_rounding_mode_rtefloat_16;
  VkBool32 shader_rounding_mode_rtefloat_32;
  VkBool32 shader_rounding_mode_rtefloat_64;
  VkBool32 shader_rounding_mode_rtzfloat_16;
  VkBool32 shader_rounding_mode_rtzfloat_32;
  VkBool32 shader_rounding_mode_rtzfloat_64;
}

typedef VkResolveModeFlagBitsKHR = inline CUInt;
const VkResolveModeFlagBitsKHR RESOLVE_MODE_NONE_KHR = 0;
const VkResolveModeFlagBitsKHR RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR = 0x00000001;
const VkResolveModeFlagBitsKHR RESOLVE_MODE_AVERAGE_BIT_KHR = 0x00000002;
const VkResolveModeFlagBitsKHR RESOLVE_MODE_MIN_BIT_KHR = 0x00000004;
const VkResolveModeFlagBitsKHR RESOLVE_MODE_MAX_BIT_KHR = 0x00000008;
const VkResolveModeFlagBitsKHR RESOLVE_MODE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF;

alias VkResolveModeFlagsKHR = VkFlags;

struct VkSubpassDescriptionDepthStencilResolveKHR {
  VkStructureType s_type;
  void * p_next;
  VkResolveModeFlagBitsKHR depth_resolve_mode;
  VkResolveModeFlagBitsKHR stencil_resolve_mode;
  VkAttachmentReference2KHR * p_depth_stencil_resolve_attachment;
}

struct VkPhysicalDeviceDepthStencilResolvePropertiesKHR {
  VkStructureType s_type;
  void * p_next;
  VkResolveModeFlagsKHR supported_depth_resolve_modes;
  VkResolveModeFlagsKHR supported_stencil_resolve_modes;
  VkBool32 independent_resolve_none;
  VkBool32 independent_resolve;
}

typedef VkSemaphoreTypeKHR = inline CUInt;
const VkSemaphoreTypeKHR SEMAPHORE_TYPE_BINARY_KHR = 0;
const VkSemaphoreTypeKHR SEMAPHORE_TYPE_TIMELINE_KHR = 1;
const VkSemaphoreTypeKHR SEMAPHORE_TYPE_BEGIN_RANGE_KHR = SEMAPHORE_TYPE_BINARY_KHR;
const VkSemaphoreTypeKHR SEMAPHORE_TYPE_END_RANGE_KHR = SEMAPHORE_TYPE_TIMELINE_KHR;
const VkSemaphoreTypeKHR SEMAPHORE_TYPE_RANGE_SIZE_KHR = (SEMAPHORE_TYPE_TIMELINE_KHR-SEMAPHORE_TYPE_BINARY_KHR+1);
const VkSemaphoreTypeKHR SEMAPHORE_TYPE_MAX_ENUM_KHR = 0x7FFFFFFF;

typedef VkSemaphoreWaitFlagBitsKHR = inline CUInt;
const VkSemaphoreWaitFlagBitsKHR SEMAPHORE_WAIT_ANY_BIT_KHR = 0x00000001;
const VkSemaphoreWaitFlagBitsKHR SEMAPHORE_WAIT_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF;

alias VkSemaphoreWaitFlagsKHR = VkFlags;

struct VkPhysicalDeviceTimelineSemaphoreFeaturesKHR {
  VkStructureType s_type;
  void * p_next;
  VkBool32 timeline_semaphore;
}

struct VkPhysicalDeviceTimelineSemaphorePropertiesKHR {
  VkStructureType s_type;
  void * p_next;
  ulong max_timeline_semaphore_value_difference;
}

struct VkSemaphoreTypeCreateInfoKHR {
  VkStructureType s_type;
  void * p_next;
  VkSemaphoreTypeKHR semaphore_type;
  ulong initial_value;
}

struct VkTimelineSemaphoreSubmitInfoKHR {
  VkStructureType s_type;
  void * p_next;
  uint wait_semaphore_value_count;
  ulong * p_wait_semaphore_values;
  uint signal_semaphore_value_count;
  ulong * p_signal_semaphore_values;
}

struct VkSemaphoreWaitInfoKHR {
  VkStructureType s_type;
  void * p_next;
  VkSemaphoreWaitFlagsKHR flags;
  uint semaphore_count;
  VkSemaphore * p_semaphores;
  ulong * p_values;
}

struct VkSemaphoreSignalInfoKHR {
  VkStructureType s_type;
  void * p_next;
  VkSemaphore semaphore;
  ulong value;
}

alias PFN_vkGetSemaphoreCounterValueKHR = fn VkResult(
  VkDevice device, 
  VkSemaphore semaphore, 
  ulong * p_value);

alias PFN_vkWaitSemaphoresKHR = fn VkResult(
  VkDevice device, 
  VkSemaphoreWaitInfoKHR * p_wait_info, 
  ulong timeout);

alias PFN_vkSignalSemaphoreKHR = fn VkResult(
  VkDevice device, 
  VkSemaphoreSignalInfoKHR * p_signal_info);

fn VkResult get_semaphore_counter_value_khr(
  VkDevice device, 
  VkSemaphore semaphore, 
  ulong * p_value)
@extern("vkGetSemaphoreCounterValueKHR");

fn VkResult wait_semaphores_khr(
  VkDevice device, 
  VkSemaphoreWaitInfoKHR * p_wait_info, 
  ulong timeout)
@extern("vkWaitSemaphoresKHR");

fn VkResult signal_semaphore_khr(
  VkDevice device, 
  VkSemaphoreSignalInfoKHR * p_signal_info)
@extern("vkSignalSemaphoreKHR");

struct VkPhysicalDeviceVulkanMemoryModelFeaturesKHR {
  VkStructureType s_type;
  void * p_next;
  VkBool32 vulkan_memory_model;
  VkBool32 vulkan_memory_model_device_scope;
  VkBool32 vulkan_memory_model_availability_visibility_chains;
}

struct VkSurfaceProtectedCapabilitiesKHR {
  VkStructureType s_type;
  void * p_next;
  VkBool32 supports_protected;
}

struct VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR {
  VkStructureType s_type;
  void * p_next;
  VkBool32 separate_depth_stencil_layouts;
}

struct VkAttachmentReferenceStencilLayoutKHR {
  VkStructureType s_type;
  void * p_next;
  VkImageLayout stencil_layout;
}

struct VkAttachmentDescriptionStencilLayoutKHR {
  VkStructureType s_type;
  void * p_next;
  VkImageLayout stencil_initial_layout;
  VkImageLayout stencil_final_layout;
}

struct VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR {
  VkStructureType s_type;
  void * p_next;
  VkBool32 uniform_buffer_standard_layout;
}

alias VkDeviceAddress = ulong;

struct VkPhysicalDeviceBufferDeviceAddressFeaturesKHR {
  VkStructureType s_type;
  void * p_next;
  VkBool32 buffer_device_address;
  VkBool32 buffer_device_address_capture_replay;
  VkBool32 buffer_device_address_multi_device;
}

struct VkBufferDeviceAddressInfoKHR {
  VkStructureType s_type;
  void * p_next;
  VkBuffer buffer;
}

struct VkBufferOpaqueCaptureAddressCreateInfoKHR {
  VkStructureType s_type;
  void * p_next;
  ulong opaque_capture_address;
}

struct VkMemoryOpaqueCaptureAddressAllocateInfoKHR {
  VkStructureType s_type;
  void * p_next;
  ulong opaque_capture_address;
}

struct VkDeviceMemoryOpaqueCaptureAddressInfoKHR {
  VkStructureType s_type;
  void * p_next;
  VkDeviceMemory memory;
}

alias PFN_vkGetBufferDeviceAddressKHR = fn VkDeviceAddress(
  VkDevice device, 
  VkBufferDeviceAddressInfoKHR * p_info);

alias PFN_vkGetBufferOpaqueCaptureAddressKHR = fn ulong(
  VkDevice device, 
  VkBufferDeviceAddressInfoKHR * p_info);

alias PFN_vkGetDeviceMemoryOpaqueCaptureAddressKHR = fn ulong(
  VkDevice device, 
  VkDeviceMemoryOpaqueCaptureAddressInfoKHR * p_info);

fn VkDeviceAddress get_buffer_device_address_khr(
  VkDevice device, 
  VkBufferDeviceAddressInfoKHR * p_info)
@extern("vkGetBufferDeviceAddressKHR");

fn ulong get_buffer_opaque_capture_address_khr(
  VkDevice device, 
  VkBufferDeviceAddressInfoKHR * p_info)
@extern("vkGetBufferOpaqueCaptureAddressKHR");

fn ulong get_device_memory_opaque_capture_address_khr(
  VkDevice device, 
  VkDeviceMemoryOpaqueCaptureAddressInfoKHR * p_info)
@extern("vkGetDeviceMemoryOpaqueCaptureAddressKHR");

typedef VkPipelineExecutableStatisticFormatKHR = inline CUInt;
const VkPipelineExecutableStatisticFormatKHR PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR = 0;
const VkPipelineExecutableStatisticFormatKHR PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR = 1;
const VkPipelineExecutableStatisticFormatKHR PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR = 2;
const VkPipelineExecutableStatisticFormatKHR PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR = 3;
const VkPipelineExecutableStatisticFormatKHR PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BEGIN_RANGE_KHR = PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR;
const VkPipelineExecutableStatisticFormatKHR PIPELINE_EXECUTABLE_STATISTIC_FORMAT_END_RANGE_KHR = PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR;
const VkPipelineExecutableStatisticFormatKHR PIPELINE_EXECUTABLE_STATISTIC_FORMAT_RANGE_SIZE_KHR = (PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR-PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR+1);
const VkPipelineExecutableStatisticFormatKHR PIPELINE_EXECUTABLE_STATISTIC_FORMAT_MAX_ENUM_KHR = 0x7FFFFFFF;

struct VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR {
  VkStructureType s_type;
  void * p_next;
  VkBool32 pipeline_executable_info;
}

struct VkPipelineInfoKHR {
  VkStructureType s_type;
  void * p_next;
  VkPipeline pipeline;
}

struct VkPipelineExecutablePropertiesKHR {
  VkStructureType s_type;
  void * p_next;
  VkShaderStageFlags stages;
  CChar[256] name;
  CChar[256] description;
  uint subgroup_size;
}

struct VkPipelineExecutableInfoKHR {
  VkStructureType s_type;
  void * p_next;
  VkPipeline pipeline;
  uint executable_index;
}

union VkPipelineExecutableStatisticValueKHR {
  VkBool32 b_32;
  long i_64;
  ulong u_64;
  double f_64;
}

struct VkPipelineExecutableStatisticKHR {
  VkStructureType s_type;
  void * p_next;
  CChar[256] name;
  CChar[256] description;
  VkPipelineExecutableStatisticFormatKHR format;
  VkPipelineExecutableStatisticValueKHR value;
}

struct VkPipelineExecutableInternalRepresentationKHR {
  VkStructureType s_type;
  void * p_next;
  CChar[256] name;
  CChar[256] description;
  VkBool32 is_text;
  usz data_size;
  void * p_data;
}

alias PFN_vkGetPipelineExecutablePropertiesKHR = fn VkResult(
  VkDevice device, 
  VkPipelineInfoKHR * p_pipeline_info, 
  uint * p_executable_count, 
  VkPipelineExecutablePropertiesKHR * p_properties);

alias PFN_vkGetPipelineExecutableStatisticsKHR = fn VkResult(
  VkDevice device, 
  VkPipelineExecutableInfoKHR * p_executable_info, 
  uint * p_statistic_count, 
  VkPipelineExecutableStatisticKHR * p_statistics);

alias PFN_vkGetPipelineExecutableInternalRepresentationsKHR = fn VkResult(
  VkDevice device, 
  VkPipelineExecutableInfoKHR * p_executable_info, 
  uint * p_internal_representation_count, 
  VkPipelineExecutableInternalRepresentationKHR * p_internal_representations);

fn VkResult get_pipeline_executable_properties_khr(
  VkDevice device, 
  VkPipelineInfoKHR * p_pipeline_info, 
  uint * p_executable_count, 
  VkPipelineExecutablePropertiesKHR * p_properties)
@extern("vkGetPipelineExecutablePropertiesKHR");

fn VkResult get_pipeline_executable_statistics_khr(
  VkDevice device, 
  VkPipelineExecutableInfoKHR * p_executable_info, 
  uint * p_statistic_count, 
  VkPipelineExecutableStatisticKHR * p_statistics)
@extern("vkGetPipelineExecutableStatisticsKHR");

fn VkResult get_pipeline_executable_internal_representations_khr(
  VkDevice device, 
  VkPipelineExecutableInfoKHR * p_executable_info, 
  uint * p_internal_representation_count, 
  VkPipelineExecutableInternalRepresentationKHR * p_internal_representations)
@extern("vkGetPipelineExecutableInternalRepresentationsKHR");

typedef VkDebugReportCallbackEXT_T = void;

alias VkDebugReportCallbackEXT = VkDebugReportCallbackEXT_T *;

typedef VkDebugReportObjectTypeEXT = inline CUInt;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT = 0;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT = 1;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT = 2;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT = 3;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT = 4;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT = 5;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT = 6;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT = 7;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT = 8;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT = 9;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT = 10;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT = 11;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT = 12;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT = 13;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT = 14;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT = 15;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT = 16;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT = 17;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT = 18;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT = 19;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT = 20;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT = 21;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT = 22;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT = 23;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT = 24;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT = 25;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT = 26;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT = 27;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT = 28;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT = 29;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT = 30;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT = 31;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT = 32;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT = 33;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT = 1000156000;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT = 1000085000;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT = 1000165000;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT = DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT = DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT = DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT = DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_BEGIN_RANGE_EXT = DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_END_RANGE_EXT = DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT;
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_RANGE_SIZE_EXT = (DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT-DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT+1);
const VkDebugReportObjectTypeEXT DEBUG_REPORT_OBJECT_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF;

typedef VkDebugReportFlagBitsEXT = inline CUInt;
const VkDebugReportFlagBitsEXT DEBUG_REPORT_INFORMATION_BIT_EXT = 0x00000001;
const VkDebugReportFlagBitsEXT DEBUG_REPORT_WARNING_BIT_EXT = 0x00000002;
const VkDebugReportFlagBitsEXT DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT = 0x00000004;
const VkDebugReportFlagBitsEXT DEBUG_REPORT_ERROR_BIT_EXT = 0x00000008;
const VkDebugReportFlagBitsEXT DEBUG_REPORT_DEBUG_BIT_EXT = 0x00000010;
const VkDebugReportFlagBitsEXT DEBUG_REPORT_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF;

alias VkDebugReportFlagsEXT = VkFlags;

alias PFN_vkDebugReportCallbackEXT = fn VkBool32(
  VkDebugReportFlagsEXT flags, 
  VkDebugReportObjectTypeEXT object_type, 
  ulong object, 
  usz location, 
  int message_code, 
  CChar * p_layer_prefix, 
  CChar * p_message, 
  void * p_user_data);

struct VkDebugReportCallbackCreateInfoEXT {
  VkStructureType s_type;
  void * p_next;
  VkDebugReportFlagsEXT flags;
  PFN_vkDebugReportCallbackEXT pfn_callback;
  void * p_user_data;
}

alias PFN_vkCreateDebugReportCallbackEXT = fn VkResult(
  VkInstance instance, 
  VkDebugReportCallbackCreateInfoEXT * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkDebugReportCallbackEXT * p_callback);

alias PFN_vkDestroyDebugReportCallbackEXT = fn void(
  VkInstance instance, 
  VkDebugReportCallbackEXT callback, 
  VkAllocationCallbacks * p_allocator);

alias PFN_vkDebugReportMessageEXT = fn void(
  VkInstance instance, 
  VkDebugReportFlagsEXT flags, 
  VkDebugReportObjectTypeEXT object_type, 
  ulong object, 
  usz location, 
  int message_code, 
  CChar * p_layer_prefix, 
  CChar * p_message);

fn VkResult create_debug_report_callback_ext(
  VkInstance instance, 
  VkDebugReportCallbackCreateInfoEXT * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkDebugReportCallbackEXT * p_callback)
@extern("vkCreateDebugReportCallbackEXT");

fn void destroy_debug_report_callback_ext(
  VkInstance instance, 
  VkDebugReportCallbackEXT callback, 
  VkAllocationCallbacks * p_allocator)
@extern("vkDestroyDebugReportCallbackEXT");

fn void debug_report_message_ext(
  VkInstance instance, 
  VkDebugReportFlagsEXT flags, 
  VkDebugReportObjectTypeEXT object_type, 
  ulong object, 
  usz location, 
  int message_code, 
  CChar * p_layer_prefix, 
  CChar * p_message)
@extern("vkDebugReportMessageEXT");

typedef VkRasterizationOrderAMD = inline CUInt;
const VkRasterizationOrderAMD RASTERIZATION_ORDER_STRICT_AMD = 0;
const VkRasterizationOrderAMD RASTERIZATION_ORDER_RELAXED_AMD = 1;
const VkRasterizationOrderAMD RASTERIZATION_ORDER_BEGIN_RANGE_AMD = RASTERIZATION_ORDER_STRICT_AMD;
const VkRasterizationOrderAMD RASTERIZATION_ORDER_END_RANGE_AMD = RASTERIZATION_ORDER_RELAXED_AMD;
const VkRasterizationOrderAMD RASTERIZATION_ORDER_RANGE_SIZE_AMD = (RASTERIZATION_ORDER_RELAXED_AMD-RASTERIZATION_ORDER_STRICT_AMD+1);
const VkRasterizationOrderAMD RASTERIZATION_ORDER_MAX_ENUM_AMD = 0x7FFFFFFF;

struct VkPipelineRasterizationStateRasterizationOrderAMD {
  VkStructureType s_type;
  void * p_next;
  VkRasterizationOrderAMD rasterization_order;
}

struct VkDebugMarkerObjectNameInfoEXT {
  VkStructureType s_type;
  void * p_next;
  VkDebugReportObjectTypeEXT object_type;
  ulong object;
  CChar * p_object_name;
}

struct VkDebugMarkerObjectTagInfoEXT {
  VkStructureType s_type;
  void * p_next;
  VkDebugReportObjectTypeEXT object_type;
  ulong object;
  ulong tag_name;
  usz tag_size;
  void * p_tag;
}

struct VkDebugMarkerMarkerInfoEXT {
  VkStructureType s_type;
  void * p_next;
  CChar * p_marker_name;
  float[4] color;
}

alias PFN_vkDebugMarkerSetObjectTagEXT = fn VkResult(
  VkDevice device, 
  VkDebugMarkerObjectTagInfoEXT * p_tag_info);

alias PFN_vkDebugMarkerSetObjectNameEXT = fn VkResult(
  VkDevice device, 
  VkDebugMarkerObjectNameInfoEXT * p_name_info);

alias PFN_vkCmdDebugMarkerBeginEXT = fn void(
  VkCommandBuffer command_buffer, 
  VkDebugMarkerMarkerInfoEXT * p_marker_info);

alias PFN_vkCmdDebugMarkerEndEXT = fn void(  VkCommandBuffer command_buffer);

alias PFN_vkCmdDebugMarkerInsertEXT = fn void(
  VkCommandBuffer command_buffer, 
  VkDebugMarkerMarkerInfoEXT * p_marker_info);

fn VkResult debug_marker_set_object_tag_ext(
  VkDevice device, 
  VkDebugMarkerObjectTagInfoEXT * p_tag_info)
@extern("vkDebugMarkerSetObjectTagEXT");

fn VkResult debug_marker_set_object_name_ext(
  VkDevice device, 
  VkDebugMarkerObjectNameInfoEXT * p_name_info)
@extern("vkDebugMarkerSetObjectNameEXT");

fn void cmd_debug_marker_begin_ext(
  VkCommandBuffer command_buffer, 
  VkDebugMarkerMarkerInfoEXT * p_marker_info)
@extern("vkCmdDebugMarkerBeginEXT");

fn void cmd_debug_marker_end_ext(
  VkCommandBuffer command_buffer)
@extern("vkCmdDebugMarkerEndEXT");

fn void cmd_debug_marker_insert_ext(
  VkCommandBuffer command_buffer, 
  VkDebugMarkerMarkerInfoEXT * p_marker_info)
@extern("vkCmdDebugMarkerInsertEXT");

struct VkDedicatedAllocationImageCreateInfoNV {
  VkStructureType s_type;
  void * p_next;
  VkBool32 dedicated_allocation;
}

struct VkDedicatedAllocationBufferCreateInfoNV {
  VkStructureType s_type;
  void * p_next;
  VkBool32 dedicated_allocation;
}

struct VkDedicatedAllocationMemoryAllocateInfoNV {
  VkStructureType s_type;
  void * p_next;
  VkImage image;
  VkBuffer buffer;
}

alias VkPipelineRasterizationStateStreamCreateFlagsEXT = VkFlags;

struct VkPhysicalDeviceTransformFeedbackFeaturesEXT {
  VkStructureType s_type;
  void * p_next;
  VkBool32 transform_feedback;
  VkBool32 geometry_streams;
}

struct VkPhysicalDeviceTransformFeedbackPropertiesEXT {
  VkStructureType s_type;
  void * p_next;
  uint max_transform_feedback_streams;
  uint max_transform_feedback_buffers;
  VkDeviceSize max_transform_feedback_buffer_size;
  uint max_transform_feedback_stream_data_size;
  uint max_transform_feedback_buffer_data_size;
  uint max_transform_feedback_buffer_data_stride;
  VkBool32 transform_feedback_queries;
  VkBool32 transform_feedback_streams_lines_triangles;
  VkBool32 transform_feedback_rasterization_stream_select;
  VkBool32 transform_feedback_draw;
}

struct VkPipelineRasterizationStateStreamCreateInfoEXT {
  VkStructureType s_type;
  void * p_next;
  VkPipelineRasterizationStateStreamCreateFlagsEXT flags;
  uint rasterization_stream;
}

alias PFN_vkCmdBindTransformFeedbackBuffersEXT = fn void(
  VkCommandBuffer command_buffer, 
  uint first_binding, 
  uint binding_count, 
  VkBuffer * p_buffers, 
  VkDeviceSize * p_offsets, 
  VkDeviceSize * p_sizes);

alias PFN_vkCmdBeginTransformFeedbackEXT = fn void(
  VkCommandBuffer command_buffer, 
  uint first_counter_buffer, 
  uint counter_buffer_count, 
  VkBuffer * p_counter_buffers, 
  VkDeviceSize * p_counter_buffer_offsets);

alias PFN_vkCmdEndTransformFeedbackEXT = fn void(
  VkCommandBuffer command_buffer, 
  uint first_counter_buffer, 
  uint counter_buffer_count, 
  VkBuffer * p_counter_buffers, 
  VkDeviceSize * p_counter_buffer_offsets);

alias PFN_vkCmdBeginQueryIndexedEXT = fn void(
  VkCommandBuffer command_buffer, 
  VkQueryPool query_pool, 
  uint query, 
  VkQueryControlFlags flags, 
  uint index);

alias PFN_vkCmdEndQueryIndexedEXT = fn void(
  VkCommandBuffer command_buffer, 
  VkQueryPool query_pool, 
  uint query, 
  uint index);

alias PFN_vkCmdDrawIndirectByteCountEXT = fn void(
  VkCommandBuffer command_buffer, 
  uint instance_count, 
  uint first_instance, 
  VkBuffer counter_buffer, 
  VkDeviceSize counter_buffer_offset, 
  uint counter_offset, 
  uint vertex_stride);

fn void cmd_bind_transform_feedback_buffers_ext(
  VkCommandBuffer command_buffer, 
  uint first_binding, 
  uint binding_count, 
  VkBuffer * p_buffers, 
  VkDeviceSize * p_offsets, 
  VkDeviceSize * p_sizes)
@extern("vkCmdBindTransformFeedbackBuffersEXT");

fn void cmd_begin_transform_feedback_ext(
  VkCommandBuffer command_buffer, 
  uint first_counter_buffer, 
  uint counter_buffer_count, 
  VkBuffer * p_counter_buffers, 
  VkDeviceSize * p_counter_buffer_offsets)
@extern("vkCmdBeginTransformFeedbackEXT");

fn void cmd_end_transform_feedback_ext(
  VkCommandBuffer command_buffer, 
  uint first_counter_buffer, 
  uint counter_buffer_count, 
  VkBuffer * p_counter_buffers, 
  VkDeviceSize * p_counter_buffer_offsets)
@extern("vkCmdEndTransformFeedbackEXT");

fn void cmd_begin_query_indexed_ext(
  VkCommandBuffer command_buffer, 
  VkQueryPool query_pool, 
  uint query, 
  VkQueryControlFlags flags, 
  uint index)
@extern("vkCmdBeginQueryIndexedEXT");

fn void cmd_end_query_indexed_ext(
  VkCommandBuffer command_buffer, 
  VkQueryPool query_pool, 
  uint query, 
  uint index)
@extern("vkCmdEndQueryIndexedEXT");

fn void cmd_draw_indirect_byte_count_ext(
  VkCommandBuffer command_buffer, 
  uint instance_count, 
  uint first_instance, 
  VkBuffer counter_buffer, 
  VkDeviceSize counter_buffer_offset, 
  uint counter_offset, 
  uint vertex_stride)
@extern("vkCmdDrawIndirectByteCountEXT");

struct VkImageViewHandleInfoNVX {
  VkStructureType s_type;
  void * p_next;
  VkImageView image_view;
  VkDescriptorType descriptor_type;
  VkSampler sampler;
}

alias PFN_vkGetImageViewHandleNVX = fn uint(
  VkDevice device, 
  VkImageViewHandleInfoNVX * p_info);

fn uint get_image_view_handle_nvx(
  VkDevice device, 
  VkImageViewHandleInfoNVX * p_info)
@extern("vkGetImageViewHandleNVX");

alias PFN_vkCmdDrawIndirectCountAMD = fn void(
  VkCommandBuffer command_buffer, 
  VkBuffer buffer, 
  VkDeviceSize offset, 
  VkBuffer count_buffer, 
  VkDeviceSize count_buffer_offset, 
  uint max_draw_count, 
  uint stride);

alias PFN_vkCmdDrawIndexedIndirectCountAMD = fn void(
  VkCommandBuffer command_buffer, 
  VkBuffer buffer, 
  VkDeviceSize offset, 
  VkBuffer count_buffer, 
  VkDeviceSize count_buffer_offset, 
  uint max_draw_count, 
  uint stride);

fn void cmd_draw_indirect_count_amd(
  VkCommandBuffer command_buffer, 
  VkBuffer buffer, 
  VkDeviceSize offset, 
  VkBuffer count_buffer, 
  VkDeviceSize count_buffer_offset, 
  uint max_draw_count, 
  uint stride)
@extern("vkCmdDrawIndirectCountAMD");

fn void cmd_draw_indexed_indirect_count_amd(
  VkCommandBuffer command_buffer, 
  VkBuffer buffer, 
  VkDeviceSize offset, 
  VkBuffer count_buffer, 
  VkDeviceSize count_buffer_offset, 
  uint max_draw_count, 
  uint stride)
@extern("vkCmdDrawIndexedIndirectCountAMD");

struct VkTextureLODGatherFormatPropertiesAMD {
  VkStructureType s_type;
  void * p_next;
  VkBool32 supports_texture_gather_lodbias_amd;
}

typedef VkShaderInfoTypeAMD = inline CUInt;
const VkShaderInfoTypeAMD SHADER_INFO_TYPE_STATISTICS_AMD = 0;
const VkShaderInfoTypeAMD SHADER_INFO_TYPE_BINARY_AMD = 1;
const VkShaderInfoTypeAMD SHADER_INFO_TYPE_DISASSEMBLY_AMD = 2;
const VkShaderInfoTypeAMD SHADER_INFO_TYPE_BEGIN_RANGE_AMD = SHADER_INFO_TYPE_STATISTICS_AMD;
const VkShaderInfoTypeAMD SHADER_INFO_TYPE_END_RANGE_AMD = SHADER_INFO_TYPE_DISASSEMBLY_AMD;
const VkShaderInfoTypeAMD SHADER_INFO_TYPE_RANGE_SIZE_AMD = (SHADER_INFO_TYPE_DISASSEMBLY_AMD-SHADER_INFO_TYPE_STATISTICS_AMD+1);
const VkShaderInfoTypeAMD SHADER_INFO_TYPE_MAX_ENUM_AMD = 0x7FFFFFFF;

struct VkShaderResourceUsageAMD {
  uint num_used_vgprs;
  uint num_used_sgprs;
  uint lds_size_per_local_work_group;
  usz lds_usage_size_in_bytes;
  usz scratch_mem_usage_in_bytes;
}

struct VkShaderStatisticsInfoAMD {
  VkShaderStageFlags shader_stage_mask;
  VkShaderResourceUsageAMD resource_usage;
  uint num_physical_vgprs;
  uint num_physical_sgprs;
  uint num_available_vgprs;
  uint num_available_sgprs;
  uint[3] compute_work_group_size;
}

alias PFN_vkGetShaderInfoAMD = fn VkResult(
  VkDevice device, 
  VkPipeline pipeline, 
  VkShaderStageFlagBits shader_stage, 
  VkShaderInfoTypeAMD info_type, 
  usz * p_info_size, 
  void * p_info);

fn VkResult get_shader_info_amd(
  VkDevice device, 
  VkPipeline pipeline, 
  VkShaderStageFlagBits shader_stage, 
  VkShaderInfoTypeAMD info_type, 
  usz * p_info_size, 
  void * p_info)
@extern("vkGetShaderInfoAMD");

struct VkPhysicalDeviceCornerSampledImageFeaturesNV {
  VkStructureType s_type;
  void * p_next;
  VkBool32 corner_sampled_image;
}

typedef VkExternalMemoryHandleTypeFlagBitsNV = inline CUInt;
const VkExternalMemoryHandleTypeFlagBitsNV EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV = 0x00000001;
const VkExternalMemoryHandleTypeFlagBitsNV EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV = 0x00000002;
const VkExternalMemoryHandleTypeFlagBitsNV EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV = 0x00000004;
const VkExternalMemoryHandleTypeFlagBitsNV EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV = 0x00000008;
const VkExternalMemoryHandleTypeFlagBitsNV EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF;

alias VkExternalMemoryHandleTypeFlagsNV = VkFlags;

typedef VkExternalMemoryFeatureFlagBitsNV = inline CUInt;
const VkExternalMemoryFeatureFlagBitsNV EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV = 0x00000001;
const VkExternalMemoryFeatureFlagBitsNV EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV = 0x00000002;
const VkExternalMemoryFeatureFlagBitsNV EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV = 0x00000004;
const VkExternalMemoryFeatureFlagBitsNV EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF;

alias VkExternalMemoryFeatureFlagsNV = VkFlags;

struct VkExternalImageFormatPropertiesNV {
  VkImageFormatProperties image_format_properties;
  VkExternalMemoryFeatureFlagsNV external_memory_features;
  VkExternalMemoryHandleTypeFlagsNV export_from_imported_handle_types;
  VkExternalMemoryHandleTypeFlagsNV compatible_handle_types;
}

alias PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV = fn VkResult(
  VkPhysicalDevice physical_device, 
  VkFormat format, 
  VkImageType type, 
  VkImageTiling tiling, 
  VkImageUsageFlags usage, 
  VkImageCreateFlags flags, 
  VkExternalMemoryHandleTypeFlagsNV external_handle_type, 
  VkExternalImageFormatPropertiesNV * p_external_image_format_properties);

fn VkResult get_physical_device_external_image_format_properties_nv(
  VkPhysicalDevice physical_device, 
  VkFormat format, 
  VkImageType type, 
  VkImageTiling tiling, 
  VkImageUsageFlags usage, 
  VkImageCreateFlags flags, 
  VkExternalMemoryHandleTypeFlagsNV external_handle_type, 
  VkExternalImageFormatPropertiesNV * p_external_image_format_properties)
@extern("vkGetPhysicalDeviceExternalImageFormatPropertiesNV");

struct VkExternalMemoryImageCreateInfoNV {
  VkStructureType s_type;
  void * p_next;
  VkExternalMemoryHandleTypeFlagsNV handle_types;
}

struct VkExportMemoryAllocateInfoNV {
  VkStructureType s_type;
  void * p_next;
  VkExternalMemoryHandleTypeFlagsNV handle_types;
}

typedef VkValidationCheckEXT = inline CUInt;
const VkValidationCheckEXT VALIDATION_CHECK_ALL_EXT = 0;
const VkValidationCheckEXT VALIDATION_CHECK_SHADERS_EXT = 1;
const VkValidationCheckEXT VALIDATION_CHECK_BEGIN_RANGE_EXT = VALIDATION_CHECK_ALL_EXT;
const VkValidationCheckEXT VALIDATION_CHECK_END_RANGE_EXT = VALIDATION_CHECK_SHADERS_EXT;
const VkValidationCheckEXT VALIDATION_CHECK_RANGE_SIZE_EXT = (VALIDATION_CHECK_SHADERS_EXT-VALIDATION_CHECK_ALL_EXT+1);
const VkValidationCheckEXT VALIDATION_CHECK_MAX_ENUM_EXT = 0x7FFFFFFF;

struct VkValidationFlagsEXT {
  VkStructureType s_type;
  void * p_next;
  uint disabled_validation_check_count;
  VkValidationCheckEXT * p_disabled_validation_checks;
}

struct VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT {
  VkStructureType s_type;
  void * p_next;
  VkBool32 texture_compression_astc__hdr;
}

struct VkImageViewASTCDecodeModeEXT {
  VkStructureType s_type;
  void * p_next;
  VkFormat decode_mode;
}

struct VkPhysicalDeviceASTCDecodeFeaturesEXT {
  VkStructureType s_type;
  void * p_next;
  VkBool32 decode_mode_shared_exponent;
}

typedef VkConditionalRenderingFlagBitsEXT = inline CUInt;
const VkConditionalRenderingFlagBitsEXT CONDITIONAL_RENDERING_INVERTED_BIT_EXT = 0x00000001;
const VkConditionalRenderingFlagBitsEXT CONDITIONAL_RENDERING_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF;

alias VkConditionalRenderingFlagsEXT = VkFlags;

struct VkConditionalRenderingBeginInfoEXT {
  VkStructureType s_type;
  void * p_next;
  VkBuffer buffer;
  VkDeviceSize offset;
  VkConditionalRenderingFlagsEXT flags;
}

struct VkPhysicalDeviceConditionalRenderingFeaturesEXT {
  VkStructureType s_type;
  void * p_next;
  VkBool32 conditional_rendering;
  VkBool32 inherited_conditional_rendering;
}

struct VkCommandBufferInheritanceConditionalRenderingInfoEXT {
  VkStructureType s_type;
  void * p_next;
  VkBool32 conditional_rendering_enable;
}

alias PFN_vkCmdBeginConditionalRenderingEXT = fn void(
  VkCommandBuffer command_buffer, 
  VkConditionalRenderingBeginInfoEXT * p_conditional_rendering_begin);

alias PFN_vkCmdEndConditionalRenderingEXT = fn void(  VkCommandBuffer command_buffer);

fn void cmd_begin_conditional_rendering_ext(
  VkCommandBuffer command_buffer, 
  VkConditionalRenderingBeginInfoEXT * p_conditional_rendering_begin)
@extern("vkCmdBeginConditionalRenderingEXT");

fn void cmd_end_conditional_rendering_ext(
  VkCommandBuffer command_buffer)
@extern("vkCmdEndConditionalRenderingEXT");

typedef VkObjectTableNVX_T = void;

alias VkObjectTableNVX = VkObjectTableNVX_T *;

typedef VkIndirectCommandsLayoutNVX_T = void;

alias VkIndirectCommandsLayoutNVX = VkIndirectCommandsLayoutNVX_T *;

typedef VkIndirectCommandsTokenTypeNVX = inline CUInt;
const VkIndirectCommandsTokenTypeNVX INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX = 0;
const VkIndirectCommandsTokenTypeNVX INDIRECT_COMMANDS_TOKEN_TYPE_DESCRIPTOR_SET_NVX = 1;
const VkIndirectCommandsTokenTypeNVX INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NVX = 2;
const VkIndirectCommandsTokenTypeNVX INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NVX = 3;
const VkIndirectCommandsTokenTypeNVX INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NVX = 4;
const VkIndirectCommandsTokenTypeNVX INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NVX = 5;
const VkIndirectCommandsTokenTypeNVX INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NVX = 6;
const VkIndirectCommandsTokenTypeNVX INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX = 7;
const VkIndirectCommandsTokenTypeNVX INDIRECT_COMMANDS_TOKEN_TYPE_BEGIN_RANGE_NVX = INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX;
const VkIndirectCommandsTokenTypeNVX INDIRECT_COMMANDS_TOKEN_TYPE_END_RANGE_NVX = INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX;
const VkIndirectCommandsTokenTypeNVX INDIRECT_COMMANDS_TOKEN_TYPE_RANGE_SIZE_NVX = (INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX-INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX+1);
const VkIndirectCommandsTokenTypeNVX INDIRECT_COMMANDS_TOKEN_TYPE_MAX_ENUM_NVX = 0x7FFFFFFF;

typedef VkObjectEntryTypeNVX = inline CUInt;
const VkObjectEntryTypeNVX OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX = 0;
const VkObjectEntryTypeNVX OBJECT_ENTRY_TYPE_PIPELINE_NVX = 1;
const VkObjectEntryTypeNVX OBJECT_ENTRY_TYPE_INDEX_BUFFER_NVX = 2;
const VkObjectEntryTypeNVX OBJECT_ENTRY_TYPE_VERTEX_BUFFER_NVX = 3;
const VkObjectEntryTypeNVX OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX = 4;
const VkObjectEntryTypeNVX OBJECT_ENTRY_TYPE_BEGIN_RANGE_NVX = OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX;
const VkObjectEntryTypeNVX OBJECT_ENTRY_TYPE_END_RANGE_NVX = OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX;
const VkObjectEntryTypeNVX OBJECT_ENTRY_TYPE_RANGE_SIZE_NVX = (OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX-OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX+1);
const VkObjectEntryTypeNVX OBJECT_ENTRY_TYPE_MAX_ENUM_NVX = 0x7FFFFFFF;

typedef VkIndirectCommandsLayoutUsageFlagBitsNVX = inline CUInt;
const VkIndirectCommandsLayoutUsageFlagBitsNVX INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX = 0x00000001;
const VkIndirectCommandsLayoutUsageFlagBitsNVX INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX = 0x00000002;
const VkIndirectCommandsLayoutUsageFlagBitsNVX INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX = 0x00000004;
const VkIndirectCommandsLayoutUsageFlagBitsNVX INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX = 0x00000008;
const VkIndirectCommandsLayoutUsageFlagBitsNVX INDIRECT_COMMANDS_LAYOUT_USAGE_FLAG_BITS_MAX_ENUM_NVX = 0x7FFFFFFF;

alias VkIndirectCommandsLayoutUsageFlagsNVX = VkFlags;

typedef VkObjectEntryUsageFlagBitsNVX = inline CUInt;
const VkObjectEntryUsageFlagBitsNVX OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX = 0x00000001;
const VkObjectEntryUsageFlagBitsNVX OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX = 0x00000002;
const VkObjectEntryUsageFlagBitsNVX OBJECT_ENTRY_USAGE_FLAG_BITS_MAX_ENUM_NVX = 0x7FFFFFFF;

alias VkObjectEntryUsageFlagsNVX = VkFlags;

struct VkDeviceGeneratedCommandsFeaturesNVX {
  VkStructureType s_type;
  void * p_next;
  VkBool32 compute_binding_point_support;
}

struct VkDeviceGeneratedCommandsLimitsNVX {
  VkStructureType s_type;
  void * p_next;
  uint max_indirect_commands_layout_token_count;
  uint max_object_entry_counts;
  uint min_sequence_count_buffer_offset_alignment;
  uint min_sequence_index_buffer_offset_alignment;
  uint min_commands_token_buffer_offset_alignment;
}

struct VkIndirectCommandsTokenNVX {
  VkIndirectCommandsTokenTypeNVX token_type;
  VkBuffer buffer;
  VkDeviceSize offset;
}

struct VkIndirectCommandsLayoutTokenNVX {
  VkIndirectCommandsTokenTypeNVX token_type;
  uint binding_unit;
  uint dynamic_count;
  uint divisor;
}

struct VkIndirectCommandsLayoutCreateInfoNVX {
  VkStructureType s_type;
  void * p_next;
  VkPipelineBindPoint pipeline_bind_point;
  VkIndirectCommandsLayoutUsageFlagsNVX flags;
  uint token_count;
  VkIndirectCommandsLayoutTokenNVX * p_tokens;
}

struct VkCmdProcessCommandsInfoNVX {
  VkStructureType s_type;
  void * p_next;
  VkObjectTableNVX object_table;
  VkIndirectCommandsLayoutNVX indirect_commands_layout;
  uint indirect_commands_token_count;
  VkIndirectCommandsTokenNVX * p_indirect_commands_tokens;
  uint max_sequences_count;
  VkCommandBuffer target_command_buffer;
  VkBuffer sequences_count_buffer;
  VkDeviceSize sequences_count_offset;
  VkBuffer sequences_index_buffer;
  VkDeviceSize sequences_index_offset;
}

struct VkCmdReserveSpaceForCommandsInfoNVX {
  VkStructureType s_type;
  void * p_next;
  VkObjectTableNVX object_table;
  VkIndirectCommandsLayoutNVX indirect_commands_layout;
  uint max_sequences_count;
}

struct VkObjectTableCreateInfoNVX {
  VkStructureType s_type;
  void * p_next;
  uint object_count;
  VkObjectEntryTypeNVX * p_object_entry_types;
  uint * p_object_entry_counts;
  VkObjectEntryUsageFlagsNVX * p_object_entry_usage_flags;
  uint max_uniform_buffers_per_descriptor;
  uint max_storage_buffers_per_descriptor;
  uint max_storage_images_per_descriptor;
  uint max_sampled_images_per_descriptor;
  uint max_pipeline_layouts;
}

struct VkObjectTableEntryNVX {
  VkObjectEntryTypeNVX type;
  VkObjectEntryUsageFlagsNVX flags;
}

struct VkObjectTablePipelineEntryNVX {
  VkObjectEntryTypeNVX type;
  VkObjectEntryUsageFlagsNVX flags;
  VkPipeline pipeline;
}

struct VkObjectTableDescriptorSetEntryNVX {
  VkObjectEntryTypeNVX type;
  VkObjectEntryUsageFlagsNVX flags;
  VkPipelineLayout pipeline_layout;
  VkDescriptorSet descriptor_set;
}

struct VkObjectTableVertexBufferEntryNVX {
  VkObjectEntryTypeNVX type;
  VkObjectEntryUsageFlagsNVX flags;
  VkBuffer buffer;
}

struct VkObjectTableIndexBufferEntryNVX {
  VkObjectEntryTypeNVX type;
  VkObjectEntryUsageFlagsNVX flags;
  VkBuffer buffer;
  VkIndexType index_type;
}

struct VkObjectTablePushConstantEntryNVX {
  VkObjectEntryTypeNVX type;
  VkObjectEntryUsageFlagsNVX flags;
  VkPipelineLayout pipeline_layout;
  VkShaderStageFlags stage_flags;
}

alias PFN_vkCmdProcessCommandsNVX = fn void(
  VkCommandBuffer command_buffer, 
  VkCmdProcessCommandsInfoNVX * p_process_commands_info);

alias PFN_vkCmdReserveSpaceForCommandsNVX = fn void(
  VkCommandBuffer command_buffer, 
  VkCmdReserveSpaceForCommandsInfoNVX * p_reserve_space_info);

alias PFN_vkCreateIndirectCommandsLayoutNVX = fn VkResult(
  VkDevice device, 
  VkIndirectCommandsLayoutCreateInfoNVX * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkIndirectCommandsLayoutNVX * p_indirect_commands_layout);

alias PFN_vkDestroyIndirectCommandsLayoutNVX = fn void(
  VkDevice device, 
  VkIndirectCommandsLayoutNVX indirect_commands_layout, 
  VkAllocationCallbacks * p_allocator);

alias PFN_vkCreateObjectTableNVX = fn VkResult(
  VkDevice device, 
  VkObjectTableCreateInfoNVX * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkObjectTableNVX * p_object_table);

alias PFN_vkDestroyObjectTableNVX = fn void(
  VkDevice device, 
  VkObjectTableNVX object_table, 
  VkAllocationCallbacks * p_allocator);

alias PFN_vkRegisterObjectsNVX = fn VkResult(
  VkDevice device, 
  VkObjectTableNVX object_table, 
  uint object_count, 
  VkObjectTableEntryNVX ** pp_object_table_entries, 
  uint * p_object_indices);

alias PFN_vkUnregisterObjectsNVX = fn VkResult(
  VkDevice device, 
  VkObjectTableNVX object_table, 
  uint object_count, 
  VkObjectEntryTypeNVX * p_object_entry_types, 
  uint * p_object_indices);

alias PFN_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX = fn void(
  VkPhysicalDevice physical_device, 
  VkDeviceGeneratedCommandsFeaturesNVX * p_features, 
  VkDeviceGeneratedCommandsLimitsNVX * p_limits);

fn void cmd_process_commands_nvx(
  VkCommandBuffer command_buffer, 
  VkCmdProcessCommandsInfoNVX * p_process_commands_info)
@extern("vkCmdProcessCommandsNVX");

fn void cmd_reserve_space_for_commands_nvx(
  VkCommandBuffer command_buffer, 
  VkCmdReserveSpaceForCommandsInfoNVX * p_reserve_space_info)
@extern("vkCmdReserveSpaceForCommandsNVX");

fn VkResult create_indirect_commands_layout_nvx(
  VkDevice device, 
  VkIndirectCommandsLayoutCreateInfoNVX * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkIndirectCommandsLayoutNVX * p_indirect_commands_layout)
@extern("vkCreateIndirectCommandsLayoutNVX");

fn void destroy_indirect_commands_layout_nvx(
  VkDevice device, 
  VkIndirectCommandsLayoutNVX indirect_commands_layout, 
  VkAllocationCallbacks * p_allocator)
@extern("vkDestroyIndirectCommandsLayoutNVX");

fn VkResult create_object_table_nvx(
  VkDevice device, 
  VkObjectTableCreateInfoNVX * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkObjectTableNVX * p_object_table)
@extern("vkCreateObjectTableNVX");

fn void destroy_object_table_nvx(
  VkDevice device, 
  VkObjectTableNVX object_table, 
  VkAllocationCallbacks * p_allocator)
@extern("vkDestroyObjectTableNVX");

fn VkResult register_objects_nvx(
  VkDevice device, 
  VkObjectTableNVX object_table, 
  uint object_count, 
  VkObjectTableEntryNVX ** pp_object_table_entries, 
  uint * p_object_indices)
@extern("vkRegisterObjectsNVX");

fn VkResult unregister_objects_nvx(
  VkDevice device, 
  VkObjectTableNVX object_table, 
  uint object_count, 
  VkObjectEntryTypeNVX * p_object_entry_types, 
  uint * p_object_indices)
@extern("vkUnregisterObjectsNVX");

fn void get_physical_device_generated_commands_properties_nvx(
  VkPhysicalDevice physical_device, 
  VkDeviceGeneratedCommandsFeaturesNVX * p_features, 
  VkDeviceGeneratedCommandsLimitsNVX * p_limits)
@extern("vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX");

struct VkViewportWScalingNV {
  float xcoeff;
  float ycoeff;
}

struct VkPipelineViewportWScalingStateCreateInfoNV {
  VkStructureType s_type;
  void * p_next;
  VkBool32 viewport_wscaling_enable;
  uint viewport_count;
  VkViewportWScalingNV * p_viewport_wscalings;
}

alias PFN_vkCmdSetViewportWScalingNV = fn void(
  VkCommandBuffer command_buffer, 
  uint first_viewport, 
  uint viewport_count, 
  VkViewportWScalingNV * p_viewport_wscalings);

fn void cmd_set_viewport_wscaling_nv(
  VkCommandBuffer command_buffer, 
  uint first_viewport, 
  uint viewport_count, 
  VkViewportWScalingNV * p_viewport_wscalings)
@extern("vkCmdSetViewportWScalingNV");

alias PFN_vkReleaseDisplayEXT = fn VkResult(
  VkPhysicalDevice physical_device, 
  VkDisplayKHR display);

fn VkResult release_display_ext(
  VkPhysicalDevice physical_device, 
  VkDisplayKHR display)
@extern("vkReleaseDisplayEXT");

typedef VkSurfaceCounterFlagBitsEXT = inline CUInt;
const VkSurfaceCounterFlagBitsEXT SURFACE_COUNTER_VBLANK_EXT = 0x00000001;
const VkSurfaceCounterFlagBitsEXT SURFACE_COUNTER_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF;

alias VkSurfaceCounterFlagsEXT = VkFlags;

struct VkSurfaceCapabilities2EXT {
  VkStructureType s_type;
  void * p_next;
  uint min_image_count;
  uint max_image_count;
  VkExtent2D current_extent;
  VkExtent2D min_image_extent;
  VkExtent2D max_image_extent;
  uint max_image_array_layers;
  VkSurfaceTransformFlagsKHR supported_transforms;
  VkSurfaceTransformFlagBitsKHR current_transform;
  VkCompositeAlphaFlagsKHR supported_composite_alpha;
  VkImageUsageFlags supported_usage_flags;
  VkSurfaceCounterFlagsEXT supported_surface_counters;
}

alias PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT = fn VkResult(
  VkPhysicalDevice physical_device, 
  VkSurfaceKHR surface, 
  VkSurfaceCapabilities2EXT * p_surface_capabilities);

fn VkResult get_physical_device_surface_capabilities_2_ext(
  VkPhysicalDevice physical_device, 
  VkSurfaceKHR surface, 
  VkSurfaceCapabilities2EXT * p_surface_capabilities)
@extern("vkGetPhysicalDeviceSurfaceCapabilities2EXT");

typedef VkDisplayPowerStateEXT = inline CUInt;
const VkDisplayPowerStateEXT DISPLAY_POWER_STATE_OFF_EXT = 0;
const VkDisplayPowerStateEXT DISPLAY_POWER_STATE_SUSPEND_EXT = 1;
const VkDisplayPowerStateEXT DISPLAY_POWER_STATE_ON_EXT = 2;
const VkDisplayPowerStateEXT DISPLAY_POWER_STATE_BEGIN_RANGE_EXT = DISPLAY_POWER_STATE_OFF_EXT;
const VkDisplayPowerStateEXT DISPLAY_POWER_STATE_END_RANGE_EXT = DISPLAY_POWER_STATE_ON_EXT;
const VkDisplayPowerStateEXT DISPLAY_POWER_STATE_RANGE_SIZE_EXT = (DISPLAY_POWER_STATE_ON_EXT-DISPLAY_POWER_STATE_OFF_EXT+1);
const VkDisplayPowerStateEXT DISPLAY_POWER_STATE_MAX_ENUM_EXT = 0x7FFFFFFF;

typedef VkDeviceEventTypeEXT = inline CUInt;
const VkDeviceEventTypeEXT DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT = 0;
const VkDeviceEventTypeEXT DEVICE_EVENT_TYPE_BEGIN_RANGE_EXT = DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT;
const VkDeviceEventTypeEXT DEVICE_EVENT_TYPE_END_RANGE_EXT = DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT;
const VkDeviceEventTypeEXT DEVICE_EVENT_TYPE_RANGE_SIZE_EXT = (DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT-DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT+1);
const VkDeviceEventTypeEXT DEVICE_EVENT_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF;

typedef VkDisplayEventTypeEXT = inline CUInt;
const VkDisplayEventTypeEXT DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT = 0;
const VkDisplayEventTypeEXT DISPLAY_EVENT_TYPE_BEGIN_RANGE_EXT = DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT;
const VkDisplayEventTypeEXT DISPLAY_EVENT_TYPE_END_RANGE_EXT = DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT;
const VkDisplayEventTypeEXT DISPLAY_EVENT_TYPE_RANGE_SIZE_EXT = (DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT-DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT+1);
const VkDisplayEventTypeEXT DISPLAY_EVENT_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF;

struct VkDisplayPowerInfoEXT {
  VkStructureType s_type;
  void * p_next;
  VkDisplayPowerStateEXT power_state;
}

struct VkDeviceEventInfoEXT {
  VkStructureType s_type;
  void * p_next;
  VkDeviceEventTypeEXT device_event;
}

struct VkDisplayEventInfoEXT {
  VkStructureType s_type;
  void * p_next;
  VkDisplayEventTypeEXT display_event;
}

struct VkSwapchainCounterCreateInfoEXT {
  VkStructureType s_type;
  void * p_next;
  VkSurfaceCounterFlagsEXT surface_counters;
}

alias PFN_vkDisplayPowerControlEXT = fn VkResult(
  VkDevice device, 
  VkDisplayKHR display, 
  VkDisplayPowerInfoEXT * p_display_power_info);

alias PFN_vkRegisterDeviceEventEXT = fn VkResult(
  VkDevice device, 
  VkDeviceEventInfoEXT * p_device_event_info, 
  VkAllocationCallbacks * p_allocator, 
  VkFence * p_fence);

alias PFN_vkRegisterDisplayEventEXT = fn VkResult(
  VkDevice device, 
  VkDisplayKHR display, 
  VkDisplayEventInfoEXT * p_display_event_info, 
  VkAllocationCallbacks * p_allocator, 
  VkFence * p_fence);

alias PFN_vkGetSwapchainCounterEXT = fn VkResult(
  VkDevice device, 
  VkSwapchainKHR swapchain, 
  VkSurfaceCounterFlagBitsEXT counter, 
  ulong * p_counter_value);

fn VkResult display_power_control_ext(
  VkDevice device, 
  VkDisplayKHR display, 
  VkDisplayPowerInfoEXT * p_display_power_info)
@extern("vkDisplayPowerControlEXT");

fn VkResult register_device_event_ext(
  VkDevice device, 
  VkDeviceEventInfoEXT * p_device_event_info, 
  VkAllocationCallbacks * p_allocator, 
  VkFence * p_fence)
@extern("vkRegisterDeviceEventEXT");

fn VkResult register_display_event_ext(
  VkDevice device, 
  VkDisplayKHR display, 
  VkDisplayEventInfoEXT * p_display_event_info, 
  VkAllocationCallbacks * p_allocator, 
  VkFence * p_fence)
@extern("vkRegisterDisplayEventEXT");

fn VkResult get_swapchain_counter_ext(
  VkDevice device, 
  VkSwapchainKHR swapchain, 
  VkSurfaceCounterFlagBitsEXT counter, 
  ulong * p_counter_value)
@extern("vkGetSwapchainCounterEXT");

struct VkRefreshCycleDurationGOOGLE {
  ulong refresh_duration;
}

struct VkPastPresentationTimingGOOGLE {
  uint present_id;
  ulong desired_present_time;
  ulong actual_present_time;
  ulong earliest_present_time;
  ulong present_margin;
}

struct VkPresentTimeGOOGLE {
  uint present_id;
  ulong desired_present_time;
}

struct VkPresentTimesInfoGOOGLE {
  VkStructureType s_type;
  void * p_next;
  uint swapchain_count;
  VkPresentTimeGOOGLE * p_times;
}

alias PFN_vkGetRefreshCycleDurationGOOGLE = fn VkResult(
  VkDevice device, 
  VkSwapchainKHR swapchain, 
  VkRefreshCycleDurationGOOGLE * p_display_timing_properties);

alias PFN_vkGetPastPresentationTimingGOOGLE = fn VkResult(
  VkDevice device, 
  VkSwapchainKHR swapchain, 
  uint * p_presentation_timing_count, 
  VkPastPresentationTimingGOOGLE * p_presentation_timings);

fn VkResult get_refresh_cycle_duration_google(
  VkDevice device, 
  VkSwapchainKHR swapchain, 
  VkRefreshCycleDurationGOOGLE * p_display_timing_properties)
@extern("vkGetRefreshCycleDurationGOOGLE");

fn VkResult get_past_presentation_timing_google(
  VkDevice device, 
  VkSwapchainKHR swapchain, 
  uint * p_presentation_timing_count, 
  VkPastPresentationTimingGOOGLE * p_presentation_timings)
@extern("vkGetPastPresentationTimingGOOGLE");

struct VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
  VkStructureType s_type;
  void * p_next;
  VkBool32 per_view_position_all_components;
}

typedef VkViewportCoordinateSwizzleNV = inline CUInt;
const VkViewportCoordinateSwizzleNV VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV = 0;
const VkViewportCoordinateSwizzleNV VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV = 1;
const VkViewportCoordinateSwizzleNV VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV = 2;
const VkViewportCoordinateSwizzleNV VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV = 3;
const VkViewportCoordinateSwizzleNV VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV = 4;
const VkViewportCoordinateSwizzleNV VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV = 5;
const VkViewportCoordinateSwizzleNV VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV = 6;
const VkViewportCoordinateSwizzleNV VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV = 7;
const VkViewportCoordinateSwizzleNV VIEWPORT_COORDINATE_SWIZZLE_BEGIN_RANGE_NV = VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV;
const VkViewportCoordinateSwizzleNV VIEWPORT_COORDINATE_SWIZZLE_END_RANGE_NV = VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV;
const VkViewportCoordinateSwizzleNV VIEWPORT_COORDINATE_SWIZZLE_RANGE_SIZE_NV = (VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV-VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV+1);
const VkViewportCoordinateSwizzleNV VIEWPORT_COORDINATE_SWIZZLE_MAX_ENUM_NV = 0x7FFFFFFF;

alias VkPipelineViewportSwizzleStateCreateFlagsNV = VkFlags;

struct VkViewportSwizzleNV {
  VkViewportCoordinateSwizzleNV x;
  VkViewportCoordinateSwizzleNV y;
  VkViewportCoordinateSwizzleNV z;
  VkViewportCoordinateSwizzleNV w;
}

struct VkPipelineViewportSwizzleStateCreateInfoNV {
  VkStructureType s_type;
  void * p_next;
  VkPipelineViewportSwizzleStateCreateFlagsNV flags;
  uint viewport_count;
  VkViewportSwizzleNV * p_viewport_swizzles;
}

typedef VkDiscardRectangleModeEXT = inline CUInt;
const VkDiscardRectangleModeEXT DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT = 0;
const VkDiscardRectangleModeEXT DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT = 1;
const VkDiscardRectangleModeEXT DISCARD_RECTANGLE_MODE_BEGIN_RANGE_EXT = DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT;
const VkDiscardRectangleModeEXT DISCARD_RECTANGLE_MODE_END_RANGE_EXT = DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT;
const VkDiscardRectangleModeEXT DISCARD_RECTANGLE_MODE_RANGE_SIZE_EXT = (DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT-DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT+1);
const VkDiscardRectangleModeEXT DISCARD_RECTANGLE_MODE_MAX_ENUM_EXT = 0x7FFFFFFF;

alias VkPipelineDiscardRectangleStateCreateFlagsEXT = VkFlags;

struct VkPhysicalDeviceDiscardRectanglePropertiesEXT {
  VkStructureType s_type;
  void * p_next;
  uint max_discard_rectangles;
}

struct VkPipelineDiscardRectangleStateCreateInfoEXT {
  VkStructureType s_type;
  void * p_next;
  VkPipelineDiscardRectangleStateCreateFlagsEXT flags;
  VkDiscardRectangleModeEXT discard_rectangle_mode;
  uint discard_rectangle_count;
  VkRect2D * p_discard_rectangles;
}

alias PFN_vkCmdSetDiscardRectangleEXT = fn void(
  VkCommandBuffer command_buffer, 
  uint first_discard_rectangle, 
  uint discard_rectangle_count, 
  VkRect2D * p_discard_rectangles);

fn void cmd_set_discard_rectangle_ext(
  VkCommandBuffer command_buffer, 
  uint first_discard_rectangle, 
  uint discard_rectangle_count, 
  VkRect2D * p_discard_rectangles)
@extern("vkCmdSetDiscardRectangleEXT");

typedef VkConservativeRasterizationModeEXT = inline CUInt;
const VkConservativeRasterizationModeEXT CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT = 0;
const VkConservativeRasterizationModeEXT CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT = 1;
const VkConservativeRasterizationModeEXT CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT = 2;
const VkConservativeRasterizationModeEXT CONSERVATIVE_RASTERIZATION_MODE_BEGIN_RANGE_EXT = CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT;
const VkConservativeRasterizationModeEXT CONSERVATIVE_RASTERIZATION_MODE_END_RANGE_EXT = CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT;
const VkConservativeRasterizationModeEXT CONSERVATIVE_RASTERIZATION_MODE_RANGE_SIZE_EXT = (CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT-CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT+1);
const VkConservativeRasterizationModeEXT CONSERVATIVE_RASTERIZATION_MODE_MAX_ENUM_EXT = 0x7FFFFFFF;

alias VkPipelineRasterizationConservativeStateCreateFlagsEXT = VkFlags;

struct VkPhysicalDeviceConservativeRasterizationPropertiesEXT {
  VkStructureType s_type;
  void * p_next;
  float primitive_overestimation_size;
  float max_extra_primitive_overestimation_size;
  float extra_primitive_overestimation_size_granularity;
  VkBool32 primitive_underestimation;
  VkBool32 conservative_point_and_line_rasterization;
  VkBool32 degenerate_triangles_rasterized;
  VkBool32 degenerate_lines_rasterized;
  VkBool32 fully_covered_fragment_shader_input_variable;
  VkBool32 conservative_rasterization_post_depth_coverage;
}

struct VkPipelineRasterizationConservativeStateCreateInfoEXT {
  VkStructureType s_type;
  void * p_next;
  VkPipelineRasterizationConservativeStateCreateFlagsEXT flags;
  VkConservativeRasterizationModeEXT conservative_rasterization_mode;
  float extra_primitive_overestimation_size;
}

alias VkPipelineRasterizationDepthClipStateCreateFlagsEXT = VkFlags;

struct VkPhysicalDeviceDepthClipEnableFeaturesEXT {
  VkStructureType s_type;
  void * p_next;
  VkBool32 depth_clip_enable;
}

struct VkPipelineRasterizationDepthClipStateCreateInfoEXT {
  VkStructureType s_type;
  void * p_next;
  VkPipelineRasterizationDepthClipStateCreateFlagsEXT flags;
  VkBool32 depth_clip_enable;
}

struct VkXYColorEXT {
  float x;
  float y;
}

struct VkHdrMetadataEXT {
  VkStructureType s_type;
  void * p_next;
  VkXYColorEXT display_primary_red;
  VkXYColorEXT display_primary_green;
  VkXYColorEXT display_primary_blue;
  VkXYColorEXT white_point;
  float max_luminance;
  float min_luminance;
  float max_content_light_level;
  float max_frame_average_light_level;
}

alias PFN_vkSetHdrMetadataEXT = fn void(
  VkDevice device, 
  uint swapchain_count, 
  VkSwapchainKHR * p_swapchains, 
  VkHdrMetadataEXT * p_metadata);

fn void set_hdr_metadata_ext(
  VkDevice device, 
  uint swapchain_count, 
  VkSwapchainKHR * p_swapchains, 
  VkHdrMetadataEXT * p_metadata)
@extern("vkSetHdrMetadataEXT");

typedef VkDebugUtilsMessengerEXT_T = void;

alias VkDebugUtilsMessengerEXT = VkDebugUtilsMessengerEXT_T *;

alias VkDebugUtilsMessengerCallbackDataFlagsEXT = VkFlags;

alias VkDebugUtilsMessengerCreateFlagsEXT = VkFlags;

typedef VkDebugUtilsMessageSeverityFlagBitsEXT = inline CUInt;
const VkDebugUtilsMessageSeverityFlagBitsEXT DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT = 0x00000001;
const VkDebugUtilsMessageSeverityFlagBitsEXT DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT = 0x00000010;
const VkDebugUtilsMessageSeverityFlagBitsEXT DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT = 0x00000100;
const VkDebugUtilsMessageSeverityFlagBitsEXT DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT = 0x00001000;
const VkDebugUtilsMessageSeverityFlagBitsEXT DEBUG_UTILS_MESSAGE_SEVERITY_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF;

alias VkDebugUtilsMessageSeverityFlagsEXT = VkFlags;

typedef VkDebugUtilsMessageTypeFlagBitsEXT = inline CUInt;
const VkDebugUtilsMessageTypeFlagBitsEXT DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT = 0x00000001;
const VkDebugUtilsMessageTypeFlagBitsEXT DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT = 0x00000002;
const VkDebugUtilsMessageTypeFlagBitsEXT DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT = 0x00000004;
const VkDebugUtilsMessageTypeFlagBitsEXT DEBUG_UTILS_MESSAGE_TYPE_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF;

alias VkDebugUtilsMessageTypeFlagsEXT = VkFlags;

struct VkDebugUtilsObjectNameInfoEXT {
  VkStructureType s_type;
  void * p_next;
  VkObjectType object_type;
  ulong object_handle;
  CChar * p_object_name;
}

struct VkDebugUtilsObjectTagInfoEXT {
  VkStructureType s_type;
  void * p_next;
  VkObjectType object_type;
  ulong object_handle;
  ulong tag_name;
  usz tag_size;
  void * p_tag;
}

struct VkDebugUtilsLabelEXT {
  VkStructureType s_type;
  void * p_next;
  CChar * p_label_name;
  float[4] color;
}

struct VkDebugUtilsMessengerCallbackDataEXT {
  VkStructureType s_type;
  void * p_next;
  VkDebugUtilsMessengerCallbackDataFlagsEXT flags;
  CChar * p_message_id_name;
  int message_id_number;
  CChar * p_message;
  uint queue_label_count;
  VkDebugUtilsLabelEXT * p_queue_labels;
  uint cmd_buf_label_count;
  VkDebugUtilsLabelEXT * p_cmd_buf_labels;
  uint object_count;
  VkDebugUtilsObjectNameInfoEXT * p_objects;
}

alias PFN_vkDebugUtilsMessengerCallbackEXT = fn VkBool32(
  VkDebugUtilsMessageSeverityFlagBitsEXT message_severity, 
  VkDebugUtilsMessageTypeFlagsEXT message_types, 
  VkDebugUtilsMessengerCallbackDataEXT * p_callback_data, 
  void * p_user_data);

struct VkDebugUtilsMessengerCreateInfoEXT {
  VkStructureType s_type;
  void * p_next;
  VkDebugUtilsMessengerCreateFlagsEXT flags;
  VkDebugUtilsMessageSeverityFlagsEXT message_severity;
  VkDebugUtilsMessageTypeFlagsEXT message_type;
  PFN_vkDebugUtilsMessengerCallbackEXT pfn_user_callback;
  void * p_user_data;
}

alias PFN_vkSetDebugUtilsObjectNameEXT = fn VkResult(
  VkDevice device, 
  VkDebugUtilsObjectNameInfoEXT * p_name_info);

alias PFN_vkSetDebugUtilsObjectTagEXT = fn VkResult(
  VkDevice device, 
  VkDebugUtilsObjectTagInfoEXT * p_tag_info);

alias PFN_vkQueueBeginDebugUtilsLabelEXT = fn void(
  VkQueue queue, 
  VkDebugUtilsLabelEXT * p_label_info);

alias PFN_vkQueueEndDebugUtilsLabelEXT = fn void(  VkQueue queue);

alias PFN_vkQueueInsertDebugUtilsLabelEXT = fn void(
  VkQueue queue, 
  VkDebugUtilsLabelEXT * p_label_info);

alias PFN_vkCmdBeginDebugUtilsLabelEXT = fn void(
  VkCommandBuffer command_buffer, 
  VkDebugUtilsLabelEXT * p_label_info);

alias PFN_vkCmdEndDebugUtilsLabelEXT = fn void(  VkCommandBuffer command_buffer);

alias PFN_vkCmdInsertDebugUtilsLabelEXT = fn void(
  VkCommandBuffer command_buffer, 
  VkDebugUtilsLabelEXT * p_label_info);

alias PFN_vkCreateDebugUtilsMessengerEXT = fn VkResult(
  VkInstance instance, 
  VkDebugUtilsMessengerCreateInfoEXT * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkDebugUtilsMessengerEXT * p_messenger);

alias PFN_vkDestroyDebugUtilsMessengerEXT = fn void(
  VkInstance instance, 
  VkDebugUtilsMessengerEXT messenger, 
  VkAllocationCallbacks * p_allocator);

alias PFN_vkSubmitDebugUtilsMessageEXT = fn void(
  VkInstance instance, 
  VkDebugUtilsMessageSeverityFlagBitsEXT message_severity, 
  VkDebugUtilsMessageTypeFlagsEXT message_types, 
  VkDebugUtilsMessengerCallbackDataEXT * p_callback_data);

fn VkResult set_debug_utils_object_name_ext(
  VkDevice device, 
  VkDebugUtilsObjectNameInfoEXT * p_name_info)
@extern("vkSetDebugUtilsObjectNameEXT");

fn VkResult set_debug_utils_object_tag_ext(
  VkDevice device, 
  VkDebugUtilsObjectTagInfoEXT * p_tag_info)
@extern("vkSetDebugUtilsObjectTagEXT");

fn void queue_begin_debug_utils_label_ext(
  VkQueue queue, 
  VkDebugUtilsLabelEXT * p_label_info)
@extern("vkQueueBeginDebugUtilsLabelEXT");

fn void queue_end_debug_utils_label_ext(
  VkQueue queue)
@extern("vkQueueEndDebugUtilsLabelEXT");

fn void queue_insert_debug_utils_label_ext(
  VkQueue queue, 
  VkDebugUtilsLabelEXT * p_label_info)
@extern("vkQueueInsertDebugUtilsLabelEXT");

fn void cmd_begin_debug_utils_label_ext(
  VkCommandBuffer command_buffer, 
  VkDebugUtilsLabelEXT * p_label_info)
@extern("vkCmdBeginDebugUtilsLabelEXT");

fn void cmd_end_debug_utils_label_ext(
  VkCommandBuffer command_buffer)
@extern("vkCmdEndDebugUtilsLabelEXT");

fn void cmd_insert_debug_utils_label_ext(
  VkCommandBuffer command_buffer, 
  VkDebugUtilsLabelEXT * p_label_info)
@extern("vkCmdInsertDebugUtilsLabelEXT");

fn VkResult create_debug_utils_messenger_ext(
  VkInstance instance, 
  VkDebugUtilsMessengerCreateInfoEXT * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkDebugUtilsMessengerEXT * p_messenger)
@extern("vkCreateDebugUtilsMessengerEXT");

fn void destroy_debug_utils_messenger_ext(
  VkInstance instance, 
  VkDebugUtilsMessengerEXT messenger, 
  VkAllocationCallbacks * p_allocator)
@extern("vkDestroyDebugUtilsMessengerEXT");

fn void submit_debug_utils_message_ext(
  VkInstance instance, 
  VkDebugUtilsMessageSeverityFlagBitsEXT message_severity, 
  VkDebugUtilsMessageTypeFlagsEXT message_types, 
  VkDebugUtilsMessengerCallbackDataEXT * p_callback_data)
@extern("vkSubmitDebugUtilsMessageEXT");

typedef VkSamplerReductionModeEXT = inline CUInt;
const VkSamplerReductionModeEXT SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT = 0;
const VkSamplerReductionModeEXT SAMPLER_REDUCTION_MODE_MIN_EXT = 1;
const VkSamplerReductionModeEXT SAMPLER_REDUCTION_MODE_MAX_EXT = 2;
const VkSamplerReductionModeEXT SAMPLER_REDUCTION_MODE_BEGIN_RANGE_EXT = SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT;
const VkSamplerReductionModeEXT SAMPLER_REDUCTION_MODE_END_RANGE_EXT = SAMPLER_REDUCTION_MODE_MAX_EXT;
const VkSamplerReductionModeEXT SAMPLER_REDUCTION_MODE_RANGE_SIZE_EXT = (SAMPLER_REDUCTION_MODE_MAX_EXT-SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT+1);
const VkSamplerReductionModeEXT SAMPLER_REDUCTION_MODE_MAX_ENUM_EXT = 0x7FFFFFFF;

struct VkSamplerReductionModeCreateInfoEXT {
  VkStructureType s_type;
  void * p_next;
  VkSamplerReductionModeEXT reduction_mode;
}

struct VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT {
  VkStructureType s_type;
  void * p_next;
  VkBool32 filter_minmax_single_component_formats;
  VkBool32 filter_minmax_image_component_mapping;
}

struct VkPhysicalDeviceInlineUniformBlockFeaturesEXT {
  VkStructureType s_type;
  void * p_next;
  VkBool32 inline_uniform_block;
  VkBool32 descriptor_binding_inline_uniform_block_update_after_bind;
}

struct VkPhysicalDeviceInlineUniformBlockPropertiesEXT {
  VkStructureType s_type;
  void * p_next;
  uint max_inline_uniform_block_size;
  uint max_per_stage_descriptor_inline_uniform_blocks;
  uint max_per_stage_descriptor_update_after_bind_inline_uniform_blocks;
  uint max_descriptor_set_inline_uniform_blocks;
  uint max_descriptor_set_update_after_bind_inline_uniform_blocks;
}

struct VkWriteDescriptorSetInlineUniformBlockEXT {
  VkStructureType s_type;
  void * p_next;
  uint data_size;
  void * p_data;
}

struct VkDescriptorPoolInlineUniformBlockCreateInfoEXT {
  VkStructureType s_type;
  void * p_next;
  uint max_inline_uniform_block_bindings;
}

struct VkSampleLocationEXT {
  float x;
  float y;
}

struct VkSampleLocationsInfoEXT {
  VkStructureType s_type;
  void * p_next;
  VkSampleCountFlagBits sample_locations_per_pixel;
  VkExtent2D sample_location_grid_size;
  uint sample_locations_count;
  VkSampleLocationEXT * p_sample_locations;
}

struct VkAttachmentSampleLocationsEXT {
  uint attachment_index;
  VkSampleLocationsInfoEXT sample_locations_info;
}

struct VkSubpassSampleLocationsEXT {
  uint subpass_index;
  VkSampleLocationsInfoEXT sample_locations_info;
}

struct VkRenderPassSampleLocationsBeginInfoEXT {
  VkStructureType s_type;
  void * p_next;
  uint attachment_initial_sample_locations_count;
  VkAttachmentSampleLocationsEXT * p_attachment_initial_sample_locations;
  uint post_subpass_sample_locations_count;
  VkSubpassSampleLocationsEXT * p_post_subpass_sample_locations;
}

struct VkPipelineSampleLocationsStateCreateInfoEXT {
  VkStructureType s_type;
  void * p_next;
  VkBool32 sample_locations_enable;
  VkSampleLocationsInfoEXT sample_locations_info;
}

struct VkPhysicalDeviceSampleLocationsPropertiesEXT {
  VkStructureType s_type;
  void * p_next;
  VkSampleCountFlags sample_location_sample_counts;
  VkExtent2D max_sample_location_grid_size;
  float[2] sample_location_coordinate_range;
  uint sample_location_sub_pixel_bits;
  VkBool32 variable_sample_locations;
}

struct VkMultisamplePropertiesEXT {
  VkStructureType s_type;
  void * p_next;
  VkExtent2D max_sample_location_grid_size;
}

alias PFN_vkCmdSetSampleLocationsEXT = fn void(
  VkCommandBuffer command_buffer, 
  VkSampleLocationsInfoEXT * p_sample_locations_info);

alias PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT = fn void(
  VkPhysicalDevice physical_device, 
  VkSampleCountFlagBits samples, 
  VkMultisamplePropertiesEXT * p_multisample_properties);

fn void cmd_set_sample_locations_ext(
  VkCommandBuffer command_buffer, 
  VkSampleLocationsInfoEXT * p_sample_locations_info)
@extern("vkCmdSetSampleLocationsEXT");

fn void get_physical_device_multisample_properties_ext(
  VkPhysicalDevice physical_device, 
  VkSampleCountFlagBits samples, 
  VkMultisamplePropertiesEXT * p_multisample_properties)
@extern("vkGetPhysicalDeviceMultisamplePropertiesEXT");

typedef VkBlendOverlapEXT = inline CUInt;
const VkBlendOverlapEXT BLEND_OVERLAP_UNCORRELATED_EXT = 0;
const VkBlendOverlapEXT BLEND_OVERLAP_DISJOINT_EXT = 1;
const VkBlendOverlapEXT BLEND_OVERLAP_CONJOINT_EXT = 2;
const VkBlendOverlapEXT BLEND_OVERLAP_BEGIN_RANGE_EXT = BLEND_OVERLAP_UNCORRELATED_EXT;
const VkBlendOverlapEXT BLEND_OVERLAP_END_RANGE_EXT = BLEND_OVERLAP_CONJOINT_EXT;
const VkBlendOverlapEXT BLEND_OVERLAP_RANGE_SIZE_EXT = (BLEND_OVERLAP_CONJOINT_EXT-BLEND_OVERLAP_UNCORRELATED_EXT+1);
const VkBlendOverlapEXT BLEND_OVERLAP_MAX_ENUM_EXT = 0x7FFFFFFF;

struct VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT {
  VkStructureType s_type;
  void * p_next;
  VkBool32 advanced_blend_coherent_operations;
}

struct VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT {
  VkStructureType s_type;
  void * p_next;
  uint advanced_blend_max_color_attachments;
  VkBool32 advanced_blend_independent_blend;
  VkBool32 advanced_blend_non_premultiplied_src_color;
  VkBool32 advanced_blend_non_premultiplied_dst_color;
  VkBool32 advanced_blend_correlated_overlap;
  VkBool32 advanced_blend_all_operations;
}

struct VkPipelineColorBlendAdvancedStateCreateInfoEXT {
  VkStructureType s_type;
  void * p_next;
  VkBool32 src_premultiplied;
  VkBool32 dst_premultiplied;
  VkBlendOverlapEXT blend_overlap;
}

alias VkPipelineCoverageToColorStateCreateFlagsNV = VkFlags;

struct VkPipelineCoverageToColorStateCreateInfoNV {
  VkStructureType s_type;
  void * p_next;
  VkPipelineCoverageToColorStateCreateFlagsNV flags;
  VkBool32 coverage_to_color_enable;
  uint coverage_to_color_location;
}

typedef VkCoverageModulationModeNV = inline CUInt;
const VkCoverageModulationModeNV COVERAGE_MODULATION_MODE_NONE_NV = 0;
const VkCoverageModulationModeNV COVERAGE_MODULATION_MODE_RGB_NV = 1;
const VkCoverageModulationModeNV COVERAGE_MODULATION_MODE_ALPHA_NV = 2;
const VkCoverageModulationModeNV COVERAGE_MODULATION_MODE_RGBA_NV = 3;
const VkCoverageModulationModeNV COVERAGE_MODULATION_MODE_BEGIN_RANGE_NV = COVERAGE_MODULATION_MODE_NONE_NV;
const VkCoverageModulationModeNV COVERAGE_MODULATION_MODE_END_RANGE_NV = COVERAGE_MODULATION_MODE_RGBA_NV;
const VkCoverageModulationModeNV COVERAGE_MODULATION_MODE_RANGE_SIZE_NV = (COVERAGE_MODULATION_MODE_RGBA_NV-COVERAGE_MODULATION_MODE_NONE_NV+1);
const VkCoverageModulationModeNV COVERAGE_MODULATION_MODE_MAX_ENUM_NV = 0x7FFFFFFF;

alias VkPipelineCoverageModulationStateCreateFlagsNV = VkFlags;

struct VkPipelineCoverageModulationStateCreateInfoNV {
  VkStructureType s_type;
  void * p_next;
  VkPipelineCoverageModulationStateCreateFlagsNV flags;
  VkCoverageModulationModeNV coverage_modulation_mode;
  VkBool32 coverage_modulation_table_enable;
  uint coverage_modulation_table_count;
  float * p_coverage_modulation_table;
}

struct VkPhysicalDeviceShaderSMBuiltinsPropertiesNV {
  VkStructureType s_type;
  void * p_next;
  uint shader_smcount;
  uint shader_warps_per_sm;
}

struct VkPhysicalDeviceShaderSMBuiltinsFeaturesNV {
  VkStructureType s_type;
  void * p_next;
  VkBool32 shader_smbuiltins;
}

struct VkDrmFormatModifierPropertiesEXT {
  ulong drm_format_modifier;
  uint drm_format_modifier_plane_count;
  VkFormatFeatureFlags drm_format_modifier_tiling_features;
}

struct VkDrmFormatModifierPropertiesListEXT {
  VkStructureType s_type;
  void * p_next;
  uint drm_format_modifier_count;
  VkDrmFormatModifierPropertiesEXT * p_drm_format_modifier_properties;
}

struct VkPhysicalDeviceImageDrmFormatModifierInfoEXT {
  VkStructureType s_type;
  void * p_next;
  ulong drm_format_modifier;
  VkSharingMode sharing_mode;
  uint queue_family_index_count;
  uint * p_queue_family_indices;
}

struct VkImageDrmFormatModifierListCreateInfoEXT {
  VkStructureType s_type;
  void * p_next;
  uint drm_format_modifier_count;
  ulong * p_drm_format_modifiers;
}

struct VkImageDrmFormatModifierExplicitCreateInfoEXT {
  VkStructureType s_type;
  void * p_next;
  ulong drm_format_modifier;
  uint drm_format_modifier_plane_count;
  VkSubresourceLayout * p_plane_layouts;
}

struct VkImageDrmFormatModifierPropertiesEXT {
  VkStructureType s_type;
  void * p_next;
  ulong drm_format_modifier;
}

alias PFN_vkGetImageDrmFormatModifierPropertiesEXT = fn VkResult(
  VkDevice device, 
  VkImage image, 
  VkImageDrmFormatModifierPropertiesEXT * p_properties);

fn VkResult get_image_drm_format_modifier_properties_ext(
  VkDevice device, 
  VkImage image, 
  VkImageDrmFormatModifierPropertiesEXT * p_properties)
@extern("vkGetImageDrmFormatModifierPropertiesEXT");

typedef VkValidationCacheEXT_T = void;

alias VkValidationCacheEXT = VkValidationCacheEXT_T *;

typedef VkValidationCacheHeaderVersionEXT = inline CUInt;
const VkValidationCacheHeaderVersionEXT VALIDATION_CACHE_HEADER_VERSION_ONE_EXT = 1;
const VkValidationCacheHeaderVersionEXT VALIDATION_CACHE_HEADER_VERSION_BEGIN_RANGE_EXT = VALIDATION_CACHE_HEADER_VERSION_ONE_EXT;
const VkValidationCacheHeaderVersionEXT VALIDATION_CACHE_HEADER_VERSION_END_RANGE_EXT = VALIDATION_CACHE_HEADER_VERSION_ONE_EXT;
const VkValidationCacheHeaderVersionEXT VALIDATION_CACHE_HEADER_VERSION_RANGE_SIZE_EXT = (VALIDATION_CACHE_HEADER_VERSION_ONE_EXT-VALIDATION_CACHE_HEADER_VERSION_ONE_EXT+1);
const VkValidationCacheHeaderVersionEXT VALIDATION_CACHE_HEADER_VERSION_MAX_ENUM_EXT = 0x7FFFFFFF;

alias VkValidationCacheCreateFlagsEXT = VkFlags;

struct VkValidationCacheCreateInfoEXT {
  VkStructureType s_type;
  void * p_next;
  VkValidationCacheCreateFlagsEXT flags;
  usz initial_data_size;
  void * p_initial_data;
}

struct VkShaderModuleValidationCacheCreateInfoEXT {
  VkStructureType s_type;
  void * p_next;
  VkValidationCacheEXT validation_cache;
}

alias PFN_vkCreateValidationCacheEXT = fn VkResult(
  VkDevice device, 
  VkValidationCacheCreateInfoEXT * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkValidationCacheEXT * p_validation_cache);

alias PFN_vkDestroyValidationCacheEXT = fn void(
  VkDevice device, 
  VkValidationCacheEXT validation_cache, 
  VkAllocationCallbacks * p_allocator);

alias PFN_vkMergeValidationCachesEXT = fn VkResult(
  VkDevice device, 
  VkValidationCacheEXT dst_cache, 
  uint src_cache_count, 
  VkValidationCacheEXT * p_src_caches);

alias PFN_vkGetValidationCacheDataEXT = fn VkResult(
  VkDevice device, 
  VkValidationCacheEXT validation_cache, 
  usz * p_data_size, 
  void * p_data);

fn VkResult create_validation_cache_ext(
  VkDevice device, 
  VkValidationCacheCreateInfoEXT * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkValidationCacheEXT * p_validation_cache)
@extern("vkCreateValidationCacheEXT");

fn void destroy_validation_cache_ext(
  VkDevice device, 
  VkValidationCacheEXT validation_cache, 
  VkAllocationCallbacks * p_allocator)
@extern("vkDestroyValidationCacheEXT");

fn VkResult merge_validation_caches_ext(
  VkDevice device, 
  VkValidationCacheEXT dst_cache, 
  uint src_cache_count, 
  VkValidationCacheEXT * p_src_caches)
@extern("vkMergeValidationCachesEXT");

fn VkResult get_validation_cache_data_ext(
  VkDevice device, 
  VkValidationCacheEXT validation_cache, 
  usz * p_data_size, 
  void * p_data)
@extern("vkGetValidationCacheDataEXT");

typedef VkDescriptorBindingFlagBitsEXT = inline CUInt;
const VkDescriptorBindingFlagBitsEXT DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT = 0x00000001;
const VkDescriptorBindingFlagBitsEXT DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT = 0x00000002;
const VkDescriptorBindingFlagBitsEXT DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT = 0x00000004;
const VkDescriptorBindingFlagBitsEXT DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT = 0x00000008;
const VkDescriptorBindingFlagBitsEXT DESCRIPTOR_BINDING_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF;

alias VkDescriptorBindingFlagsEXT = VkFlags;

struct VkDescriptorSetLayoutBindingFlagsCreateInfoEXT {
  VkStructureType s_type;
  void * p_next;
  uint binding_count;
  VkDescriptorBindingFlagsEXT * p_binding_flags;
}

struct VkPhysicalDeviceDescriptorIndexingFeaturesEXT {
  VkStructureType s_type;
  void * p_next;
  VkBool32 shader_input_attachment_array_dynamic_indexing;
  VkBool32 shader_uniform_texel_buffer_array_dynamic_indexing;
  VkBool32 shader_storage_texel_buffer_array_dynamic_indexing;
  VkBool32 shader_uniform_buffer_array_non_uniform_indexing;
  VkBool32 shader_sampled_image_array_non_uniform_indexing;
  VkBool32 shader_storage_buffer_array_non_uniform_indexing;
  VkBool32 shader_storage_image_array_non_uniform_indexing;
  VkBool32 shader_input_attachment_array_non_uniform_indexing;
  VkBool32 shader_uniform_texel_buffer_array_non_uniform_indexing;
  VkBool32 shader_storage_texel_buffer_array_non_uniform_indexing;
  VkBool32 descriptor_binding_uniform_buffer_update_after_bind;
  VkBool32 descriptor_binding_sampled_image_update_after_bind;
  VkBool32 descriptor_binding_storage_image_update_after_bind;
  VkBool32 descriptor_binding_storage_buffer_update_after_bind;
  VkBool32 descriptor_binding_uniform_texel_buffer_update_after_bind;
  VkBool32 descriptor_binding_storage_texel_buffer_update_after_bind;
  VkBool32 descriptor_binding_update_unused_while_pending;
  VkBool32 descriptor_binding_partially_bound;
  VkBool32 descriptor_binding_variable_descriptor_count;
  VkBool32 runtime_descriptor_array;
}

struct VkPhysicalDeviceDescriptorIndexingPropertiesEXT {
  VkStructureType s_type;
  void * p_next;
  uint max_update_after_bind_descriptors_in_all_pools;
  VkBool32 shader_uniform_buffer_array_non_uniform_indexing_native;
  VkBool32 shader_sampled_image_array_non_uniform_indexing_native;
  VkBool32 shader_storage_buffer_array_non_uniform_indexing_native;
  VkBool32 shader_storage_image_array_non_uniform_indexing_native;
  VkBool32 shader_input_attachment_array_non_uniform_indexing_native;
  VkBool32 robust_buffer_access_update_after_bind;
  VkBool32 quad_divergent_implicit_lod;
  uint max_per_stage_descriptor_update_after_bind_samplers;
  uint max_per_stage_descriptor_update_after_bind_uniform_buffers;
  uint max_per_stage_descriptor_update_after_bind_storage_buffers;
  uint max_per_stage_descriptor_update_after_bind_sampled_images;
  uint max_per_stage_descriptor_update_after_bind_storage_images;
  uint max_per_stage_descriptor_update_after_bind_input_attachments;
  uint max_per_stage_update_after_bind_resources;
  uint max_descriptor_set_update_after_bind_samplers;
  uint max_descriptor_set_update_after_bind_uniform_buffers;
  uint max_descriptor_set_update_after_bind_uniform_buffers_dynamic;
  uint max_descriptor_set_update_after_bind_storage_buffers;
  uint max_descriptor_set_update_after_bind_storage_buffers_dynamic;
  uint max_descriptor_set_update_after_bind_sampled_images;
  uint max_descriptor_set_update_after_bind_storage_images;
  uint max_descriptor_set_update_after_bind_input_attachments;
}

struct VkDescriptorSetVariableDescriptorCountAllocateInfoEXT {
  VkStructureType s_type;
  void * p_next;
  uint descriptor_set_count;
  uint * p_descriptor_counts;
}

struct VkDescriptorSetVariableDescriptorCountLayoutSupportEXT {
  VkStructureType s_type;
  void * p_next;
  uint max_variable_descriptor_count;
}

typedef VkShadingRatePaletteEntryNV = inline CUInt;
const VkShadingRatePaletteEntryNV SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV = 0;
const VkShadingRatePaletteEntryNV SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV = 1;
const VkShadingRatePaletteEntryNV SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV = 2;
const VkShadingRatePaletteEntryNV SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV = 3;
const VkShadingRatePaletteEntryNV SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV = 4;
const VkShadingRatePaletteEntryNV SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV = 5;
const VkShadingRatePaletteEntryNV SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV = 6;
const VkShadingRatePaletteEntryNV SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV = 7;
const VkShadingRatePaletteEntryNV SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV = 8;
const VkShadingRatePaletteEntryNV SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV = 9;
const VkShadingRatePaletteEntryNV SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV = 10;
const VkShadingRatePaletteEntryNV SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV = 11;
const VkShadingRatePaletteEntryNV SHADING_RATE_PALETTE_ENTRY_BEGIN_RANGE_NV = SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV;
const VkShadingRatePaletteEntryNV SHADING_RATE_PALETTE_ENTRY_END_RANGE_NV = SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV;
const VkShadingRatePaletteEntryNV SHADING_RATE_PALETTE_ENTRY_RANGE_SIZE_NV = (SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV-SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV+1);
const VkShadingRatePaletteEntryNV SHADING_RATE_PALETTE_ENTRY_MAX_ENUM_NV = 0x7FFFFFFF;

typedef VkCoarseSampleOrderTypeNV = inline CUInt;
const VkCoarseSampleOrderTypeNV COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV = 0;
const VkCoarseSampleOrderTypeNV COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV = 1;
const VkCoarseSampleOrderTypeNV COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV = 2;
const VkCoarseSampleOrderTypeNV COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV = 3;
const VkCoarseSampleOrderTypeNV COARSE_SAMPLE_ORDER_TYPE_BEGIN_RANGE_NV = COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV;
const VkCoarseSampleOrderTypeNV COARSE_SAMPLE_ORDER_TYPE_END_RANGE_NV = COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV;
const VkCoarseSampleOrderTypeNV COARSE_SAMPLE_ORDER_TYPE_RANGE_SIZE_NV = (COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV-COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV+1);
const VkCoarseSampleOrderTypeNV COARSE_SAMPLE_ORDER_TYPE_MAX_ENUM_NV = 0x7FFFFFFF;

struct VkShadingRatePaletteNV {
  uint shading_rate_palette_entry_count;
  VkShadingRatePaletteEntryNV * p_shading_rate_palette_entries;
}

struct VkPipelineViewportShadingRateImageStateCreateInfoNV {
  VkStructureType s_type;
  void * p_next;
  VkBool32 shading_rate_image_enable;
  uint viewport_count;
  VkShadingRatePaletteNV * p_shading_rate_palettes;
}

struct VkPhysicalDeviceShadingRateImageFeaturesNV {
  VkStructureType s_type;
  void * p_next;
  VkBool32 shading_rate_image;
  VkBool32 shading_rate_coarse_sample_order;
}

struct VkPhysicalDeviceShadingRateImagePropertiesNV {
  VkStructureType s_type;
  void * p_next;
  VkExtent2D shading_rate_texel_size;
  uint shading_rate_palette_size;
  uint shading_rate_max_coarse_samples;
}

struct VkCoarseSampleLocationNV {
  uint pixel_x;
  uint pixel_y;
  uint sample;
}

struct VkCoarseSampleOrderCustomNV {
  VkShadingRatePaletteEntryNV shading_rate;
  uint sample_count;
  uint sample_location_count;
  VkCoarseSampleLocationNV * p_sample_locations;
}

struct VkPipelineViewportCoarseSampleOrderStateCreateInfoNV {
  VkStructureType s_type;
  void * p_next;
  VkCoarseSampleOrderTypeNV sample_order_type;
  uint custom_sample_order_count;
  VkCoarseSampleOrderCustomNV * p_custom_sample_orders;
}

alias PFN_vkCmdBindShadingRateImageNV = fn void(
  VkCommandBuffer command_buffer, 
  VkImageView image_view, 
  VkImageLayout image_layout);

alias PFN_vkCmdSetViewportShadingRatePaletteNV = fn void(
  VkCommandBuffer command_buffer, 
  uint first_viewport, 
  uint viewport_count, 
  VkShadingRatePaletteNV * p_shading_rate_palettes);

alias PFN_vkCmdSetCoarseSampleOrderNV = fn void(
  VkCommandBuffer command_buffer, 
  VkCoarseSampleOrderTypeNV sample_order_type, 
  uint custom_sample_order_count, 
  VkCoarseSampleOrderCustomNV * p_custom_sample_orders);

fn void cmd_bind_shading_rate_image_nv(
  VkCommandBuffer command_buffer, 
  VkImageView image_view, 
  VkImageLayout image_layout)
@extern("vkCmdBindShadingRateImageNV");

fn void cmd_set_viewport_shading_rate_palette_nv(
  VkCommandBuffer command_buffer, 
  uint first_viewport, 
  uint viewport_count, 
  VkShadingRatePaletteNV * p_shading_rate_palettes)
@extern("vkCmdSetViewportShadingRatePaletteNV");

fn void cmd_set_coarse_sample_order_nv(
  VkCommandBuffer command_buffer, 
  VkCoarseSampleOrderTypeNV sample_order_type, 
  uint custom_sample_order_count, 
  VkCoarseSampleOrderCustomNV * p_custom_sample_orders)
@extern("vkCmdSetCoarseSampleOrderNV");

typedef VkAccelerationStructureNV_T = void;

alias VkAccelerationStructureNV = VkAccelerationStructureNV_T *;

typedef VkAccelerationStructureTypeNV = inline CUInt;
const VkAccelerationStructureTypeNV ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV = 0;
const VkAccelerationStructureTypeNV ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV = 1;
const VkAccelerationStructureTypeNV ACCELERATION_STRUCTURE_TYPE_BEGIN_RANGE_NV = ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV;
const VkAccelerationStructureTypeNV ACCELERATION_STRUCTURE_TYPE_END_RANGE_NV = ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV;
const VkAccelerationStructureTypeNV ACCELERATION_STRUCTURE_TYPE_RANGE_SIZE_NV = (ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV-ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV+1);
const VkAccelerationStructureTypeNV ACCELERATION_STRUCTURE_TYPE_MAX_ENUM_NV = 0x7FFFFFFF;

typedef VkRayTracingShaderGroupTypeNV = inline CUInt;
const VkRayTracingShaderGroupTypeNV RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV = 0;
const VkRayTracingShaderGroupTypeNV RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV = 1;
const VkRayTracingShaderGroupTypeNV RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV = 2;
const VkRayTracingShaderGroupTypeNV RAY_TRACING_SHADER_GROUP_TYPE_BEGIN_RANGE_NV = RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV;
const VkRayTracingShaderGroupTypeNV RAY_TRACING_SHADER_GROUP_TYPE_END_RANGE_NV = RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV;
const VkRayTracingShaderGroupTypeNV RAY_TRACING_SHADER_GROUP_TYPE_RANGE_SIZE_NV = (RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV-RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV+1);
const VkRayTracingShaderGroupTypeNV RAY_TRACING_SHADER_GROUP_TYPE_MAX_ENUM_NV = 0x7FFFFFFF;

typedef VkGeometryTypeNV = inline CUInt;
const VkGeometryTypeNV GEOMETRY_TYPE_TRIANGLES_NV = 0;
const VkGeometryTypeNV GEOMETRY_TYPE_AABBS_NV = 1;
const VkGeometryTypeNV GEOMETRY_TYPE_BEGIN_RANGE_NV = GEOMETRY_TYPE_TRIANGLES_NV;
const VkGeometryTypeNV GEOMETRY_TYPE_END_RANGE_NV = GEOMETRY_TYPE_AABBS_NV;
const VkGeometryTypeNV GEOMETRY_TYPE_RANGE_SIZE_NV = (GEOMETRY_TYPE_AABBS_NV-GEOMETRY_TYPE_TRIANGLES_NV+1);
const VkGeometryTypeNV GEOMETRY_TYPE_MAX_ENUM_NV = 0x7FFFFFFF;

typedef VkCopyAccelerationStructureModeNV = inline CUInt;
const VkCopyAccelerationStructureModeNV COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV = 0;
const VkCopyAccelerationStructureModeNV COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV = 1;
const VkCopyAccelerationStructureModeNV COPY_ACCELERATION_STRUCTURE_MODE_BEGIN_RANGE_NV = COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV;
const VkCopyAccelerationStructureModeNV COPY_ACCELERATION_STRUCTURE_MODE_END_RANGE_NV = COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV;
const VkCopyAccelerationStructureModeNV COPY_ACCELERATION_STRUCTURE_MODE_RANGE_SIZE_NV = (COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV-COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV+1);
const VkCopyAccelerationStructureModeNV COPY_ACCELERATION_STRUCTURE_MODE_MAX_ENUM_NV = 0x7FFFFFFF;

typedef VkAccelerationStructureMemoryRequirementsTypeNV = inline CUInt;
const VkAccelerationStructureMemoryRequirementsTypeNV ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV = 0;
const VkAccelerationStructureMemoryRequirementsTypeNV ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV = 1;
const VkAccelerationStructureMemoryRequirementsTypeNV ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV = 2;
const VkAccelerationStructureMemoryRequirementsTypeNV ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BEGIN_RANGE_NV = ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV;
const VkAccelerationStructureMemoryRequirementsTypeNV ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_END_RANGE_NV = ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV;
const VkAccelerationStructureMemoryRequirementsTypeNV ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_RANGE_SIZE_NV = (ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV-ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV+1);
const VkAccelerationStructureMemoryRequirementsTypeNV ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_MAX_ENUM_NV = 0x7FFFFFFF;

typedef VkGeometryFlagBitsNV = inline CUInt;
const VkGeometryFlagBitsNV GEOMETRY_OPAQUE_BIT_NV = 0x00000001;
const VkGeometryFlagBitsNV GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV = 0x00000002;
const VkGeometryFlagBitsNV GEOMETRY_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF;

alias VkGeometryFlagsNV = VkFlags;

typedef VkGeometryInstanceFlagBitsNV = inline CUInt;
const VkGeometryInstanceFlagBitsNV GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV = 0x00000001;
const VkGeometryInstanceFlagBitsNV GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV = 0x00000002;
const VkGeometryInstanceFlagBitsNV GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV = 0x00000004;
const VkGeometryInstanceFlagBitsNV GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV = 0x00000008;
const VkGeometryInstanceFlagBitsNV GEOMETRY_INSTANCE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF;

alias VkGeometryInstanceFlagsNV = VkFlags;

typedef VkBuildAccelerationStructureFlagBitsNV = inline CUInt;
const VkBuildAccelerationStructureFlagBitsNV BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV = 0x00000001;
const VkBuildAccelerationStructureFlagBitsNV BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV = 0x00000002;
const VkBuildAccelerationStructureFlagBitsNV BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV = 0x00000004;
const VkBuildAccelerationStructureFlagBitsNV BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV = 0x00000008;
const VkBuildAccelerationStructureFlagBitsNV BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV = 0x00000010;
const VkBuildAccelerationStructureFlagBitsNV BUILD_ACCELERATION_STRUCTURE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF;

alias VkBuildAccelerationStructureFlagsNV = VkFlags;

struct VkRayTracingShaderGroupCreateInfoNV {
  VkStructureType s_type;
  void * p_next;
  VkRayTracingShaderGroupTypeNV type;
  uint general_shader;
  uint closest_hit_shader;
  uint any_hit_shader;
  uint intersection_shader;
}

struct VkRayTracingPipelineCreateInfoNV {
  VkStructureType s_type;
  void * p_next;
  VkPipelineCreateFlags flags;
  uint stage_count;
  VkPipelineShaderStageCreateInfo * p_stages;
  uint group_count;
  VkRayTracingShaderGroupCreateInfoNV * p_groups;
  uint max_recursion_depth;
  VkPipelineLayout layout;
  VkPipeline base_pipeline_handle;
  int base_pipeline_index;
}

struct VkGeometryTrianglesNV {
  VkStructureType s_type;
  void * p_next;
  VkBuffer vertex_data;
  VkDeviceSize vertex_offset;
  uint vertex_count;
  VkDeviceSize vertex_stride;
  VkFormat vertex_format;
  VkBuffer index_data;
  VkDeviceSize index_offset;
  uint index_count;
  VkIndexType index_type;
  VkBuffer transform_data;
  VkDeviceSize transform_offset;
}

struct VkGeometryAABBNV {
  VkStructureType s_type;
  void * p_next;
  VkBuffer aabb_data;
  uint num_aabbs;
  uint stride;
  VkDeviceSize offset;
}

struct VkGeometryDataNV {
  VkGeometryTrianglesNV triangles;
  VkGeometryAABBNV aabbs;
}

struct VkGeometryNV {
  VkStructureType s_type;
  void * p_next;
  VkGeometryTypeNV geometry_type;
  VkGeometryDataNV geometry;
  VkGeometryFlagsNV flags;
}

struct VkAccelerationStructureInfoNV {
  VkStructureType s_type;
  void * p_next;
  VkAccelerationStructureTypeNV type;
  VkBuildAccelerationStructureFlagsNV flags;
  uint instance_count;
  uint geometry_count;
  VkGeometryNV * p_geometries;
}

struct VkAccelerationStructureCreateInfoNV {
  VkStructureType s_type;
  void * p_next;
  VkDeviceSize compacted_size;
  VkAccelerationStructureInfoNV info;
}

struct VkBindAccelerationStructureMemoryInfoNV {
  VkStructureType s_type;
  void * p_next;
  VkAccelerationStructureNV acceleration_structure;
  VkDeviceMemory memory;
  VkDeviceSize memory_offset;
  uint device_index_count;
  uint * p_device_indices;
}

struct VkWriteDescriptorSetAccelerationStructureNV {
  VkStructureType s_type;
  void * p_next;
  uint acceleration_structure_count;
  VkAccelerationStructureNV * p_acceleration_structures;
}

struct VkAccelerationStructureMemoryRequirementsInfoNV {
  VkStructureType s_type;
  void * p_next;
  VkAccelerationStructureMemoryRequirementsTypeNV type;
  VkAccelerationStructureNV acceleration_structure;
}

struct VkPhysicalDeviceRayTracingPropertiesNV {
  VkStructureType s_type;
  void * p_next;
  uint shader_group_handle_size;
  uint max_recursion_depth;
  uint max_shader_group_stride;
  uint shader_group_base_alignment;
  ulong max_geometry_count;
  ulong max_instance_count;
  ulong max_triangle_count;
  uint max_descriptor_set_acceleration_structures;
}

alias PFN_vkCreateAccelerationStructureNV = fn VkResult(
  VkDevice device, 
  VkAccelerationStructureCreateInfoNV * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkAccelerationStructureNV * p_acceleration_structure);

alias PFN_vkDestroyAccelerationStructureNV = fn void(
  VkDevice device, 
  VkAccelerationStructureNV acceleration_structure, 
  VkAllocationCallbacks * p_allocator);

alias PFN_vkGetAccelerationStructureMemoryRequirementsNV = fn void(
  VkDevice device, 
  VkAccelerationStructureMemoryRequirementsInfoNV * p_info, 
  VkMemoryRequirements2KHR * p_memory_requirements);

alias PFN_vkBindAccelerationStructureMemoryNV = fn VkResult(
  VkDevice device, 
  uint bind_info_count, 
  VkBindAccelerationStructureMemoryInfoNV * p_bind_infos);

alias PFN_vkCmdBuildAccelerationStructureNV = fn void(
  VkCommandBuffer command_buffer, 
  VkAccelerationStructureInfoNV * p_info, 
  VkBuffer instance_data, 
  VkDeviceSize instance_offset, 
  VkBool32 update, 
  VkAccelerationStructureNV dst, 
  VkAccelerationStructureNV src, 
  VkBuffer scratch, 
  VkDeviceSize scratch_offset);

alias PFN_vkCmdCopyAccelerationStructureNV = fn void(
  VkCommandBuffer command_buffer, 
  VkAccelerationStructureNV dst, 
  VkAccelerationStructureNV src, 
  VkCopyAccelerationStructureModeNV mode);

alias PFN_vkCmdTraceRaysNV = fn void(
  VkCommandBuffer command_buffer, 
  VkBuffer raygen_shader_binding_table_buffer, 
  VkDeviceSize raygen_shader_binding_offset, 
  VkBuffer miss_shader_binding_table_buffer, 
  VkDeviceSize miss_shader_binding_offset, 
  VkDeviceSize miss_shader_binding_stride, 
  VkBuffer hit_shader_binding_table_buffer, 
  VkDeviceSize hit_shader_binding_offset, 
  VkDeviceSize hit_shader_binding_stride, 
  VkBuffer callable_shader_binding_table_buffer, 
  VkDeviceSize callable_shader_binding_offset, 
  VkDeviceSize callable_shader_binding_stride, 
  uint width, 
  uint height, 
  uint depth);

alias PFN_vkCreateRayTracingPipelinesNV = fn VkResult(
  VkDevice device, 
  VkPipelineCache pipeline_cache, 
  uint create_info_count, 
  VkRayTracingPipelineCreateInfoNV * p_create_infos, 
  VkAllocationCallbacks * p_allocator, 
  VkPipeline * p_pipelines);

alias PFN_vkGetRayTracingShaderGroupHandlesNV = fn VkResult(
  VkDevice device, 
  VkPipeline pipeline, 
  uint first_group, 
  uint group_count, 
  usz data_size, 
  void * p_data);

alias PFN_vkGetAccelerationStructureHandleNV = fn VkResult(
  VkDevice device, 
  VkAccelerationStructureNV acceleration_structure, 
  usz data_size, 
  void * p_data);

alias PFN_vkCmdWriteAccelerationStructuresPropertiesNV = fn void(
  VkCommandBuffer command_buffer, 
  uint acceleration_structure_count, 
  VkAccelerationStructureNV * p_acceleration_structures, 
  VkQueryType query_type, 
  VkQueryPool query_pool, 
  uint first_query);

alias PFN_vkCompileDeferredNV = fn VkResult(
  VkDevice device, 
  VkPipeline pipeline, 
  uint shader);

fn VkResult create_acceleration_structure_nv(
  VkDevice device, 
  VkAccelerationStructureCreateInfoNV * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkAccelerationStructureNV * p_acceleration_structure)
@extern("vkCreateAccelerationStructureNV");

fn void destroy_acceleration_structure_nv(
  VkDevice device, 
  VkAccelerationStructureNV acceleration_structure, 
  VkAllocationCallbacks * p_allocator)
@extern("vkDestroyAccelerationStructureNV");

fn void get_acceleration_structure_memory_requirements_nv(
  VkDevice device, 
  VkAccelerationStructureMemoryRequirementsInfoNV * p_info, 
  VkMemoryRequirements2KHR * p_memory_requirements)
@extern("vkGetAccelerationStructureMemoryRequirementsNV");

fn VkResult bind_acceleration_structure_memory_nv(
  VkDevice device, 
  uint bind_info_count, 
  VkBindAccelerationStructureMemoryInfoNV * p_bind_infos)
@extern("vkBindAccelerationStructureMemoryNV");

fn void cmd_build_acceleration_structure_nv(
  VkCommandBuffer command_buffer, 
  VkAccelerationStructureInfoNV * p_info, 
  VkBuffer instance_data, 
  VkDeviceSize instance_offset, 
  VkBool32 update, 
  VkAccelerationStructureNV dst, 
  VkAccelerationStructureNV src, 
  VkBuffer scratch, 
  VkDeviceSize scratch_offset)
@extern("vkCmdBuildAccelerationStructureNV");

fn void cmd_copy_acceleration_structure_nv(
  VkCommandBuffer command_buffer, 
  VkAccelerationStructureNV dst, 
  VkAccelerationStructureNV src, 
  VkCopyAccelerationStructureModeNV mode)
@extern("vkCmdCopyAccelerationStructureNV");

fn void cmd_trace_rays_nv(
  VkCommandBuffer command_buffer, 
  VkBuffer raygen_shader_binding_table_buffer, 
  VkDeviceSize raygen_shader_binding_offset, 
  VkBuffer miss_shader_binding_table_buffer, 
  VkDeviceSize miss_shader_binding_offset, 
  VkDeviceSize miss_shader_binding_stride, 
  VkBuffer hit_shader_binding_table_buffer, 
  VkDeviceSize hit_shader_binding_offset, 
  VkDeviceSize hit_shader_binding_stride, 
  VkBuffer callable_shader_binding_table_buffer, 
  VkDeviceSize callable_shader_binding_offset, 
  VkDeviceSize callable_shader_binding_stride, 
  uint width, 
  uint height, 
  uint depth)
@extern("vkCmdTraceRaysNV");

fn VkResult create_ray_tracing_pipelines_nv(
  VkDevice device, 
  VkPipelineCache pipeline_cache, 
  uint create_info_count, 
  VkRayTracingPipelineCreateInfoNV * p_create_infos, 
  VkAllocationCallbacks * p_allocator, 
  VkPipeline * p_pipelines)
@extern("vkCreateRayTracingPipelinesNV");

fn VkResult get_ray_tracing_shader_group_handles_nv(
  VkDevice device, 
  VkPipeline pipeline, 
  uint first_group, 
  uint group_count, 
  usz data_size, 
  void * p_data)
@extern("vkGetRayTracingShaderGroupHandlesNV");

fn VkResult get_acceleration_structure_handle_nv(
  VkDevice device, 
  VkAccelerationStructureNV acceleration_structure, 
  usz data_size, 
  void * p_data)
@extern("vkGetAccelerationStructureHandleNV");

fn void cmd_write_acceleration_structures_properties_nv(
  VkCommandBuffer command_buffer, 
  uint acceleration_structure_count, 
  VkAccelerationStructureNV * p_acceleration_structures, 
  VkQueryType query_type, 
  VkQueryPool query_pool, 
  uint first_query)
@extern("vkCmdWriteAccelerationStructuresPropertiesNV");

fn VkResult compile_deferred_nv(
  VkDevice device, 
  VkPipeline pipeline, 
  uint shader)
@extern("vkCompileDeferredNV");

struct VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV {
  VkStructureType s_type;
  void * p_next;
  VkBool32 representative_fragment_test;
}

struct VkPipelineRepresentativeFragmentTestStateCreateInfoNV {
  VkStructureType s_type;
  void * p_next;
  VkBool32 representative_fragment_test_enable;
}

struct VkPhysicalDeviceImageViewImageFormatInfoEXT {
  VkStructureType s_type;
  void * p_next;
  VkImageViewType image_view_type;
}

struct VkFilterCubicImageViewImageFormatPropertiesEXT {
  VkStructureType s_type;
  void * p_next;
  VkBool32 filter_cubic;
  VkBool32 filter_cubic_minmax;
}

typedef VkQueueGlobalPriorityEXT = inline CUInt;
const VkQueueGlobalPriorityEXT QUEUE_GLOBAL_PRIORITY_LOW_EXT = 128;
const VkQueueGlobalPriorityEXT QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT = 256;
const VkQueueGlobalPriorityEXT QUEUE_GLOBAL_PRIORITY_HIGH_EXT = 512;
const VkQueueGlobalPriorityEXT QUEUE_GLOBAL_PRIORITY_REALTIME_EXT = 1024;
const VkQueueGlobalPriorityEXT QUEUE_GLOBAL_PRIORITY_BEGIN_RANGE_EXT = QUEUE_GLOBAL_PRIORITY_LOW_EXT;
const VkQueueGlobalPriorityEXT QUEUE_GLOBAL_PRIORITY_END_RANGE_EXT = QUEUE_GLOBAL_PRIORITY_REALTIME_EXT;
const VkQueueGlobalPriorityEXT QUEUE_GLOBAL_PRIORITY_RANGE_SIZE_EXT = (QUEUE_GLOBAL_PRIORITY_REALTIME_EXT-QUEUE_GLOBAL_PRIORITY_LOW_EXT+1);
const VkQueueGlobalPriorityEXT QUEUE_GLOBAL_PRIORITY_MAX_ENUM_EXT = 0x7FFFFFFF;

struct VkDeviceQueueGlobalPriorityCreateInfoEXT {
  VkStructureType s_type;
  void * p_next;
  VkQueueGlobalPriorityEXT global_priority;
}

struct VkImportMemoryHostPointerInfoEXT {
  VkStructureType s_type;
  void * p_next;
  VkExternalMemoryHandleTypeFlagBits handle_type;
  void * p_host_pointer;
}

struct VkMemoryHostPointerPropertiesEXT {
  VkStructureType s_type;
  void * p_next;
  uint memory_type_bits;
}

struct VkPhysicalDeviceExternalMemoryHostPropertiesEXT {
  VkStructureType s_type;
  void * p_next;
  VkDeviceSize min_imported_host_pointer_alignment;
}

alias PFN_vkGetMemoryHostPointerPropertiesEXT = fn VkResult(
  VkDevice device, 
  VkExternalMemoryHandleTypeFlagBits handle_type, 
  void * p_host_pointer, 
  VkMemoryHostPointerPropertiesEXT * p_memory_host_pointer_properties);

fn VkResult get_memory_host_pointer_properties_ext(
  VkDevice device, 
  VkExternalMemoryHandleTypeFlagBits handle_type, 
  void * p_host_pointer, 
  VkMemoryHostPointerPropertiesEXT * p_memory_host_pointer_properties)
@extern("vkGetMemoryHostPointerPropertiesEXT");

alias PFN_vkCmdWriteBufferMarkerAMD = fn void(
  VkCommandBuffer command_buffer, 
  VkPipelineStageFlagBits pipeline_stage, 
  VkBuffer dst_buffer, 
  VkDeviceSize dst_offset, 
  uint marker);

fn void cmd_write_buffer_marker_amd(
  VkCommandBuffer command_buffer, 
  VkPipelineStageFlagBits pipeline_stage, 
  VkBuffer dst_buffer, 
  VkDeviceSize dst_offset, 
  uint marker)
@extern("vkCmdWriteBufferMarkerAMD");

typedef VkPipelineCompilerControlFlagBitsAMD = inline CUInt;
const VkPipelineCompilerControlFlagBitsAMD PIPELINE_COMPILER_CONTROL_FLAG_BITS_MAX_ENUM_AMD = 0x7FFFFFFF;

alias VkPipelineCompilerControlFlagsAMD = VkFlags;

struct VkPipelineCompilerControlCreateInfoAMD {
  VkStructureType s_type;
  void * p_next;
  VkPipelineCompilerControlFlagsAMD compiler_control_flags;
}

typedef VkTimeDomainEXT = inline CUInt;
const VkTimeDomainEXT TIME_DOMAIN_DEVICE_EXT = 0;
const VkTimeDomainEXT TIME_DOMAIN_CLOCK_MONOTONIC_EXT = 1;
const VkTimeDomainEXT TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT = 2;
const VkTimeDomainEXT TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT = 3;
const VkTimeDomainEXT TIME_DOMAIN_BEGIN_RANGE_EXT = TIME_DOMAIN_DEVICE_EXT;
const VkTimeDomainEXT TIME_DOMAIN_END_RANGE_EXT = TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT;
const VkTimeDomainEXT TIME_DOMAIN_RANGE_SIZE_EXT = (TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT-TIME_DOMAIN_DEVICE_EXT+1);
const VkTimeDomainEXT TIME_DOMAIN_MAX_ENUM_EXT = 0x7FFFFFFF;

struct VkCalibratedTimestampInfoEXT {
  VkStructureType s_type;
  void * p_next;
  VkTimeDomainEXT time_domain;
}

alias PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT = fn VkResult(
  VkPhysicalDevice physical_device, 
  uint * p_time_domain_count, 
  VkTimeDomainEXT * p_time_domains);

alias PFN_vkGetCalibratedTimestampsEXT = fn VkResult(
  VkDevice device, 
  uint timestamp_count, 
  VkCalibratedTimestampInfoEXT * p_timestamp_infos, 
  ulong * p_timestamps, 
  ulong * p_max_deviation);

fn VkResult get_physical_device_calibrateable_time_domains_ext(
  VkPhysicalDevice physical_device, 
  uint * p_time_domain_count, 
  VkTimeDomainEXT * p_time_domains)
@extern("vkGetPhysicalDeviceCalibrateableTimeDomainsEXT");

fn VkResult get_calibrated_timestamps_ext(
  VkDevice device, 
  uint timestamp_count, 
  VkCalibratedTimestampInfoEXT * p_timestamp_infos, 
  ulong * p_timestamps, 
  ulong * p_max_deviation)
@extern("vkGetCalibratedTimestampsEXT");

struct VkPhysicalDeviceShaderCorePropertiesAMD {
  VkStructureType s_type;
  void * p_next;
  uint shader_engine_count;
  uint shader_arrays_per_engine_count;
  uint compute_units_per_shader_array;
  uint simd_per_compute_unit;
  uint wavefronts_per_simd;
  uint wavefront_size;
  uint sgprs_per_simd;
  uint min_sgpr_allocation;
  uint max_sgpr_allocation;
  uint sgpr_allocation_granularity;
  uint vgprs_per_simd;
  uint min_vgpr_allocation;
  uint max_vgpr_allocation;
  uint vgpr_allocation_granularity;
}

typedef VkMemoryOverallocationBehaviorAMD = inline CUInt;
const VkMemoryOverallocationBehaviorAMD MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD = 0;
const VkMemoryOverallocationBehaviorAMD MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD = 1;
const VkMemoryOverallocationBehaviorAMD MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD = 2;
const VkMemoryOverallocationBehaviorAMD MEMORY_OVERALLOCATION_BEHAVIOR_BEGIN_RANGE_AMD = MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD;
const VkMemoryOverallocationBehaviorAMD MEMORY_OVERALLOCATION_BEHAVIOR_END_RANGE_AMD = MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD;
const VkMemoryOverallocationBehaviorAMD MEMORY_OVERALLOCATION_BEHAVIOR_RANGE_SIZE_AMD = (MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD-MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD+1);
const VkMemoryOverallocationBehaviorAMD MEMORY_OVERALLOCATION_BEHAVIOR_MAX_ENUM_AMD = 0x7FFFFFFF;

struct VkDeviceMemoryOverallocationCreateInfoAMD {
  VkStructureType s_type;
  void * p_next;
  VkMemoryOverallocationBehaviorAMD overallocation_behavior;
}

struct VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT {
  VkStructureType s_type;
  void * p_next;
  uint max_vertex_attrib_divisor;
}

struct VkVertexInputBindingDivisorDescriptionEXT {
  uint binding;
  uint divisor;
}

struct VkPipelineVertexInputDivisorStateCreateInfoEXT {
  VkStructureType s_type;
  void * p_next;
  uint vertex_binding_divisor_count;
  VkVertexInputBindingDivisorDescriptionEXT * p_vertex_binding_divisors;
}

struct VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT {
  VkStructureType s_type;
  void * p_next;
  VkBool32 vertex_attribute_instance_rate_divisor;
  VkBool32 vertex_attribute_instance_rate_zero_divisor;
}

typedef VkPipelineCreationFeedbackFlagBitsEXT = inline CUInt;
const VkPipelineCreationFeedbackFlagBitsEXT PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT = 0x00000001;
const VkPipelineCreationFeedbackFlagBitsEXT PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT = 0x00000002;
const VkPipelineCreationFeedbackFlagBitsEXT PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT = 0x00000004;
const VkPipelineCreationFeedbackFlagBitsEXT PIPELINE_CREATION_FEEDBACK_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF;

alias VkPipelineCreationFeedbackFlagsEXT = VkFlags;

struct VkPipelineCreationFeedbackEXT {
  VkPipelineCreationFeedbackFlagsEXT flags;
  ulong duration;
}

struct VkPipelineCreationFeedbackCreateInfoEXT {
  VkStructureType s_type;
  void * p_next;
  VkPipelineCreationFeedbackEXT * p_pipeline_creation_feedback;
  uint pipeline_stage_creation_feedback_count;
  VkPipelineCreationFeedbackEXT * p_pipeline_stage_creation_feedbacks;
}

struct VkPhysicalDeviceComputeShaderDerivativesFeaturesNV {
  VkStructureType s_type;
  void * p_next;
  VkBool32 compute_derivative_group_quads;
  VkBool32 compute_derivative_group_linear;
}

struct VkPhysicalDeviceMeshShaderFeaturesNV {
  VkStructureType s_type;
  void * p_next;
  VkBool32 task_shader;
  VkBool32 mesh_shader;
}

struct VkPhysicalDeviceMeshShaderPropertiesNV {
  VkStructureType s_type;
  void * p_next;
  uint max_draw_mesh_tasks_count;
  uint max_task_work_group_invocations;
  uint[3] max_task_work_group_size;
  uint max_task_total_memory_size;
  uint max_task_output_count;
  uint max_mesh_work_group_invocations;
  uint[3] max_mesh_work_group_size;
  uint max_mesh_total_memory_size;
  uint max_mesh_output_vertices;
  uint max_mesh_output_primitives;
  uint max_mesh_multiview_view_count;
  uint mesh_output_per_vertex_granularity;
  uint mesh_output_per_primitive_granularity;
}

struct VkDrawMeshTasksIndirectCommandNV {
  uint task_count;
  uint first_task;
}

alias PFN_vkCmdDrawMeshTasksNV = fn void(
  VkCommandBuffer command_buffer, 
  uint task_count, 
  uint first_task);

alias PFN_vkCmdDrawMeshTasksIndirectNV = fn void(
  VkCommandBuffer command_buffer, 
  VkBuffer buffer, 
  VkDeviceSize offset, 
  uint draw_count, 
  uint stride);

alias PFN_vkCmdDrawMeshTasksIndirectCountNV = fn void(
  VkCommandBuffer command_buffer, 
  VkBuffer buffer, 
  VkDeviceSize offset, 
  VkBuffer count_buffer, 
  VkDeviceSize count_buffer_offset, 
  uint max_draw_count, 
  uint stride);

fn void cmd_draw_mesh_tasks_nv(
  VkCommandBuffer command_buffer, 
  uint task_count, 
  uint first_task)
@extern("vkCmdDrawMeshTasksNV");

fn void cmd_draw_mesh_tasks_indirect_nv(
  VkCommandBuffer command_buffer, 
  VkBuffer buffer, 
  VkDeviceSize offset, 
  uint draw_count, 
  uint stride)
@extern("vkCmdDrawMeshTasksIndirectNV");

fn void cmd_draw_mesh_tasks_indirect_count_nv(
  VkCommandBuffer command_buffer, 
  VkBuffer buffer, 
  VkDeviceSize offset, 
  VkBuffer count_buffer, 
  VkDeviceSize count_buffer_offset, 
  uint max_draw_count, 
  uint stride)
@extern("vkCmdDrawMeshTasksIndirectCountNV");

struct VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV {
  VkStructureType s_type;
  void * p_next;
  VkBool32 fragment_shader_barycentric;
}

struct VkPhysicalDeviceShaderImageFootprintFeaturesNV {
  VkStructureType s_type;
  void * p_next;
  VkBool32 image_footprint;
}

struct VkPipelineViewportExclusiveScissorStateCreateInfoNV {
  VkStructureType s_type;
  void * p_next;
  uint exclusive_scissor_count;
  VkRect2D * p_exclusive_scissors;
}

struct VkPhysicalDeviceExclusiveScissorFeaturesNV {
  VkStructureType s_type;
  void * p_next;
  VkBool32 exclusive_scissor;
}

alias PFN_vkCmdSetExclusiveScissorNV = fn void(
  VkCommandBuffer command_buffer, 
  uint first_exclusive_scissor, 
  uint exclusive_scissor_count, 
  VkRect2D * p_exclusive_scissors);

fn void cmd_set_exclusive_scissor_nv(
  VkCommandBuffer command_buffer, 
  uint first_exclusive_scissor, 
  uint exclusive_scissor_count, 
  VkRect2D * p_exclusive_scissors)
@extern("vkCmdSetExclusiveScissorNV");

struct VkQueueFamilyCheckpointPropertiesNV {
  VkStructureType s_type;
  void * p_next;
  VkPipelineStageFlags checkpoint_execution_stage_mask;
}

struct VkCheckpointDataNV {
  VkStructureType s_type;
  void * p_next;
  VkPipelineStageFlagBits stage;
  void * p_checkpoint_marker;
}

alias PFN_vkCmdSetCheckpointNV = fn void(
  VkCommandBuffer command_buffer, 
  void * p_checkpoint_marker);

alias PFN_vkGetQueueCheckpointDataNV = fn void(
  VkQueue queue, 
  uint * p_checkpoint_data_count, 
  VkCheckpointDataNV * p_checkpoint_data);

fn void cmd_set_checkpoint_nv(
  VkCommandBuffer command_buffer, 
  void * p_checkpoint_marker)
@extern("vkCmdSetCheckpointNV");

fn void get_queue_checkpoint_data_nv(
  VkQueue queue, 
  uint * p_checkpoint_data_count, 
  VkCheckpointDataNV * p_checkpoint_data)
@extern("vkGetQueueCheckpointDataNV");

struct VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL {
  VkStructureType s_type;
  void * p_next;
  VkBool32 shader_integer_functions_2;
}

typedef VkPerformanceConfigurationINTEL_T = void;

alias VkPerformanceConfigurationINTEL = VkPerformanceConfigurationINTEL_T *;

typedef VkPerformanceConfigurationTypeINTEL = inline CUInt;
const VkPerformanceConfigurationTypeINTEL PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL = 0;
const VkPerformanceConfigurationTypeINTEL PERFORMANCE_CONFIGURATION_TYPE_BEGIN_RANGE_INTEL = PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL;
const VkPerformanceConfigurationTypeINTEL PERFORMANCE_CONFIGURATION_TYPE_END_RANGE_INTEL = PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL;
const VkPerformanceConfigurationTypeINTEL PERFORMANCE_CONFIGURATION_TYPE_RANGE_SIZE_INTEL = (PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL-PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL+1);
const VkPerformanceConfigurationTypeINTEL PERFORMANCE_CONFIGURATION_TYPE_MAX_ENUM_INTEL = 0x7FFFFFFF;

typedef VkQueryPoolSamplingModeINTEL = inline CUInt;
const VkQueryPoolSamplingModeINTEL QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL = 0;
const VkQueryPoolSamplingModeINTEL QUERY_POOL_SAMPLING_MODE_BEGIN_RANGE_INTEL = QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL;
const VkQueryPoolSamplingModeINTEL QUERY_POOL_SAMPLING_MODE_END_RANGE_INTEL = QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL;
const VkQueryPoolSamplingModeINTEL QUERY_POOL_SAMPLING_MODE_RANGE_SIZE_INTEL = (QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL-QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL+1);
const VkQueryPoolSamplingModeINTEL QUERY_POOL_SAMPLING_MODE_MAX_ENUM_INTEL = 0x7FFFFFFF;

typedef VkPerformanceOverrideTypeINTEL = inline CUInt;
const VkPerformanceOverrideTypeINTEL PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL = 0;
const VkPerformanceOverrideTypeINTEL PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL = 1;
const VkPerformanceOverrideTypeINTEL PERFORMANCE_OVERRIDE_TYPE_BEGIN_RANGE_INTEL = PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL;
const VkPerformanceOverrideTypeINTEL PERFORMANCE_OVERRIDE_TYPE_END_RANGE_INTEL = PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL;
const VkPerformanceOverrideTypeINTEL PERFORMANCE_OVERRIDE_TYPE_RANGE_SIZE_INTEL = (PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL-PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL+1);
const VkPerformanceOverrideTypeINTEL PERFORMANCE_OVERRIDE_TYPE_MAX_ENUM_INTEL = 0x7FFFFFFF;

typedef VkPerformanceParameterTypeINTEL = inline CUInt;
const VkPerformanceParameterTypeINTEL PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL = 0;
const VkPerformanceParameterTypeINTEL PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL = 1;
const VkPerformanceParameterTypeINTEL PERFORMANCE_PARAMETER_TYPE_BEGIN_RANGE_INTEL = PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL;
const VkPerformanceParameterTypeINTEL PERFORMANCE_PARAMETER_TYPE_END_RANGE_INTEL = PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL;
const VkPerformanceParameterTypeINTEL PERFORMANCE_PARAMETER_TYPE_RANGE_SIZE_INTEL = (PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL-PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL+1);
const VkPerformanceParameterTypeINTEL PERFORMANCE_PARAMETER_TYPE_MAX_ENUM_INTEL = 0x7FFFFFFF;

typedef VkPerformanceValueTypeINTEL = inline CUInt;
const VkPerformanceValueTypeINTEL PERFORMANCE_VALUE_TYPE_UINT32_INTEL = 0;
const VkPerformanceValueTypeINTEL PERFORMANCE_VALUE_TYPE_UINT64_INTEL = 1;
const VkPerformanceValueTypeINTEL PERFORMANCE_VALUE_TYPE_FLOAT_INTEL = 2;
const VkPerformanceValueTypeINTEL PERFORMANCE_VALUE_TYPE_BOOL_INTEL = 3;
const VkPerformanceValueTypeINTEL PERFORMANCE_VALUE_TYPE_STRING_INTEL = 4;
const VkPerformanceValueTypeINTEL PERFORMANCE_VALUE_TYPE_BEGIN_RANGE_INTEL = PERFORMANCE_VALUE_TYPE_UINT32_INTEL;
const VkPerformanceValueTypeINTEL PERFORMANCE_VALUE_TYPE_END_RANGE_INTEL = PERFORMANCE_VALUE_TYPE_STRING_INTEL;
const VkPerformanceValueTypeINTEL PERFORMANCE_VALUE_TYPE_RANGE_SIZE_INTEL = (PERFORMANCE_VALUE_TYPE_STRING_INTEL-PERFORMANCE_VALUE_TYPE_UINT32_INTEL+1);
const VkPerformanceValueTypeINTEL PERFORMANCE_VALUE_TYPE_MAX_ENUM_INTEL = 0x7FFFFFFF;

union VkPerformanceValueDataINTEL {
  uint value_32;
  ulong value_64;
  float value_float;
  VkBool32 value_bool;
  CChar * value_string;
}

struct VkPerformanceValueINTEL {
  VkPerformanceValueTypeINTEL type;
  VkPerformanceValueDataINTEL data;
}

struct VkInitializePerformanceApiInfoINTEL {
  VkStructureType s_type;
  void * p_next;
  void * p_user_data;
}

struct VkQueryPoolCreateInfoINTEL {
  VkStructureType s_type;
  void * p_next;
  VkQueryPoolSamplingModeINTEL performance_counters_sampling;
}

struct VkPerformanceMarkerInfoINTEL {
  VkStructureType s_type;
  void * p_next;
  ulong marker;
}

struct VkPerformanceStreamMarkerInfoINTEL {
  VkStructureType s_type;
  void * p_next;
  uint marker;
}

struct VkPerformanceOverrideInfoINTEL {
  VkStructureType s_type;
  void * p_next;
  VkPerformanceOverrideTypeINTEL type;
  VkBool32 enable;
  ulong parameter;
}

struct VkPerformanceConfigurationAcquireInfoINTEL {
  VkStructureType s_type;
  void * p_next;
  VkPerformanceConfigurationTypeINTEL type;
}

alias PFN_vkInitializePerformanceApiINTEL = fn VkResult(
  VkDevice device, 
  VkInitializePerformanceApiInfoINTEL * p_initialize_info);

alias PFN_vkUninitializePerformanceApiINTEL = fn void(  VkDevice device);

alias PFN_vkCmdSetPerformanceMarkerINTEL = fn VkResult(
  VkCommandBuffer command_buffer, 
  VkPerformanceMarkerInfoINTEL * p_marker_info);

alias PFN_vkCmdSetPerformanceStreamMarkerINTEL = fn VkResult(
  VkCommandBuffer command_buffer, 
  VkPerformanceStreamMarkerInfoINTEL * p_marker_info);

alias PFN_vkCmdSetPerformanceOverrideINTEL = fn VkResult(
  VkCommandBuffer command_buffer, 
  VkPerformanceOverrideInfoINTEL * p_override_info);

alias PFN_vkAcquirePerformanceConfigurationINTEL = fn VkResult(
  VkDevice device, 
  VkPerformanceConfigurationAcquireInfoINTEL * p_acquire_info, 
  VkPerformanceConfigurationINTEL * p_configuration);

alias PFN_vkReleasePerformanceConfigurationINTEL = fn VkResult(
  VkDevice device, 
  VkPerformanceConfigurationINTEL configuration);

alias PFN_vkQueueSetPerformanceConfigurationINTEL = fn VkResult(
  VkQueue queue, 
  VkPerformanceConfigurationINTEL configuration);

alias PFN_vkGetPerformanceParameterINTEL = fn VkResult(
  VkDevice device, 
  VkPerformanceParameterTypeINTEL parameter, 
  VkPerformanceValueINTEL * p_value);

fn VkResult initialize_performance_api_intel(
  VkDevice device, 
  VkInitializePerformanceApiInfoINTEL * p_initialize_info)
@extern("vkInitializePerformanceApiINTEL");

fn void uninitialize_performance_api_intel(
  VkDevice device)
@extern("vkUninitializePerformanceApiINTEL");

fn VkResult cmd_set_performance_marker_intel(
  VkCommandBuffer command_buffer, 
  VkPerformanceMarkerInfoINTEL * p_marker_info)
@extern("vkCmdSetPerformanceMarkerINTEL");

fn VkResult cmd_set_performance_stream_marker_intel(
  VkCommandBuffer command_buffer, 
  VkPerformanceStreamMarkerInfoINTEL * p_marker_info)
@extern("vkCmdSetPerformanceStreamMarkerINTEL");

fn VkResult cmd_set_performance_override_intel(
  VkCommandBuffer command_buffer, 
  VkPerformanceOverrideInfoINTEL * p_override_info)
@extern("vkCmdSetPerformanceOverrideINTEL");

fn VkResult acquire_performance_configuration_intel(
  VkDevice device, 
  VkPerformanceConfigurationAcquireInfoINTEL * p_acquire_info, 
  VkPerformanceConfigurationINTEL * p_configuration)
@extern("vkAcquirePerformanceConfigurationINTEL");

fn VkResult release_performance_configuration_intel(
  VkDevice device, 
  VkPerformanceConfigurationINTEL configuration)
@extern("vkReleasePerformanceConfigurationINTEL");

fn VkResult queue_set_performance_configuration_intel(
  VkQueue queue, 
  VkPerformanceConfigurationINTEL configuration)
@extern("vkQueueSetPerformanceConfigurationINTEL");

fn VkResult get_performance_parameter_intel(
  VkDevice device, 
  VkPerformanceParameterTypeINTEL parameter, 
  VkPerformanceValueINTEL * p_value)
@extern("vkGetPerformanceParameterINTEL");

struct VkPhysicalDevicePCIBusInfoPropertiesEXT {
  VkStructureType s_type;
  void * p_next;
  uint pci_domain;
  uint pci_bus;
  uint pci_device;
  uint pci_function;
}

struct VkDisplayNativeHdrSurfaceCapabilitiesAMD {
  VkStructureType s_type;
  void * p_next;
  VkBool32 local_dimming_support;
}

struct VkSwapchainDisplayNativeHdrCreateInfoAMD {
  VkStructureType s_type;
  void * p_next;
  VkBool32 local_dimming_enable;
}

alias PFN_vkSetLocalDimmingAMD = fn void(
  VkDevice device, 
  VkSwapchainKHR swap_chain, 
  VkBool32 local_dimming_enable);

fn void set_local_dimming_amd(
  VkDevice device, 
  VkSwapchainKHR swap_chain, 
  VkBool32 local_dimming_enable)
@extern("vkSetLocalDimmingAMD");

struct VkPhysicalDeviceFragmentDensityMapFeaturesEXT {
  VkStructureType s_type;
  void * p_next;
  VkBool32 fragment_density_map;
  VkBool32 fragment_density_map_dynamic;
  VkBool32 fragment_density_map_non_subsampled_images;
}

struct VkPhysicalDeviceFragmentDensityMapPropertiesEXT {
  VkStructureType s_type;
  void * p_next;
  VkExtent2D min_fragment_density_texel_size;
  VkExtent2D max_fragment_density_texel_size;
  VkBool32 fragment_density_invocations;
}

struct VkRenderPassFragmentDensityMapCreateInfoEXT {
  VkStructureType s_type;
  void * p_next;
  VkAttachmentReference fragment_density_map_attachment;
}

struct VkPhysicalDeviceScalarBlockLayoutFeaturesEXT {
  VkStructureType s_type;
  void * p_next;
  VkBool32 scalar_block_layout;
}

struct VkPhysicalDeviceSubgroupSizeControlFeaturesEXT {
  VkStructureType s_type;
  void * p_next;
  VkBool32 subgroup_size_control;
  VkBool32 compute_full_subgroups;
}

struct VkPhysicalDeviceSubgroupSizeControlPropertiesEXT {
  VkStructureType s_type;
  void * p_next;
  uint min_subgroup_size;
  uint max_subgroup_size;
  uint max_compute_workgroup_subgroups;
  VkShaderStageFlags required_subgroup_size_stages;
}

struct VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT {
  VkStructureType s_type;
  void * p_next;
  uint required_subgroup_size;
}

typedef VkShaderCorePropertiesFlagBitsAMD = inline CUInt;
const VkShaderCorePropertiesFlagBitsAMD SHADER_CORE_PROPERTIES_FLAG_BITS_MAX_ENUM_AMD = 0x7FFFFFFF;

alias VkShaderCorePropertiesFlagsAMD = VkFlags;

struct VkPhysicalDeviceShaderCoreProperties2AMD {
  VkStructureType s_type;
  void * p_next;
  VkShaderCorePropertiesFlagsAMD shader_core_features;
  uint active_compute_unit_count;
}

struct VkPhysicalDeviceCoherentMemoryFeaturesAMD {
  VkStructureType s_type;
  void * p_next;
  VkBool32 device_coherent_memory;
}

struct VkPhysicalDeviceMemoryBudgetPropertiesEXT {
  VkStructureType s_type;
  void * p_next;
  VkDeviceSize[16] heap_budget;
  VkDeviceSize[16] heap_usage;
}

struct VkPhysicalDeviceMemoryPriorityFeaturesEXT {
  VkStructureType s_type;
  void * p_next;
  VkBool32 memory_priority;
}

struct VkMemoryPriorityAllocateInfoEXT {
  VkStructureType s_type;
  void * p_next;
  float priority;
}

struct VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV {
  VkStructureType s_type;
  void * p_next;
  VkBool32 dedicated_allocation_image_aliasing;
}

struct VkPhysicalDeviceBufferDeviceAddressFeaturesEXT {
  VkStructureType s_type;
  void * p_next;
  VkBool32 buffer_device_address;
  VkBool32 buffer_device_address_capture_replay;
  VkBool32 buffer_device_address_multi_device;
}

alias VkPhysicalDeviceBufferAddressFeaturesEXT = VkPhysicalDeviceBufferDeviceAddressFeaturesEXT;

alias VkBufferDeviceAddressInfoEXT = VkBufferDeviceAddressInfoKHR;

struct VkBufferDeviceAddressCreateInfoEXT {
  VkStructureType s_type;
  void * p_next;
  VkDeviceAddress device_address;
}

alias PFN_vkGetBufferDeviceAddressEXT = fn VkDeviceAddress(
  VkDevice device, 
  VkBufferDeviceAddressInfoKHR * p_info);

fn VkDeviceAddress get_buffer_device_address_ext(
  VkDevice device, 
  VkBufferDeviceAddressInfoKHR * p_info)
@extern("vkGetBufferDeviceAddressEXT");

typedef VkToolPurposeFlagBitsEXT = inline CUInt;
const VkToolPurposeFlagBitsEXT TOOL_PURPOSE_VALIDATION_BIT_EXT = 0x00000001;
const VkToolPurposeFlagBitsEXT TOOL_PURPOSE_PROFILING_BIT_EXT = 0x00000002;
const VkToolPurposeFlagBitsEXT TOOL_PURPOSE_TRACING_BIT_EXT = 0x00000004;
const VkToolPurposeFlagBitsEXT TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT = 0x00000008;
const VkToolPurposeFlagBitsEXT TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT = 0x00000010;
const VkToolPurposeFlagBitsEXT TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT = 0x00000020;
const VkToolPurposeFlagBitsEXT TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT = 0x00000040;
const VkToolPurposeFlagBitsEXT TOOL_PURPOSE_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF;

alias VkToolPurposeFlagsEXT = VkFlags;

struct VkPhysicalDeviceToolPropertiesEXT {
  VkStructureType s_type;
  void * p_next;
  CChar[256] name;
  CChar[256] version;
  VkToolPurposeFlagsEXT purposes;
  CChar[256] description;
  CChar[256] layer;
}

alias PFN_vkGetPhysicalDeviceToolPropertiesEXT = fn VkResult(
  VkPhysicalDevice physical_device, 
  uint * p_tool_count, 
  VkPhysicalDeviceToolPropertiesEXT * p_tool_properties);

fn VkResult get_physical_device_tool_properties_ext(
  VkPhysicalDevice physical_device, 
  uint * p_tool_count, 
  VkPhysicalDeviceToolPropertiesEXT * p_tool_properties)
@extern("vkGetPhysicalDeviceToolPropertiesEXT");

struct VkImageStencilUsageCreateInfoEXT {
  VkStructureType s_type;
  void * p_next;
  VkImageUsageFlags stencil_usage;
}

typedef VkValidationFeatureEnableEXT = inline CUInt;
const VkValidationFeatureEnableEXT VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT = 0;
const VkValidationFeatureEnableEXT VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT = 1;
const VkValidationFeatureEnableEXT VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT = 2;
const VkValidationFeatureEnableEXT VALIDATION_FEATURE_ENABLE_BEGIN_RANGE_EXT = VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT;
const VkValidationFeatureEnableEXT VALIDATION_FEATURE_ENABLE_END_RANGE_EXT = VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT;
const VkValidationFeatureEnableEXT VALIDATION_FEATURE_ENABLE_RANGE_SIZE_EXT = (VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT-VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT+1);
const VkValidationFeatureEnableEXT VALIDATION_FEATURE_ENABLE_MAX_ENUM_EXT = 0x7FFFFFFF;

typedef VkValidationFeatureDisableEXT = inline CUInt;
const VkValidationFeatureDisableEXT VALIDATION_FEATURE_DISABLE_ALL_EXT = 0;
const VkValidationFeatureDisableEXT VALIDATION_FEATURE_DISABLE_SHADERS_EXT = 1;
const VkValidationFeatureDisableEXT VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT = 2;
const VkValidationFeatureDisableEXT VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT = 3;
const VkValidationFeatureDisableEXT VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT = 4;
const VkValidationFeatureDisableEXT VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT = 5;
const VkValidationFeatureDisableEXT VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT = 6;
const VkValidationFeatureDisableEXT VALIDATION_FEATURE_DISABLE_BEGIN_RANGE_EXT = VALIDATION_FEATURE_DISABLE_ALL_EXT;
const VkValidationFeatureDisableEXT VALIDATION_FEATURE_DISABLE_END_RANGE_EXT = VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT;
const VkValidationFeatureDisableEXT VALIDATION_FEATURE_DISABLE_RANGE_SIZE_EXT = (VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT-VALIDATION_FEATURE_DISABLE_ALL_EXT+1);
const VkValidationFeatureDisableEXT VALIDATION_FEATURE_DISABLE_MAX_ENUM_EXT = 0x7FFFFFFF;

struct VkValidationFeaturesEXT {
  VkStructureType s_type;
  void * p_next;
  uint enabled_validation_feature_count;
  VkValidationFeatureEnableEXT * p_enabled_validation_features;
  uint disabled_validation_feature_count;
  VkValidationFeatureDisableEXT * p_disabled_validation_features;
}

typedef VkComponentTypeNV = inline CUInt;
const VkComponentTypeNV COMPONENT_TYPE_FLOAT16_NV = 0;
const VkComponentTypeNV COMPONENT_TYPE_FLOAT32_NV = 1;
const VkComponentTypeNV COMPONENT_TYPE_FLOAT64_NV = 2;
const VkComponentTypeNV COMPONENT_TYPE_SINT8_NV = 3;
const VkComponentTypeNV COMPONENT_TYPE_SINT16_NV = 4;
const VkComponentTypeNV COMPONENT_TYPE_SINT32_NV = 5;
const VkComponentTypeNV COMPONENT_TYPE_SINT64_NV = 6;
const VkComponentTypeNV COMPONENT_TYPE_UINT8_NV = 7;
const VkComponentTypeNV COMPONENT_TYPE_UINT16_NV = 8;
const VkComponentTypeNV COMPONENT_TYPE_UINT32_NV = 9;
const VkComponentTypeNV COMPONENT_TYPE_UINT64_NV = 10;
const VkComponentTypeNV COMPONENT_TYPE_BEGIN_RANGE_NV = COMPONENT_TYPE_FLOAT16_NV;
const VkComponentTypeNV COMPONENT_TYPE_END_RANGE_NV = COMPONENT_TYPE_UINT64_NV;
const VkComponentTypeNV COMPONENT_TYPE_RANGE_SIZE_NV = (COMPONENT_TYPE_UINT64_NV-COMPONENT_TYPE_FLOAT16_NV+1);
const VkComponentTypeNV COMPONENT_TYPE_MAX_ENUM_NV = 0x7FFFFFFF;

typedef VkScopeNV = inline CUInt;
const VkScopeNV SCOPE_DEVICE_NV = 1;
const VkScopeNV SCOPE_WORKGROUP_NV = 2;
const VkScopeNV SCOPE_SUBGROUP_NV = 3;
const VkScopeNV SCOPE_QUEUE_FAMILY_NV = 5;
const VkScopeNV SCOPE_BEGIN_RANGE_NV = SCOPE_DEVICE_NV;
const VkScopeNV SCOPE_END_RANGE_NV = SCOPE_QUEUE_FAMILY_NV;
const VkScopeNV SCOPE_RANGE_SIZE_NV = (SCOPE_QUEUE_FAMILY_NV-SCOPE_DEVICE_NV+1);
const VkScopeNV SCOPE_MAX_ENUM_NV = 0x7FFFFFFF;

struct VkCooperativeMatrixPropertiesNV {
  VkStructureType s_type;
  void * p_next;
  uint msize;
  uint nsize;
  uint ksize;
  VkComponentTypeNV atype;
  VkComponentTypeNV btype;
  VkComponentTypeNV ctype;
  VkComponentTypeNV dtype;
  VkScopeNV scope;
}

struct VkPhysicalDeviceCooperativeMatrixFeaturesNV {
  VkStructureType s_type;
  void * p_next;
  VkBool32 cooperative_matrix;
  VkBool32 cooperative_matrix_robust_buffer_access;
}

struct VkPhysicalDeviceCooperativeMatrixPropertiesNV {
  VkStructureType s_type;
  void * p_next;
  VkShaderStageFlags cooperative_matrix_supported_stages;
}

alias PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV = fn VkResult(
  VkPhysicalDevice physical_device, 
  uint * p_property_count, 
  VkCooperativeMatrixPropertiesNV * p_properties);

fn VkResult get_physical_device_cooperative_matrix_properties_nv(
  VkPhysicalDevice physical_device, 
  uint * p_property_count, 
  VkCooperativeMatrixPropertiesNV * p_properties)
@extern("vkGetPhysicalDeviceCooperativeMatrixPropertiesNV");

typedef VkCoverageReductionModeNV = inline CUInt;
const VkCoverageReductionModeNV COVERAGE_REDUCTION_MODE_MERGE_NV = 0;
const VkCoverageReductionModeNV COVERAGE_REDUCTION_MODE_TRUNCATE_NV = 1;
const VkCoverageReductionModeNV COVERAGE_REDUCTION_MODE_BEGIN_RANGE_NV = COVERAGE_REDUCTION_MODE_MERGE_NV;
const VkCoverageReductionModeNV COVERAGE_REDUCTION_MODE_END_RANGE_NV = COVERAGE_REDUCTION_MODE_TRUNCATE_NV;
const VkCoverageReductionModeNV COVERAGE_REDUCTION_MODE_RANGE_SIZE_NV = (COVERAGE_REDUCTION_MODE_TRUNCATE_NV-COVERAGE_REDUCTION_MODE_MERGE_NV+1);
const VkCoverageReductionModeNV COVERAGE_REDUCTION_MODE_MAX_ENUM_NV = 0x7FFFFFFF;

alias VkPipelineCoverageReductionStateCreateFlagsNV = VkFlags;

struct VkPhysicalDeviceCoverageReductionModeFeaturesNV {
  VkStructureType s_type;
  void * p_next;
  VkBool32 coverage_reduction_mode;
}

struct VkPipelineCoverageReductionStateCreateInfoNV {
  VkStructureType s_type;
  void * p_next;
  VkPipelineCoverageReductionStateCreateFlagsNV flags;
  VkCoverageReductionModeNV coverage_reduction_mode;
}

struct VkFramebufferMixedSamplesCombinationNV {
  VkStructureType s_type;
  void * p_next;
  VkCoverageReductionModeNV coverage_reduction_mode;
  VkSampleCountFlagBits rasterization_samples;
  VkSampleCountFlags depth_stencil_samples;
  VkSampleCountFlags color_samples;
}

alias PFN_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV = fn VkResult(
  VkPhysicalDevice physical_device, 
  uint * p_combination_count, 
  VkFramebufferMixedSamplesCombinationNV * p_combinations);

fn VkResult get_physical_device_supported_framebuffer_mixed_samples_combinations_nv(
  VkPhysicalDevice physical_device, 
  uint * p_combination_count, 
  VkFramebufferMixedSamplesCombinationNV * p_combinations)
@extern("vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV");

struct VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT {
  VkStructureType s_type;
  void * p_next;
  VkBool32 fragment_shader_sample_interlock;
  VkBool32 fragment_shader_pixel_interlock;
  VkBool32 fragment_shader_shading_rate_interlock;
}

struct VkPhysicalDeviceYcbcrImageArraysFeaturesEXT {
  VkStructureType s_type;
  void * p_next;
  VkBool32 ycbcr_image_arrays;
}

alias VkHeadlessSurfaceCreateFlagsEXT = VkFlags;

struct VkHeadlessSurfaceCreateInfoEXT {
  VkStructureType s_type;
  void * p_next;
  VkHeadlessSurfaceCreateFlagsEXT flags;
}

alias PFN_vkCreateHeadlessSurfaceEXT = fn VkResult(
  VkInstance instance, 
  VkHeadlessSurfaceCreateInfoEXT * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkSurfaceKHR * p_surface);

fn VkResult create_headless_surface_ext(
  VkInstance instance, 
  VkHeadlessSurfaceCreateInfoEXT * p_create_info, 
  VkAllocationCallbacks * p_allocator, 
  VkSurfaceKHR * p_surface)
@extern("vkCreateHeadlessSurfaceEXT");

typedef VkLineRasterizationModeEXT = inline CUInt;
const VkLineRasterizationModeEXT LINE_RASTERIZATION_MODE_DEFAULT_EXT = 0;
const VkLineRasterizationModeEXT LINE_RASTERIZATION_MODE_RECTANGULAR_EXT = 1;
const VkLineRasterizationModeEXT LINE_RASTERIZATION_MODE_BRESENHAM_EXT = 2;
const VkLineRasterizationModeEXT LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT = 3;
const VkLineRasterizationModeEXT LINE_RASTERIZATION_MODE_BEGIN_RANGE_EXT = LINE_RASTERIZATION_MODE_DEFAULT_EXT;
const VkLineRasterizationModeEXT LINE_RASTERIZATION_MODE_END_RANGE_EXT = LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT;
const VkLineRasterizationModeEXT LINE_RASTERIZATION_MODE_RANGE_SIZE_EXT = (LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT-LINE_RASTERIZATION_MODE_DEFAULT_EXT+1);
const VkLineRasterizationModeEXT LINE_RASTERIZATION_MODE_MAX_ENUM_EXT = 0x7FFFFFFF;

struct VkPhysicalDeviceLineRasterizationFeaturesEXT {
  VkStructureType s_type;
  void * p_next;
  VkBool32 rectangular_lines;
  VkBool32 bresenham_lines;
  VkBool32 smooth_lines;
  VkBool32 stippled_rectangular_lines;
  VkBool32 stippled_bresenham_lines;
  VkBool32 stippled_smooth_lines;
}

struct VkPhysicalDeviceLineRasterizationPropertiesEXT {
  VkStructureType s_type;
  void * p_next;
  uint line_sub_pixel_precision_bits;
}

struct VkPipelineRasterizationLineStateCreateInfoEXT {
  VkStructureType s_type;
  void * p_next;
  VkLineRasterizationModeEXT line_rasterization_mode;
  VkBool32 stippled_line_enable;
  uint line_stipple_factor;
  ushort line_stipple_pattern;
}

alias PFN_vkCmdSetLineStippleEXT = fn void(
  VkCommandBuffer command_buffer, 
  uint line_stipple_factor, 
  ushort line_stipple_pattern);

fn void cmd_set_line_stipple_ext(
  VkCommandBuffer command_buffer, 
  uint line_stipple_factor, 
  ushort line_stipple_pattern)
@extern("vkCmdSetLineStippleEXT");

struct VkPhysicalDeviceHostQueryResetFeaturesEXT {
  VkStructureType s_type;
  void * p_next;
  VkBool32 host_query_reset;
}

alias PFN_vkResetQueryPoolEXT = fn void(
  VkDevice device, 
  VkQueryPool query_pool, 
  uint first_query, 
  uint query_count);

fn void reset_query_pool_ext(
  VkDevice device, 
  VkQueryPool query_pool, 
  uint first_query, 
  uint query_count)
@extern("vkResetQueryPoolEXT");

struct VkPhysicalDeviceIndexTypeUint8FeaturesEXT {
  VkStructureType s_type;
  void * p_next;
  VkBool32 index_type_uint_8;
}

struct VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT {
  VkStructureType s_type;
  void * p_next;
  VkBool32 shader_demote_to_helper_invocation;
}

struct VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT {
  VkStructureType s_type;
  void * p_next;
  VkBool32 texel_buffer_alignment;
}

struct VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT {
  VkStructureType s_type;
  void * p_next;
  VkDeviceSize storage_texel_buffer_offset_alignment_bytes;
  VkBool32 storage_texel_buffer_offset_single_texel_alignment;
  VkDeviceSize uniform_texel_buffer_offset_alignment_bytes;
  VkBool32 uniform_texel_buffer_offset_single_texel_alignment;
}
